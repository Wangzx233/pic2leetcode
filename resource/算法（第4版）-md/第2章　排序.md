#第 2 章　排序

排序就是将一组对象按照某种逻辑顺序重新排列的过程。比如，信用卡账单中的交易是按照日期排序的——这种排序很可能使用了某种排序算法。在计算时代早期，大家普遍认为 30% 的计算周期都用在了排序上。如果今天这个比例降低了，可能的原因之一是如今的排序算法更加高效，而并非排序的重要性降低了。现在计算机的广泛使用使得数据无处不在，而整理数据的第一步通常就是进行排序。所有的计算机系统都实现了各种排序算法以供系统和用户使用。

即使你只是使用标准库中的排序函数，学习排序算法仍然有三大实际意义：

* 对排序算法的分析将有助于你全面理解本书中比较算法性能的方法；
* 类似的技术也能有效解决其他类型的问题；
* 排序算法常常是我们解决其他问题的第一步。

更重要的是这些算法都很经典、优雅和高效。排序在商业数据处理和现代科学计算中有着重要的地位，它能够应用于事物处理、组合优化、天体物理学、分子动力学、语言学、基因组学、天气预报和很多其他领域。其中一种排序算法（快速排序，见 2.3 节）甚至被誉为 20 世纪科学和工程领域的十大算法之一。

在本章中我们将学习几种经典的排序算法，并高效地实现了“优先队列”这种基础数据类型。我们将讨论比较排序算法的理论基础并在本章结尾总结若干排序算法和优先队列的应用。

##2.1　初级排序算法

作为对排序算法领域的第一次探索，我们将学习两种初级的排序算法以及其中一种的一个变体。深入学习这些相对简单的算法的原因在于：第一，我们将通过它们熟悉一些术语和简单的技巧；第二，这些简单的算法在某些情况下比我们之后将会讨论的复杂算法更有效；第三，以后你会发现，它们有助于我们改进复杂算法的效率。

###2.1.1　游戏规则

我们关注的主要对象是重新排列**数组元素**的算法，其中每个元素都有一个**主键**。排序算法的目标就是将所有元素的主键按照某种方式排列（通常是按照大小或是字母顺序）。排序后索引较大的主键大于等于索引较小的主键。元素和主键的具体性质在不同的应用中千差万别。在 Java 中，元素通常都是对象，对主键的抽象描述则是通过一种内置的机制（请见 2.1.1.4 节中的 `Comparable` 接口）来完成的。

“排序算法类模版”中的 `Example` 类展示了我们的习惯约定：我们会将排序代码放在类的 `sort()` 方法中，该类还将包含辅助函数 `less()` 和 `exch()`（可能还有其他辅助函数）以及一个示例用例 `main()`。`Example` 类还包含了一些早期调试使用的代码：测试用例 `main()` 将标准输入得到的字符串排序，并用私有方法 `show()` 打印字符数组的内容。我们还会在本章中遇到各种用于比较不同算法并研究它们的性能的测试用例。为了区别不同的排序算法，我们为相应的类取了不同的名字，用例可以根据名字调用不同的实现，例如 `Insertion.sort()`、`Merge.sort()`、`Quick.sort()` 等。

大多数情况下，我们的排序代码只会通过两个方法操作数据：`less()` 方法对元素进行比较，`exch()` 方法将元素交换位置。`exch()` 方法的实现很简单，通过 `Comparable` 接口实现 `less()` 方法也不困难。将数据操作限制在这两个方法中使得代码的可读性和可移植性更好，更容易验证代码的正确性、分析性能以及排序算法之间的比较。在学习具体的排序算法实现之前，我们先讨论几个对于所有排序算法都很重要的问题。

>**排序算法类的模板**

>```
>public class Example
>{
>    public static void sort(Comparable[] a)
>    {  /* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7*/  }
>
>    private static boolean less(Comparable v, Comparable w)
>    {  return v.compareTo(w) < 0;  }
>
>    private static void exch(Comparable[] a, int i, int j)
>    {  Comparable t = a[i]; a[i] = a[j]; a[j] = t;  }
>
>    private static void show(Comparable[] a)
>    {  // 在单行中打印数组
>       for (int i = 0; i < a.length; i++)
>          StdOut.print(a[i] + " ");
>       StdOut.println();
>    }
>    public static boolean isSorted(Comparable[] a)
>    {  // 测试数组元素是否有序
>       for (int i = 1; i < a.length; i++)
>          if (less(a[i], a[i-1]))  return false;
>       return true;
>    }
>    public static void main(String[] args)
>    {  // 从标准输入读取字符串，将它们排序并输出
>       String[] a = In.readStrings();
>       sort(a);
>       assert isSorted(a);
>       show(a);
>    }
>}
>```

>　

>```
>% more tiny.txt
>S O R T E X A M P L E
>
>% java Example < tiny.txt
>A E E L M O P R S T X
>
>% more words3.txt
>bed bug dad yes zoo ... all bad yet
>
>% java Example < words.txt
>all bad bed bug dad ... yes yet zoo
>```

>这个类展示的是数组排序实现的框架。对于我们学习的每种排序算法，我们都会为这样一个类实现一个 `sort()` 方法并将 `Example` 改为算法的名称。测试用例会将标准输入得到的字符串排序，但是这段代码使我们的排序方法适用于任意实现了 `Comparable` 接口的数据类型。

####2.1.1.1　验证

无论数组的初始状态是什么，排序算法都能成功吗？谨慎起见，我们会在测试代码中添加一条语句 `assert isSorted(a);` 来确认排序后数组元素都是有序的。尽管一般都会测试代码并从数学上证明算法的正确性，但在实现**每个**排序算法时加上这条语句仍然是必要的。需要注意的是，如果我们只使用 `exch()` 来交换数组的元素，这个测试就足够了。当我们直接将值存入数组中时，这条语句无法提供足够的保证（例如，把初始输入数组的元素全部置为相同的值也能通过这个测试）。

####2.1.1.2　运行时间

我们还要评估算法的**性能**。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数（包括比较和交换，或者是读写数组的次数）。然后，我们用这些数据来估计算法的相对性能并介绍在实验中验证这些猜想所使用的工具。对于大多数实现，代码风格一致会使我们更容易作出对性能的合理猜想。

>**排序成本模型**。在研究排序算法时，我们需要计算**比较**和**交换**的数量。对于不交换元素的算法，我们会计算**访问数组的次数**。

####2.1.1.3　额外的内存使用

排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类：除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的**原地排序算法**，以及需要额外内存空间来存储另一份数组副本的其他排序算法。

####2.1.1.4　数据类型

我们的排序算法模板适用于任何实现了 `Comparable` 接口的数据类型。遵守 Java 惯例的好处是很多你希望排序的数据都实现了 `Comparable` 接口。例如，Java 中封装数字的类型 `Integer` 和 `Double`，以及 `String` 和其他许多高级数据类型（如 `File` 和 `URL`）都实现了 `Comparable` 接口。因此你可以直接用这些类型的数组作为参数调用我们的排序方法。例如，右上方的代码使用了快速排序（请见 2.3 节）来对 `N` 个随机的 `Double` 数据进行排序。

```
Double a[] = new Double[N];
for (int i = 0; i < N; i++)
   a[i] = StdRandom.uniform();
Quick.sort(a);
```

{-:-}将![N](https://private.codecogs.com/gif.latex?N)个随机值的数组排序

在创建自己的数据类型时，我们只要实现 `Comparable` 接口就能够保证用例代码可以将其排序。要做到这一点，只需要实现一个 `compareTo()` 方法来定义目标类型对象的**自然次序**，如右侧的 `Date` 数据类型所示（参见表 1.2.12）。

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.001.png)

{-:-}定义一个可比较的数据类型

对于 `v<w`、`v=w` 和 `v>w` 三种情况，Java 的习惯是在 `v.compareTo(w)` 被调用时分别返回一个负整数、零和一个正整数（一般是 -1、0 和 1）。为了节约篇幅，我们接下来用 `v>w` 来表示 `v.compareTo(w)>0` 这样的代码。一般来说，如果 `v` 和 `w` 无法比较或者两者之一是 `null`，`v.compareTo(w)` 将会抛出一个异常。此外，`compareTo()` 必须实现一个**全序关系**，即：

* 自反性，对于所有的 `v`，`v=v`；
* 反对称性，对于所有的 `v<w` 都有 `v>w`，且 `v=w` 时 `w=v`；
* 传递性，对于所有的 `v`、`w` 和 `x`，如果 `v<=w` 且 `w<=x`，则 `v<=x`。

从数学上来说这些规则都很标准和自然，遵守它们应该不难。总之，`compareTo()` 实现了我们的**主键**抽象——它给出了实现了 `Comparable` 接口的任意数据类型的对象的大小顺序的定义。需要注意的是 `compareTo()` 方法不一定会用到进行比较的实例的所有实例变量，毕竟数组元素的主键很可能只是每个元素的一小部分。

本章剩余篇幅将会讨论对一组自然次序的对象进行排序的各种算法。为了比较和对照各种算法，我们会检查它们的许多性质，包括在各种输入下它们比较和交换数组元素的次数以及额外内存的使用量。通过这些我们能够对它们的性能作出猜想，而这些猜想在过去的数十年间已经在无数的计算机上被验证过了。所有的实现都是需要通过检验的，所以我们也会讨论相关的工具。在研究经典的选择排序、插入排序、希尔排序、归并排序、快速排序和堆排序之后，我们将在 2.5 节讨论一些实际的应用和问题。

###2.1.2　选择排序

一种最简单的排序算法是这样的：首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做**选择排序**，因为它在不断地选择剩余元素之中的最小者。

如算法 2.1 所示，选择排序的内循环只是在比较当前元素与目前已知的最小元素（以及将当前索引加 1 和检查是否代码越界），这已经简单到了极点。交换元素的代码写在内循环之外，每次交换都能排定一个元素，因此交换的总次数是 ![N](https://private.codecogs.com/gif.latex?N)。所以算法的时间效率取决于比较的次数。

>**命题 A**。对于长度为 ![N](https://private.codecogs.com/gif.latex?N) 的数组，选择排序需要大约 ![N^2/2](https://private.codecogs.com/gif.latex?N^2/2) 次比较和![N](https://private.codecogs.com/gif.latex?N)次交换。

>**证明**。可以通过算法的排序轨迹来证明这一点。我们用一张 ![N\times N](https://private.codecogs.com/gif.latex?N\times%20N) 的表格来表示排序的轨迹（见算法 2.1 下部的表格），其中每个非灰色字符都表示一次比较。表格中大约一半的元素不是灰色的——即对角线和其上部分的元素。对角线上的每个元素都对应着一次交换。通过查看代码我们可以更精确地得到，0 到 ![N-1](https://private.codecogs.com/gif.latex?N-1) 的任意 ![i](https://private.codecogs.com/gif.latex?i) 都会进行一次交换和 ![N-1-i](https://private.codecogs.com/gif.latex?N-1-i) 次比较，因此总共有 ![N](https://private.codecogs.com/gif.latex?N) 次交换以及 ![(N-1)+(N-2)+\cdots+2+1=N(N-1)/2\sim N^2/2](https://private.codecogs.com/gif.latex?(N-1%29+(N-2%29+\cdots+2+1=N(N-1%29/2\sim%20N^2/2) 次比较。

总的来说，选择排序是一种很容易理解和实现的简单排序算法，它有两个很鲜明的特点。

**运行时间和输入无关**。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶地发现，一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！我们将会看到，其他算法会更善于利用输入的初始状态。

**数据移动是最少的**。每次交换都会改变两个数组元素的值，因此选择排序用了 ![N](https://private.codecogs.com/gif.latex?N) 次交换——交换次数和数组的大小是**线性**关系。我们将研究的其他任何算法都不具备这个特征（大部分的增长数量级都是线性对数或是平方级别）。

>**算法 2.1　选择排序**

>```
>public class Selection
>{
>    public static void sort(Comparable[] a)
>    {  // 将a[]按升序排列
>       int N = a.length;               // 数组长度
>       for (int i = 0; i < N; i++)
>       {  // 将a[i]和a[i+1..N]中最小的元素交换
>          int min = i;                 // 最小元素的索引
>          for (int j = i+1; j < N; j++)
>             if (less(a[j], a[min])) min = j;
>          exch(a, i, min);
>       }
>    }
>    // less()、exch()、isSorted()和main()方法见“排序算法类模板”
>}
>```

>该算法将第 `i` 小的元素放到 `a[i]` 之中。数组的第 `i` 个位置的左边是 `i` 个最小的元素且它们不会再被访问。

>![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.002.png)

>{-:-}选择排序的轨迹（每次交换后的数组内容）

###2.1.3　插入排序

通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做**插入排序**，实现请见算法 2.2。

与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。

和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。

>**命题 B**。对于随机排列的长度为 ![N](https://private.codecogs.com/gif.latex?N) 且主键不重复的数组，平均情况下插入排序需要 ![\sim N^2/4](https://private.codecogs.com/gif.latex?\sim%20N^2/4) 次比较以及 ![\sim N^2/4](https://private.codecogs.com/gif.latex?\sim%20N^2/4) 次交换。最坏情况下需要 ![\sim N^2/2](https://private.codecogs.com/gif.latex?\sim%20N^2/2) 次比较和 ![\sim N^2/2](https://private.codecogs.com/gif.latex?\sim%20N^2/2) 次交换，最好情况下需要 ![N-1](https://private.codecogs.com/gif.latex?N-1) 次比较和 0 次交换。

>**证明**。和命题 A 一样，通过一个 ![N\times N](https://private.codecogs.com/gif.latex?N\times%20N) 的轨迹表可以很容易就得到交换和比较的次数。最坏情况下对角线之下所有的元素都需要移动位置，最好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度，因此交换总数是对角线之下的元素总数的二分之一。

>比较的总次数是交换的次数加上一个额外的项，该项为 ![N](https://private.codecogs.com/gif.latex?N) 减去被插入的元素正好是已知的最小元素的次数。在最坏情况下（逆序数组），这一项相对于总数可以忽略不计；在最好情况下（数组已经有序），这一项等于 ![N-1](https://private.codecogs.com/gif.latex?N-1)。

插入排序对于实际应用中常见的某些类型的非随机数组很有效。例如，正如刚才所提到的，想想当你用插入排序对一个有序数组进行排序时会发生什么。插入排序能够立即发现每个元素都已经在合适的位置之上，它的运行时间也是线性的（对于这种数组，选择排序的运行时间是平方级别的）。对于所有主键都相同的数组也会出现相同的情况（因此命题 B 的条件之一就是主键不重复）。

>**算法 2.2　插入排序**

>```
>public class Insertion
>{
>    public static void sort(Comparable[] a)
>    {  // 将a[]按升序排列
>       int N = a.length;
>       for (int i = 1; i < N; i++)
>       {  // 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中
>          for (int j = i; j > 0 && less(a[j], a[j-1]); j--)
>             exch(a, j, j-1);
>       }
>    }
>    // less()、exch()、isSorted()和main()方法见“排序算法类模板”
>}
>```

>对于 `1` 到 `N-1` 之间的每一个 `i`，将 `a[i]` 与 `a[0]` 到 `a[i-1]` 中比它小的所有元素依次有序地交换。在索引 `i` 由左向右变化的过程中，它左侧的元素总是有序的，所以当 `i` 到达数组的右端时排序就完成了。

>![{75%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.003.png)

>{-:-}插入排序的轨迹（每次插入后的数组内容）

我们要考虑的更一般的情况是**部分有序**的数组。**倒置**指的是数组中的两个顺序颠倒的元素。比如 E X A M P L E 中有 11 对倒置：E-A、X-A、X-M、X-P、X-L、X-E、M-L、M-E、P-L、P-E 以及 L-E。如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。下面是几种典型的部分有序的数组：

* 数组中每个元素距离它的最终位置都不远；
* 一个有序的大数组接一个小数组；
* 数组中只有几个元素的位置不正确。

插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快。

>**命题 C**。插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。

>**证明**。每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为 0 时，排序就完成了。每次交换都对应着一次比较，且 `1` 到 `N-1` 之间的每个 `i` 都可能需要一次额外的比较（在 `a[i]` 没有达到数组的左端时）。

要大幅提高插入排序的速度并不难，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素（这样访问数组的次数就能减半）。我们把这项改进留做一个练习（请见练习 2.1.25）。

总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组。这很重要，因为这些类型的数组在实际应用中经常出现，而且它们也是高级排序算法的中间过程。我们会在学习高级排序算法时再次接触到插入排序。

###2.1.4　排序算法的可视化

在本章中我们会使用一种简单的图示来帮助我们说明排序算法的性质。我们没有使用字母、数字或是单词这样的键值来跟踪排序的进程，而使用了棒状图，并以它们的高矮来排序。这种表示方法的好处是能够使排序过程一目了然。

如图 2.1.1 所示，插入排序不会访问索引右侧的元素，而选择排序不会访问索引左侧的元素。另外，在这种可视化的轨迹图中可以看到，因为插入排序不会移动比被插入的元素更小的元素，它所需的比较次数平均只有选择排序的一半。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.004.png)

**图 2.1.1　初级排序算法的可视轨迹图**

用我们的 StdDraw 库画出一张可视轨迹图并不比追踪一次算法的运行轨迹难多少。将 `Double` 值排序，并在适当的时候指示算法调用 `show()` 方法（和追踪算法的轨迹时一样），然后开发一个使用 StdDraw 来绘制棒状图而不是打印结果的 `show()` 方法。最复杂的部分是设置 ![y](https://private.codecogs.com/gif.latex?y) 轴的比例以使轨迹的线条符合预期的顺序。请通过练习 2.1.18 来更好地理解可视轨迹图的价值和使用。

将轨迹变成**动画**，理解起来就更加简单，这样可以看到动态演化到有序状态的过程。产生轨迹动画的过程本质上和上一段所描述的相同，但不需要担心 ![y](https://private.codecogs.com/gif.latex?y) 轴的问题（只需每次擦除窗口中的内容并重绘棒状图即可）。尽管我们无法在书中展现这些动画，它们对于理解算法的工作原理也很有帮助，你能通过练习 2.1.17 体会这一点。

###2.1.5　比较两种排序算法

现在我们已经实现了两种排序算法，我们很自然地想知道选择排序（算法 2.1）和插入排序（算法 2.2）哪种更快。这个问题在学习算法的过程中会反复出现，也是本书的重点之一。我们已经在第 1 章中讨论过一些基本的概念，这里我们第一次用实践说明我们解决这个问题的办法。一般来说，根据 1.4 节所介绍的方法，我们将通过以下步骤比较两个算法：

* 实现并调试它们；
* 分析它们的基本性质；
* 对它们的相对性能作出猜想；
* 用实验验证我们的猜想。

这些步骤都是经过时间检验的**科学方法**，只是现在是运用在算法研究之上。

现在，算法 2.1 和算法 2.2 表示已经实现了第一步，命题 A、命题 B 和命题 C 组成了第二步，下面的性质 D 将是第三步，之后“比较两种排序算法”的 `SortCompare` 类将会完成第四步。这些行为都是紧密相关的。

在这些简洁的步骤之下是大量的算法实现、调试分析和测试工作。每个程序员都知道只有经过长期的调试和改进才能得到这样的代码，每个数学家都知道正确分析的难度，每个科学家也都知道从提出猜想到设计并执行实验来验证它们是多么费心。只有研究那些最重要的算法的专家才会经历完整的研究过程，但每个使用算法的程序员都应该了解算法的性能特性背后的科学过程。

实现了算法之后，下一步我们需要确定一个适当的输入模型。对于排序，命题 A、命题 B 和命题 C 用到的自然输入模型假设数组中的元素随机排序，且主键值不会重复。对于有很多重复主键的应用来说，我们需要一个更加复杂的模型。

如何估计插入排序和选择排序在随机排序数组下的性能呢？通过算法 2.1 和算法 2.2 以及命题 A、命题 B 和命题 C 可以发现，对于随机排序数组，两者的运行时间都是平方级别的。也就是说，在这种输入下插入排序的运行时间和 ![N^2](https://private.codecogs.com/gif.latex?N^2) 乘以一个小常数成正比，选择排序的运行时间和 ![N^2](https://private.codecogs.com/gif.latex?N^2) 乘以另一个小常数成比例。这两个常数的值取决于所使用的计算机中比较和交换元素的成本。对于许多数据类型和一般的计算机，可以假设这些成本是相近的（但我们也会看到一些大不相同的例外）。因此我们直接得出了以下猜想。

>**性质 D**。对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。

>**例证**。这个结论在过去的半个世纪中已经在许多不同类型的计算机上经过了验证。在 1980 年本书第 1 版完成之时插入排序就比选择排序快一倍，现在仍然是这样，尽管那时这些算法将 10 万条数据排序需要几个小时而现在只需要几秒钟。在你的计算机上插入排序也比选择排序快一些吗？可以通过 `SortCompare` 类来检测。它会使用由命令行参数指定的排序算法名称所对应的 `sort()` 方法进行指定次数的实验（将指定大小的数组排序），并打印出所观察到的各种算法的运行时间的比例。

为了证明这一点，我们用 `SortCompare`（见“比较两种排序算法”）来做几次实验。我们使用 `Stopwatch` 来计时，右侧的 `time()` 函数的任务是调用本章中的几种简单排序算法。

>```
public static double time(String alg, Comparable[] a)
{
   Stopwatch timer = new Stopwatch();
   if (alg.equals("Insertion")) Insertion.sort(a);
   if (alg.equals("Selection")) Selection.sort(a);
   if (alg.equals("Shell"))     Shell.sort(a);
   if (alg.equals("Merge"))     Merge.sort(a);
   if (alg.equals("Quick"))     Quick.sort(a);
   if (alg.equals("Heap"))      Heap.sort(a);
   return timer.elapsedTime();
}
>```

>{-:-}针对给定输入，为本章中的一种排序算法计时

随机数组的输入模型由 `SortCompare` 类中的 `timeRandomInput()` 方法实现。这个方法会生成随机的 `Double` 值，将它们排序，并返回指定次测试的总时间。使用 0.0 至 1.0 之间的随机 `Double` 值比使用类似于 `StdRandom.shuffle()` 的库函数更简单有效，因为这样几乎不可能产生相等的主键值（请见练习 2.5.31）。如第 1 章中所讨论的，用命令行参数指定重复次数的好处是能够运行大量的测试（测试次数越多，每遍测试所需的平均时间就越接近于真实的平均数据）并且能够减小系统本身的影响。你应该在自己的计算机上用 `SortCompare` 进行实验，来了解关于插入排序和选择排序的结论是否成立。

>**比较两种排序算法**

>```
>public class SortCompare
>{
>    public static double time(String alg, Double[] a)
>    {  /* 请见前面的正文 */  }
>
>    public static double timeRandomInput(String alg, int N, int T)
>    {  // 使用算法alg将T个长度为N的数组排序
>       double total = 0.0;
>       Double[] a = new Double[N];
>       for (int t = 0; t < T; t++)
>       {  // 进行一次测试（生成一个数组并排序)
>          for (int i = 0; i < N; i++)
>             a[i] = StdRandom.uniform();
>          total += time(alg, a);
>       }
>       return total;
>    }
>
>    public static void main(String[] args)
>    {
>       String alg1 = args[0];
>       String alg2 = args[1];
>       int N = Integer.parseInt(args[2]);
>       int T = Integer.parseInt(args[3]);
>       double t1 = timeRandomInput(alg1, N, T); // 算法1的总时间
>       double t2 = timeRandomInput(alg2, N, T); // 算法2的总时间
>       StdOut.printf(“For %d random Doubles\n    %s is”, N, alg1);
>       StdOut.printf(“ %.1f times faster than %s\n”, t2/t1, alg2);
>    }
>}
>```

>这个用例会运行由前两个命令行参数指定的排序算法，对长度为 `N`（由第三个参数指定）的 `Double` 型随机数组进行排序，元素值均在 0.0 到 1.0 之间，重复 `T` 次（由第四个参数指定），然后输出总运行时间的比例。

>```
>% java SortCompare Insertion Selection 1000 100
>For 1000 random Doubles
>   Insertion is 1.7 times faster than Selection
>```

我们故意将性质 D 描述得不够明确——没有说明那个小常量的值，以及对比较和交换的成本相近的假设，这样性质 D 才能广泛适用于各种情况。可能的话，我们会尽量用这样的语言来抓住我们所研究的每个算法的性能的本质。如第 1 章中讨论的那样，我们提出的每个性质都需要在特定的场景中进行科学测试，也许还需要用一个基于相关**命题**（数学定理）的猜想进行补充。

对于实际应用，还有一个很重要的步骤，**那就是用实际数据在实验中验证我们的猜想**。我们会在 2.5 节和练习中再考虑这一点。在这种情况下，当主键有重复或是排列不随机，性质 D 就可能会不成立。可以使用 `StdRandom.shuffle()` 来将一个数组打乱，但有大量重复主键的情况则需要更加细致的分析。

我们对算法分析的讨论是抛砖引玉，而非盖棺定论。如果你想到了关于算法性能的其他问题，可以用 `SortCompare` 等工具来研究它，后面的练习为你提供了许多机会。

插入排序和选择排序的性能比较就讨论到这里，还存在许多比它们快成千上万倍的算法，我们对此会更感兴趣。当然，仍然有必要学习这些初级算法，因为：

* 它们帮助我们建立了一些基本的规则；
* 它们展示了一些性能基准；
* 在某些特殊情况下它们也是很好的选择；
* 它们是开发更强大的排序算法的基石。

因此，不止是排序，对于本书中的每个问题我们都会沿用这种方式，首先学习的就是最初级的相关算法。`SortCompare` 这样的程序对于这种渐进式的算法研究十分重要。每一步，我们都能用这类程序来了解新的或是改进后的算法的性能是否产生了预期的进步。

###2.1.6　希尔排序

为了展示初级排序算法性质的价值，接下来我们将学习一种基于插入排序的快速的排序算法。对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要 ![N-1](https://private.codecogs.com/gif.latex?N-1) 次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 **h 有序数组**。换句话说，一个 **h 有序数组**就是 h 个互相独立的有序数组编织在一起组成的一个数组（见图 2.1.2）。在进行排序时，如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 **h 有序**创造方便。用这种方式，对于任意以 1 结尾的 h 序列，我们都能够将数组排序。这就是希尔排序。算法 2.3 的实现使用了序列 ![1/2(3^k-1)](https://private.codecogs.com/gif.latex?1/2(3^k-1%29)，从 ![N/3](https://private.codecogs.com/gif.latex?N/3) 开始递减至 1。我们把这个序列称为**递增序列**。算法 2.3 实时计算了它的**递增序列**，另一种方式是将递增序列存储在一个数组中。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.005.png)

**图 2.1.2　一个 h 有序数组即一个由 h 个有序子数组组成的数组**

实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在 h- 子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。

希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。子数组部分有序的程度取决于递增序列的选择。透彻理解希尔排序的性能至今仍然是一项挑战。实际上，算法 2.3 是我们唯一无法准确描述其对于乱序的数组的性能特征的排序方法。

>**算法 2.3　希尔排序**

>```
>public class Shell
>{
>    public static void sort(Comparable[] a)
>    {  // 将a[]按升序排列
>       int N = a.length;
>       int h = 1;
>       while (h < N/3) h = 3*h + 1; // 1, 4, 13, 40, 121, 364, 1093, ...
>       while (h >= 1)
>       {  // 将数组变为h有序
>          for (int i = h; i < N; i++)
>          {  // 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中
>             for (int j = i; j >= h && less(a[j], a[j-h]); j -= h)
>                exch(a, j, j-h);
>          }
>          h = h/3;
>       }
>    }
>
>    // less()、exch()、isSorted()和main()方法见“排序算法类模板”
>
>}
>```

>如果我们在插入排序（算法 2.2）中加入一个外循环来将 h 按照递增序列递减，我们就能得到这个简洁的希尔排序。增幅 h 的初始值是数组长度乘以一个常数因子，最小为 1。

>```
>% java SortCompare Shell Insertion 100000 100
>For 100000 random Doubles
>   Shell is 600 times faster than Insertion
>```

>![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.006.png)

>**希尔排序的轨迹（每遍排序后的数组内容）**

如何选择递增序列呢？要回答这个问题并不简单。算法的性能不仅取决于 h，还取决于 h 之间的数学性质，比如它们的公因子等。有很多论文研究了各种不同的递增序列，但都无法证明某个序列是“最好的”。算法 2.3 中递增序列的计算和使用都很简单，和复杂递增序列的性能接近。但可以证明复杂的序列在最坏情况下的性能要好于我们所使用的递增序列。更加优秀的递增序列有待我们去发现。

和选择排序以及插入排序形成对比的是，希尔排序也可以用于大型数组。它对任意排序（不一定是随机的）的数组表现也很好。实际上，对于一个给定的递增序列，构造一个使希尔排序运行缓慢的数组并不容易。希尔排序的轨迹如图 2.1.3 所示，可视轨迹如图 2.1.4 所示。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.007.png)

**图 2.1.3　希尔排序的详细轨迹（各种插入）**

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.008.png)

**图 2.1.4　希尔排序的可视轨迹**

通过 `SortCompare` 可以看到，希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。在继续学习之前，请在你的计算机上用 `SortCompare` 比较一下希尔排序和插入排序以及选择排序的性能，数组的大小按照 2 的幂次递增（见练习 2.1.27）。你会看到希尔排序能够解决一些初级排序算法无能为力的问题。这个例子是我们第一次用实际应用说明一个贯穿本书的重要理念：**通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因之一**。

研究希尔排序性能需要的数学论证超出了本书范围。如果你不相信，可以从证明下面这一点开始：**当一个“h 有序”的数组按照增幅 k 排序之后，它仍然是“h 有序”的**。至于算法 2.3 的性能，目前最重要的结论是**它的运行时间达不到平方级别**。例如，已知在最坏的情况下算法 2.3 的比较次数和 ![N^{3/2}](https://private.codecogs.com/gif.latex?N^{3/2}) 成正比。有意思的是，由插入排序到希尔排序，一个小小的改变就突破了平方级别的运行时间的屏障。这正是许多算法设计问题想要达到的目标。

在输入随机排序数组的情况下，我们在数学上还不知道希尔排序所需要的平均比较次数。人们发明了很多递增序列来渐进式地改进最坏情况下所需的比较次数（![N^{4/3},~N^{5/4},~N^{6/5}\cdots](https://private.codecogs.com/gif.latex?N^{4/3},~N^{5/4},~N^{6/5}\cdots)），但这些结论大多只有学术意义，因为对于实际应用中的 ![N](https://private.codecogs.com/gif.latex?N) 来说它们的递增序列的生成函数（以及与 ![N](https://private.codecogs.com/gif.latex?N) 乘以一个常数因子）之间的区别并不明显。

在实际应用中，使用算法 2.3 中的递增序列基本就足够了（或者是本节最后的练习中提供的一个递增序列，它可能可以将性能改进 20% ～ 40%）。另外，很容易就能验证下面这个猜想。

>**性质 E**。使用递增序列 1, 4, 13, 40, 121, 364… 的希尔排序所需的比较次数不会超出N的若干倍乘以递增序列的长度。

>**例证**。记录算法2.3中比较的数量并将其除以使用的序列长度是一道简单的练习（请见练习 2.1.12）。大量的实验证明平均每个增幅所带来的比较次数约为 ![N^{1/5}](https://private.codecogs.com/gif.latex?N^{1/5})，但只有在N很大的时候这个增长幅度才会变得明显。这个性质似乎也和输入模型无关。

有经验的程序员有时会选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。在下面的几节中我们会看到更加高效的算法，但除了对于很大的 ![N](https://private.codecogs.com/gif.latex?N)，它们可能只会比希尔排序快两倍（可能还达不到），而且更复杂。如果你需要解决一个排序问题而又没有系统排序函数可用（例如直接接触硬件或是运行于嵌入式系统中的代码），可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。

###答疑

**问**　排序看起来是个很简单的问题，我们用计算机不是可以做很多更有意思的事情吗？

**答**　也许吧，但快速的排序算法才使得那些更有意思的事情**成为可能**。在 2.5 节以及全书的其他章节你都可以找到很多这样的例子。排序算法今天仍然值得我们学习是因为它易于理解，你能从中领会到许多精妙之处。

**问**　为什么有这么多排序算法？

**答**　原因之一是许多排序算法的性能都和输入模型有很大的关系，因此不同的算法适用于不同应用场景中的不同输入。例如，对于部分有序和小规模的数组应该选择插入排序。其他限制条件，例如空间和重复的主键，也都是需要考虑的因素。我们将会在 2.5 节中再次讨论这个问题。

**问**　为什么要使用 `less()` 和 `exch()` 这些不起眼的辅助函数？

**答**　它们抽象了所有排序算法都会用到的共同操作，这种抽象使得代码更便于理解。而且它们增强了代码的可移植性。例如，算法 2.1 和算法 2.2 中的大部分代码在其他几种编程语言中也是可以执行的。即使是在 Java 中，只要将 `less()` 实现为 `v < w`，这些算法的代码就可以将不支持 `Comparable` 接口的基本数据类型排序了。

**问**　当我运行 `SortCompare` 时，每次的结果都不一样（而且和书上的也不相同），为什么？

**答**　对于初学者，你的计算机和我们的计算机不同，操作系统、Java 运行时环境等都不一样。这些不同可能导致算法代码生成的机器码不同。每次运行所得结果不同的原因可能在于当时运行的其他程序或是很多其他原因。大量的重复实验可以淡化这种干扰，我们的经验是现如今算法性能的微小差异很难观察。这就是我们要关注较大差异的原因。

###练习

**2.1.1**　按照算法 2.1 所示轨迹的格式给出选择排序是如何将数组 `E A S Y Q U E S T I O N` 排序的。

**2.1.2**　在选择排序中，一个元素最多可能会被交换多少次？平均可能会被交换多少次？

**2.1.3**　构造一个含有 ![N](https://private.codecogs.com/gif.latex?N) 个元素的数组，使选择排序（算法 2.1）运行过程中 `a[j] < a[min]`（由此 `min` 会不断更新）成功的次数最大。

**2.1.4**　按照算法 2.2 所示轨迹的格式给出插入排序是如何将数组 `E A S Y Q U E S T I O N` 排序的。

**2.1.5**　构造一个含有 ![N](https://private.codecogs.com/gif.latex?N) 个元素的数组，使插入排序（算法 2.2）运行过程中内循环（`for`）的两个判断结果总是假。

**2.1.6**　在所有的主键都相同时，选择排序和插入排序谁更快？

**2.1.7**　对于逆序数组，选择排序和插入排序谁更快？

**2.1.8**　假设元素只可能有三种值，使用插入排序处理这样一个随机数组的运行时间是线性的还是平方级别的？或是介于两者之间？

**2.1.9**　按照算法 2.3 所示轨迹的格式给出希尔排序是如何将数组 `E A S Y S H E L L S O R T Q U E S T I O N` 排序的。

**2.1.10**　在希尔排序中为什么在实现 **h 有序**时不使用选择排序？

**2.1.11**　将希尔排序中实时计算递增序列改为预先计算并存储在一个数组中。

**2.1.12**　令希尔排序打印出递增序列的每个元素所带来的比较次数和数组大小的比值。编写一个测试用例对随机 `Double` 数组进行希尔排序，验证该值是一个小常数，数组大小按照 10 的幂次递增，不小于 100。

###提高题

**2.1.13**　**纸牌排序**。说说你会如何将一副扑克牌按花色排序（花色顺序是黑桃、红桃、梅花和方片），限制条件是所有牌都是背面朝上排成一列，而你一次只能翻看两张牌或者交换两张牌（保持背面朝上）。

**2.1.14**　**出列排序**。说说你会如何将一副扑克牌排序，限制条件是只能查看最上面的两张牌，交换最上面的两张牌，或是将最上面的一张牌放到这摞牌的最下面。

**2.1.15**　**昂贵的交换**。一家货运公司的一位职员得到了一项任务，需要将若干大货箱按照发货时间摆放。比较发货时间很容易（对照标签即可），但将两个货箱交换位置则很困难（移动麻烦）。仓库已经快满了，只有一个空闲的仓位。这位职员应该使用哪种排序算法呢？

**2.1.16**　**验证**。编写一个 `check()` 方法，调用 `sort()` 对任意数组排序。如果排序成功而且数组中的所有对象均没有被修改则返回 `true`，否则返回 `false`。不要假设 `sort()` 只能通过 `exch()` 来移动数据，可以信任并使用 `Arrays.sort()`。

**2.1.17**　**动画**。修改插入排序和选择排序的代码，使之将数组内容绘制成正文中所示的棒状图。在每一轮排序后重绘图片来产生动画效果，并以一张“有序”的图片作为结束，即所有圆棒均已按照高度有序排列。**提示**：使用类似于正文中的用例来随机生成 `Double` 值，在排序代码的适当位置调用 `show()` 方法，并在 `show()` 方法中清理画布并绘制棒状图。

**2.1.18**　**可视轨迹**。修改你为上一题给出的解答，为插入排序和选择排序生成和正文中类似的可视轨迹。**提示**：使用 `setYscale()` 函数是一个明智的选择。**附加题**：添加必要的代码，与正文中的图片一样用红色和灰色强调不同角色的元素。

**2.1.19**　**希尔排序的最坏情况**。用 1 到 100 构造一个含有 100 个元素的数组并用希尔排序和递增序列 `1 4 13 40` 对其排序，使比较的次数尽可能多。

**2.1.20**　**希尔排序的最好情况**。最好情况是什么？证明你的结论。

**2.1.21**　**可比较的交易**。用我们的 `Date` 类（请见 2.1.1.4 节）作为模板扩展你的 `Transaction` 类（请见练习 1.2.13），实现 `Comparable` 接口，使交易能够按照金额排序。

　　　**解答**：

```
public class Transaction implements Comparable<Transaction>
{
   ...
   private final double amount;
   ...
   public int compareTo(Transaction that)
   {
      if (this.amount > that.amount) return +1;
      if (this.amount < that.amount) return -1;
      return 0;
   }
   ...
}
```

**2.1.22**　**交易排序测试用例**。编写一个 `SortTransaction` 类，在静态方法 `main()` 中从标准输入读取一系列交易，将它们排序并在标准输出中打印结果（请见练习 1.3.17）。

　　　**解答**：

```
public class SortTransactions
{
   public static Transaction[] readTransactions()
   {  // 请见练习1.3.17  }
   public static void main(String[] args)
   {
      Transaction[] transactions = readTransactions();
      Shell.sort(transactions);
      for (Transaction t : transactions)
         StdOut.println(t);
   }
}
```

###实验题

**2.1.23**　**纸牌排序**。请几位朋友分别将一副扑克牌排序（见练习 2.1.13）。仔细观察并记录他们所使用的方法。

**2.1.24**　**插入排序的哨兵**。在插入排序的实现中先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件 `j>0`。使用 `SortCompare` 来评估这种做法的效果。**注意**：这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为**哨兵**。

**2.1.25**　**不需要交换的插入排序**。在插入排序的实现中使较大元素右移一位只需要访问一次数组（而不用使用 `exch()`）。使用 `SortCompare` 来评估这种做法的效果。

**2.1.26**　**原始数据类型**。编写一个能够处理 `int` 值的插入排序的新版本，比较它和正文中所给出的实现（能够隐式地用自动装箱和拆箱转换 `Integer` 值并排序）的性能。

**2.1.27**　**希尔排序的用时是次平方级的**。在你的计算机上用 `SortCompare` 比较希尔排序和插入排序以及选择排序。测试数组的大小按照 2 的幂次递增，从 128 开始。

**2.1.28**　**相等的主键**。对于主键仅可能取两种值的数组，评估和验证插入排序和选择排序的性能，假设两种主键值出现的概率相同。

**2.1.29**　**希尔排序的递增序列**。通过实验比较算法 2.3 中所使用的递增序列和递增序列 1，5，19，41，109，209，505，929，2161，3905，8929，16 001，36 289，64 769，146 305，260 609（这是通过序列 ![0\times4^k-9\times2^k+1](https://private.codecogs.com/gif.latex?0\times4^k-9\times2^k+1) 和 ![4^k-3\times2^k+1](https://private.codecogs.com/gif.latex?4^k-3\times2^k+1) 综合得到的）。可以参考练习 2.1.11。

**2.1.30**　**几何级数递增序列**。通过实验找到一个 ![t](https://private.codecogs.com/gif.latex?t)，使得对于大小为 ![N=10^6](https://private.codecogs.com/gif.latex?N=10^6) 的任意随机数组，使用递增序列 1，![\lfloor t \rfloor](https://private.codecogs.com/gif.latex?\lfloor%20t%20\rfloor)，![\lfloor t^2 \rfloor](https://private.codecogs.com/gif.latex?\lfloor%20t^2%20\rfloor)，![\lfloor t^3 \rfloor](https://private.codecogs.com/gif.latex?\lfloor%20t^3%20\rfloor)，![\lfloor t^4 \rfloor](https://private.codecogs.com/gif.latex?\lfloor%20t^4%20\rfloor)，…的希尔排序的运行时间最短。给出你能找到的三个最佳 ![t](https://private.codecogs.com/gif.latex?t) 值以及相应的递增序列。

　　　**以下**练习描述的是各种用于评估排序算法的测试用例。它们的作用是用随机数据帮助你增进对性能特性的理解。随着命令行指定的实验次数的增大，可以和 `SortCompare` 一样在它们中使用 `time()` 函数来得到更精确的结果。在以后的几节中我们会使用这些练习来评估更加复杂的算法。

**2.1.31**　**双倍测试**。编写一个能够对排序算法进行双倍测试的用例。数组规模 `N` 的起始值为 1000，排序后打印 `N`、估计排序用时、实际排序用时以及在 `N` 增倍之后两次用时的比例。用这段程序验证在随机输入模型下插入排序和选择排序的运行时间都是平方级别的。对希尔排序的性能作出猜想并验证你的猜想。

**2.1.32**　**运行时间曲线图**。编写一个测试用例，使用 StdDraw 在各种不同规模的随机输入下将算法的平均运行时间绘制成一张曲线图。可能需要添加一两个命令行参数，请尽量设计一个实用的工具。

**2.1.33**　**分布图**。对于你为练习 2.1.33 给出的测试用例，在一个无穷循环中调用 `sort()` 方法将由第三个命令行参数指定大小的数组排序，记录每次排序的用时并使用 `StdDraw` 在图上画出所有平均运行时间，应该能够得到一张运行时间的**分布图**。

**2.1.34**　**罕见情况**。编写一个测试用例，调用 `sort()` 方法对实际应用中可能出现困难或极端情况的数组进行排序。比如，数组可能已经是有序的，或是逆序的，数组的所有主键相同，数组的主键只有两种值，大小为 0 或是 1 的数组。

**2.1.35**　**不均匀的概率分布**。编写一个测试用例，使用非均匀分布的概率来生成随机排列的数据，包括：

* 高斯分布；
* 泊松分布；
* 几何分布；
* 离散分布（一种特殊情况请见练习 2.1.28）。

　　　评估并验证这些输入数据对本节讨论的算法的性能的影响。

**2.1.36**　**不均匀的数据**。编写一个测试用例，生成不均匀的测试**数据**，包括：

* 一半数据是 0，一半是 1；
* 一半数据是 0，1/4 是 1，1/4 是 2，以此类推；
* 一半数据是 0，一半是随机 `int` 值。

　　　评估并验证这些输入数据对本节讨论的算法的性能的影响。

**2.1.37**　**部分有序**。编写一个测试用例，生成部分有序的数组，包括：

* 95% 有序，其余部分为随机值；
* 所有的元素和它们的正确位置的距离都不超过 10；
* 5% 的元素随机分布在整个数组中，剩下的数据都是有序的。

　　　评估并验证这些输入数据对本节讨论的算法的性能的影响。

**2.1.38**　**不同类型的元素**。编写一个测试用例，生成由多种数据类型元素组成的数组，元素的主键值随机，包括：

* 每个元素的主键均为 `String` 类型（至少长 10 个字符），并含有一个 `double` 值；
* 每个元素的主键均为 `double` 类型，并含有 10 个 `String` 值（每个都至少长 10 个字符）；
* 每个元素的主键均为 `int` 类型，并含有一个 `int[20]` 值

　　　评估并验证这些输入数据对本节讨论的算法的性能的影响。

##2.2　归并排序

在本节中我们所讨论的算法都基于**归并**这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：**归并排序**。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。你将会看到，归并排序最吸引人的性质是它能够保证将任意长度为 ![N](https://private.codecogs.com/gif.latex?N) 的数组排序所需时间和 ![N\log N](https://private.codecogs.com/gif.latex?N\log%20N) 成正比；它的主要缺点则是它所需的额外空间和 ![N](https://private.codecogs.com/gif.latex?N) 成正比。简单的归并排序如图 2.2.1 所示。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.009.png)

**图 2.2.1　归并排序示意图**

###2.2.1　原地归并的抽象方法

实现归并的一种直截了当的办法是将两个不同的有序数组归并到第三个数组中，两个数组中的元素应该都实现了 `Comparable` 接口。实现的方法很简单，创建一个适当大小的数组然后将两个输入数组中的元素一个个从小到大放入这个数组中。

但是，当用归并将一个大数组排序时，我们需要进行很多次归并，因此在每次归并时都创建一个新数组来存储排序结果会带来问题。我们更希望有一种能够在原地归并的方法，这样就可以先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的空间。你可以先停下来想想应该如何实现这一点，乍一看很容易做到，但实际上已有的实现都非常复杂，尤其是和使用额外空间的方法相比。

尽管如此，将原地归并**抽象化**仍然是有帮助的。与之对应的是我们的方法签名 `merge(a, lo, mid, hi)`，它会将子数组 `a[lo..mid]` 和 `a[mid+1..hi]` 归并成一个有序的数组并将结果存放在 `a[lo..hi]` 中。下面的代码只用几行就实现了这种归并。它将涉及的所有元素复制到一个辅助数组中，再把归并的结果放回原数组中。实现的另一种方法请见练习 2.2.10。

>**原地归并的抽象方法**

>```
>public static void merge(Comparable[] a, int lo, int mid, int hi)
>{  // 将a[lo..mid] 和 a[mid+1..hi] 归并
>    int i = lo, j = mid+1;
>
>    for (int k = lo; k <= hi; k++)  // 将a[lo..hi]复制到aux[lo..hi]
>       aux[k] = a[k];
>
>    for (int k = lo; k <= hi; k++)  // 归并回到a[lo..hi]
>       if      (i > mid)              a[k] = aux[j++];
>       else if (j > hi )              a[k] = aux[i++];
>       else if (less(aux[j], aux[i])) a[k] = aux[j++];
>       else a[k] =                    aux[i++];
>}
>```

>该方法先将所有元素复制到 `aux[]` 中，然后再归并回 `a[]` 中。方法在归并时（第二个 `for` 循环）进行了 4 个条件判断：左半边用尽（取右半边的元素）、右半边用尽（取左半边的元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）以及右半边的当前元素大于等于左半边的当前元素（取左半边的元素）。

>![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.010.png)

>**原地归并的抽象方法的轨迹**

###2.2.2　自顶向下的归并排序

算法 2.4 基于原地归并的抽象实现了另一种递归归并，这也是应用高效算法设计中**分治思想**的最典型的一个例子。这段递归代码是归纳证明算法能够正确地将数组排序的基础：如果它能将两个子数组排序，它就能够通过归并两个子数组来将整个数组排序。

>**算法 2.4　自顶向下的归并排序**

>```
>public class Merge
>{
>    private static Comparable[] aux;      // 归并所需的辅助数组
>
>    public static void sort(Comparable[] a)
>
>    {
>       aux = new Comparable[a.length];    // 一次性分配空间
>       sort(a, 0, a.length - 1);
>    }
>
>    private static void sort(Comparable[] a, int lo, int hi)
>    {  // 将数组a[lo..hi]排序
>       if (hi <= lo) return;
>       int mid = lo + (hi - lo)/2;
>       sort(a, lo, mid);       // 将左半边排序
>       sort(a, mid+1, hi);     // 将右半边排序
>       merge(a, lo, mid, hi);  // 归并结果（代码见“原地归并的抽象方法”）
>    }
>}
>```

>要对子数组 `a[1o..hi]` 进行排序，先将它分为 `a[1o..mid]` 和 `a[mid+1..hi]` 两部分，分别通过递归调用将它们单独排序，最后将有序的子数组归并为最终的排序结果。

>![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.011.png)

>{-:-}自顶向下的归并排序中归并结果的轨迹

要理解归并排序就要仔细研究该方法调用的动态情况，如图 2.2.2 中的轨迹所示。要将 `a[0..15]` 排序，`sort()` 方法会调用自己将 `a[0..7]` 排序，再在其中调用自己将 `a[0..3]` 和 `a[0..1]` 排序。在将 `a[0]` 和 `a[1]` 分别排序之后，终于才会开始将 `a[0]` 和 `a[1]` 归并（简单起见，我们在轨迹中把对单个元素的数组进行排序的调用省略了）。第二次归并是 `a[2]` 和 `a[3]`，然后是 `a[0..1]` 和 `a[2..3]`，以此类推。从这段轨迹可以看到，`sort()` 方法的作用其实在于安排多次 `merge()` 方法调用的正确顺序。后面几节还会用到这个发现。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.012.png)

**图 2.2.2　自顶向下的归并排序的调用轨迹**

这段代码也是我们分析归并排序的运行时间的基础。因为归并排序是算法设计中分治思想的典型应用，我们会详细对它进行分析。

我们也可以通过图 2.2.3 所示的树状图来理解命题 F。每个结点都表示一个 `sort()` 方法通过 `merge()` 方法归并而成的子数组。这棵树正好有 ![n](https://private.codecogs.com/gif.latex?n) 层。对于 0 到 ![n-1](https://private.codecogs.com/gif.latex?n-1) 之间的任意 ![k](https://private.codecogs.com/gif.latex?k)，自顶向下的第 ![k](https://private.codecogs.com/gif.latex?k) 层有 ![2^k](https://private.codecogs.com/gif.latex?2^k) 个子数组，每个数组的长度为 ![2^{n-k}](https://private.codecogs.com/gif.latex?2^{n-k})，归并最多需要 ![2^{n-k}](https://private.codecogs.com/gif.latex?2^{n-k}) 次比较。因此每层的比较次数为 ![2^k\times2^{n-k}=2^n](https://private.codecogs.com/gif.latex?2^k\times2^{n-k}=2^n)，![n](https://private.codecogs.com/gif.latex?n) 层总共为 ![n2^n=N\lg N](https://private.codecogs.com/gif.latex?n2^n=N\lg%20N)。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.013.png)

**图 2.2.3　![N=16](https://private.codecogs.com/gif.latex?N=16) 时归并排序中子数组的依赖树**

>**命题 F**。对于长度为 ![N](https://private.codecogs.com/gif.latex?N) 的任意数组，自顶向下的归并排序需要 ½![N\lg N](https://private.codecogs.com/gif.latex?N\lg%20N) 至 ![N\lg N](https://private.codecogs.com/gif.latex?N\lg%20N) 次比较。

>**证明**。令 ![C(N)](https://private.codecogs.com/gif.latex?C(N%29) 表示将一个长度为 ![N](https://private.codecogs.com/gif.latex?N) 的数组排序时所需要的比较次数。我们有 ![C(0)=C(1)=0](https://private.codecogs.com/gif.latex?C(0%29=C(1%29=0)，对于 ![N>0](https://private.codecogs.com/gif.latex?N%3E0)，通过递归的 `sort()` 方法我们可以由相应的归纳关系得到比较次数的上限：

>![C(N)\leqslant C(\lceil N/2\rceil)+C(\lfloor N/2\rfloor)+N](https://private.codecogs.com/gif.latex?C(N%29\leqslant%20C(\lceil%20N/2\rceil%29+C(\lfloor%20N/2\rfloor%29+N)

>右边的第一项是将数组的左半部分排序所用的比较次数，第二项是将数组的右半部分排序所用的比较次数，第三项是归并所用的比较次数。因为归并所需的比较次数最少为 ![\lfloor N/2\rfloor](https://private.codecogs.com/gif.latex?\lfloor%20N/2\rfloor)，比较次数的下限是：

>![C(N)\geqslant C(\lceil N/2\rceil)+C(\lfloor N/2\rfloor)+\lfloor N/2\rfloor](https://private.codecogs.com/gif.latex?C(N%29\geqslant%20C(\lceil%20N/2\rceil%29+C(\lfloor%20N/2\rfloor%29+\lfloor%20N/2\rfloor)

>当 ![N](https://private.codecogs.com/gif.latex?N) 为 2 的幂（即 ![N=2^n](https://private.codecogs.com/gif.latex?N=2^n)）且等号成立时我们能够得到一个解。首先，因为 ![\lfloor N/2\rfloor=\lceil N/2\rceil=2^{n-1}](https://private.codecogs.com/gif.latex?\lfloor%20N/2\rfloor=\lceil%20N/2\rceil=2^{n-1})，可以得到：

>![C(2^n)=2C(2^{n-1})+2^n](https://private.codecogs.com/gif.latex?C(2^n%29=2C(2^{n-1}%29+2^n)

>将两边同时除以 ![2^n](https://private.codecogs.com/gif.latex?2^n) 可得：

>![C(2^n)/2^n=C(2^{n-1}))/2^{n-1}+1](https://private.codecogs.com/gif.latex?C(2^n%29/2^n=C(2^{n-1}%29%29/2^{n-1}+1)

>用这个公式替换右边的第一项，可得：

>![C(2^n)/2^n=C(2^{n-2}))/2^{n-2}+1+1](https://private.codecogs.com/gif.latex?C(2^n%29/2^n=C(2^{n-2}%29%29/2^{n-2}+1+1)

>将上一步重复 ![n-1](https://private.codecogs.com/gif.latex?n-1) 遍可得：

>![C(2^n)/2^n=C(2^0)/2^0+n](https://private.codecogs.com/gif.latex?C(2^n%29/2^n=C(2^0%29/2^0+n)

>将两边同时乘以 ![2^n](https://private.codecogs.com/gif.latex?2^n) 就可以解得：

>![C(N)=C(2^n)=n2^n=N\lg N](https://private.codecogs.com/gif.latex?C(N%29=C(2^n%29=n2^n=N\lg%20N)

>对于一般的 ![N](https://private.codecogs.com/gif.latex?N)，得到的准确值要更复杂一些。但对比较次数的上下界不等式使用相同的方法不难证明前面所述的对于任意 ![N](https://private.codecogs.com/gif.latex?N) 的结论。这个结论对于任意输入值和顺序都成立。

　

>**命题 G**。对于长度为 ![N](https://private.codecogs.com/gif.latex?N) 的任意数组，自顶向下的归并排序最多需要访问数组 ![6N\lg N](https://private.codecogs.com/gif.latex?6N\lg%20N) 次。

>**证明**。每次归并最多需要访问数组 ![6N](https://private.codecogs.com/gif.latex?6N) 次（![2N](https://private.codecogs.com/gif.latex?2N) 次用来复制，![2N](https://private.codecogs.com/gif.latex?2N) 次用来将排好序的元素移动回去，另外最多比较 ![2N](https://private.codecogs.com/gif.latex?2N) 次），根据命题 F 即可得到这个命题的结果。

命题 F 和命题 G 告诉我们归并排序所需的时间和 ![N\lg N](https://private.codecogs.com/gif.latex?N\lg%20N) 成正比。这和 2.1 节所述的初级排序方法不可同日而语，它表明我们只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序。可以用归并排序处理数百万甚至更大规模的数组，这是插入排序或者选择排序做不到的。归并排序的主要缺点是辅助数组所使用的额外空间和 ![N](https://private.codecogs.com/gif.latex?N) 的大小成正比。另一方面，通过一些细致的思考我们还能够大幅度缩短归并排序的运行时间。

####2.2.2.1　对小规模子数组使用插入排序

用不同的方法处理小规模问题能改进大多数递归算法的性能，因为递归会使小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法。对排序来说，我们已经知道插入排序（或者选择排序）非常简单，因此很可能在小数组上比归并排序更快。和之前一样，一幅可视轨迹图能够很好地说明归并排序的行为方式。图 2.2.4 中的可视轨迹图显示的是改良后的归并排序的所有操作。使用插入排序处理小规模的子数组（比如长度小于 15）一般可以将归并排序的运行时间缩短 10% ～ 15%（请见练习 2.2.23）。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.014.png)

**图 2.2.4　改进了小规模子数组排序方法后的自顶向下的归并排序的可视轨迹**

####2.2.2.2　测试数组是否已经有序

我们可以添加一个判断条件，如果 `a[mid]` 小于等于 `a[mid+1]`，我们就认为数组已经是有序的并跳过 `merge()` 方法。这个改动不影响排序的递归调用，但是任意有序的子数组算法的运行时间就变为线性的了（请见练习 2.2.8）。

####2.2.2.3　不将元素复制到辅助数组

我们可以节省将数组元素复制到用于归并的辅助数组所用的时间（但空间不行）。要做到这一点我们要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数据从辅助数组排序到输入数组。这种方法需要一些技巧，我们要在递归调用的每个层次交换输入数组和辅助数组的角色（请见练习 2.2.11）。

这里我们要重新强调第 1 章中提出的一个很容易遗忘的要点。在每一节中，我们会将书中的每个算法都看做某种应用的关键。但在整体上，我们希望学习的是为每种应用找到最合适的算法。我们并不是在推荐读者一定要实现所提到的这些改进方法，而是提醒大家不要对算法初始实现的性能盖棺定论。研究一个新问题时，最好的方法是先实现一个你能想到的最简单的程序，当它成为瓶颈的时候再继续改进它。实现那些只能把运行时间缩短某个常数因子的改进措施可能并不值得。你需要用实验来检验一项改进，正如本书中所有练习所演示的那样。

对于归并排序，刚才列出的三个建议都很容易实现且在应用归并排序时是十分有吸引力的——比如本章最后讨论的情况。

###2.2.3　自底向上的归并排序

递归实现的归并排序是算法设计中**分治思想**的典型应用。我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。尽管我们考虑的问题是归并两个大数组，实际上我们归并的数组大多数都非常小。实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。这种实现方法比标准递归方法所需要的代码量更少。首先我们进行的是两两归并（把每个元素想象成一个大小为 1 的数组），然后是四四归并（将两个大小为 2 的数组归并成一个有 4 个元素的数组），然后是八八的归并，一直下去。在每一轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小（但这对 `merge()` 方法不是问题），如果不是的话所有的归并中两个数组大小都应该一样，而在下一轮中子数组的大小会翻倍。此过程的可视轨迹如图 2.2.5 所示。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.015.png)

**图 2.2.5　自底向上的归并排序的可视轨迹**

自底向上的归并排序算法的实现如下。

>**自底向上的归并排序**

>```
>public class MergeBU
>{
>    private static Comparable[] aux;      // 归并所需的辅助数组
>    // merge()方法的代码请见“原地归并的抽象方法”
>    public static void sort(Comparable[] a)
>    {  //  进行lgN次两两归并
>       int N = a.length;
>       aux = new Comparable[N];
>       for (int sz = 1; sz < N; sz = sz+sz)        // sz子数组大小
>          for (int lo = 0; lo < N-sz; lo += sz+sz) // lo:子数组索引
>             merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));
>    }
>}
>```

>自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 `sz` 的初始值为 1，每次加倍。最后一个子数组的大小只有在数组大小是 `sz` 的偶数倍的时候才会等于 `sz`（否则它会比 `sz` 小）。

>![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.016.png)

>**自底向上的归并排序的归并结果**

　

>**命题 H**。对于长度为 ![N](https://private.codecogs.com/gif.latex?N) 的任意数组，自底向上的归并排序需要 ![1/2N\lg N](https://private.codecogs.com/gif.latex?1/2N\lg%20N) 至 ![N\lg N](https://private.codecogs.com/gif.latex?N\lg%20N) 次比较，最多访问数组 ![6N\lg N](https://private.codecogs.com/gif.latex?6N\lg%20N) 次。

>**证明**。处理一个数组的遍数正好是 ![\lceil\lg N\rceil](https://private.codecogs.com/gif.latex?\lceil\lg%20N\rceil) 。每一遍会访问数组 ![6N](https://private.codecogs.com/gif.latex?6N) 次，比较次数在 ![N/2](https://private.codecogs.com/gif.latex?N/2) 和 ![N](https://private.codecogs.com/gif.latex?N) 之间。

**当数组长度为 2 的幂时**，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同（请见练习 2.2.5）。

自底向上的归并排序比较适合**用链表**组织的数据。想象一下将链表先按大小为 1 的子链表进行排序，然后是大小为 2 的子链表，然后是大小为 4 的子链表等。这种方法只需要重新组织链表链接就能将链表**原地**排序（不需要创建任何新的链表结点）。

用自顶向下或是自底向上的方式实现任何分治类的算法都很自然。归并排序告诉我们，当能够用其中一种方法解决一个问题时，你都应该试试另一种。你是希望像 `Merge.sort()` 中那样化整为零（然后递归地解决它们）的方式解决问题，还是希望像 `MergeBU.sort()` 中那样循序渐进地解决问题呢？

###2.2.4　排序算法的复杂度

学习归并排序的一个重要原因是它是证明计算复杂性领域的一个重要结论的基础，而计算复杂性能够帮助我们理解排序自身固有的难易程度。计算复杂性在算法设计中扮演着非常重要的角色，而这个结论正是和排序算法的设计直接相关的，因此接下来我们就要详细地讨论它。

研究复杂度的第一步是建立一个计算模型。一般来说，研究者会尽量寻找一个和问题相关的最简单的模型。对排序来说，我们的研究对象是基于比较的算法，它们对数组元素的操作方式是由主键的比较决定的。一个基于比较的算法在两次比较之间可能会进行任意规模的计算，但它只能通过主键之间的比较得到关于某个主键的信息。因为我们局限于实现了 `Comparable` 接口的对象，本章中的所有算法都属于这一类（注意，我们忽略了访问数组的开销）。在第 5 章中，我们会讨论不局限于 `Comparable` 元素的算法。

>**命题 I**。没有任何基于比较的算法能够保证使用少于 ![\lg(N!)\sim N\lg N](https://private.codecogs.com/gif.latex?\lg(N!%29\sim%20N\lg%20N) 次比较将长度为 ![N](https://private.codecogs.com/gif.latex?N) 的数组排序。

>**证明**。首先，假设没有重复的主键，因为任何排序算法都必须能够处理这种情况。我们使用二叉树来表示所有的比较。树中的**结点**要么是一片**叶子**![{18%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.017.png)，表示排序完成且原输入的排列顺序是 <code>a[i<sub>0</sub>], a[i<sub>1</sub>], ..., a[i<sub>N-1</sub>]</code>，要么是一个**内部结点**![{4%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.018.png)，表示 `a[i]` 和 `a[j]` 之间的一次比较操作，它的左子树表示 `a[i]` 小于 `a[j]` 时进行的其他比较，右子树表示 `a[i]` 大于 `a[j]` 时进行的其他比较。从根结点到叶子结点每一条路径都对应着算法在建立叶子结点所示的顺序时进行的所有比较。例如，这是一棵 ![N=3](https://private.codecogs.com/gif.latex?N=3) 时的比较树：

>![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.019.png)

>我们从来没有明确地构造这棵树——它只是用来描述算法中的比较的一个数学工具。

>从比较树观察得到的第一个重要结论是这棵树应该至少有 ![N!](https://private.codecogs.com/gif.latex?N!) 个叶子结点，因为 ![N](https://private.codecogs.com/gif.latex?N) 个不同的主键会有 ![N!](https://private.codecogs.com/gif.latex?N!) 种不同的排列。如果叶子结点少于 ![N!](https://private.codecogs.com/gif.latex?N!)，那肯定有一些排列顺序被遗漏了。算法对于那些被遗漏的输入肯定会失败。

>从根结点到叶子结点的一条路径上的内部结点的数量即是某种输入下算法进行比较的次数。我们感兴趣的是这种路径能有多长（也就是树的**高度**），因为这也就是算法比较次数的最坏情况。二叉树的一个基本的组合学性质就是高度为 ![h](https://private.codecogs.com/gif.latex?h) 的树最多只可能有 ![2^h](https://private.codecogs.com/gif.latex?2^h) 个叶子结点，拥有 ![2^h](https://private.codecogs.com/gif.latex?2^h) 个结点的树是完美平衡的，或称为**完全树**。下图所示的就是一个 ![h=4](https://private.codecogs.com/gif.latex?h=4) 的例子。

>![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.020.png)

>结合前两段的分析可知，任意基于比较的排序算法都对应着一棵高 ![h](https://private.codecogs.com/gif.latex?h) 的比较树（如下图所示），其中：

>{-:-}![N!\leqslant](https://private.codecogs.com/gif.latex?N!\leqslant) 叶子结点的数量 ![\leqslant2^h](https://private.codecogs.com/gif.latex?\leqslant2^h)

>![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.021.png)

>![h](https://private.codecogs.com/gif.latex?h) 的值就是最坏情况下的比较次数，因此对不等式的两边取对数即可得到任意算法的比较次数至少是 ![\lg N!](https://private.codecogs.com/gif.latex?\lg%20N!)。根据斯特灵公式对阶乘函数的近似（见表 1.4.6）可得 ![\lg N!\sim N\lg N](https://private.codecogs.com/gif.latex?\lg%20N!\sim%20N\lg%20N)。

这个结论告诉了我们在设计排序算法的时候能够达到的最佳效果。例如，如果没有这个结论，我们可能会去尝试设计一个在最坏情况下比较次数只有归并排序的一半的基于比较的算法。命题 I 中的下限告诉我们这种努力是没有意义的——这样的算法不存在。这是一个重要结论，适用于任何我们能够想到的基于比较的算法。

命题 H 表明归并排序在最坏情况下的比较次数为 ![\sim N\lg N](https://private.codecogs.com/gif.latex?\sim%20N\lg%20N)。这是其他排序算法复杂度的**上限**，也就是说更好的算法需要保证使用的比较次数更少。命题 I 说明没有任何排序算法能够用少于 ![\sim N\lg N](https://private.codecogs.com/gif.latex?\sim%20N\lg%20N) 次比较将数组排序，这是其他排序算法复杂度的**下限**。也就是说，即使是最好的算法在最坏的情况下也至少需要这么多次比较。将两者结合起来也就意味着：

>**命题 J**。归并排序是一种渐进最优的基于比较排序的算法。

>**证明**。更准确地说，这句话的意思是，归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 ![\sim N\lg N](https://private.codecogs.com/gif.latex?\sim%20N\lg%20N)。命题 H 和命题 I 证明了这些结论。

需要强调的是，和计算模型一样，我们需要精确地定义最优算法。例如，我们可以**严格地**认为仅仅只需要 ![\lg N!](https://private.codecogs.com/gif.latex?\lg%20N!) 次比较的算法才是最优的排序算法。我们不这么做的原因是，即使对于很大的 ![N](https://private.codecogs.com/gif.latex?N)，这种算法和（比如说）归并排序之间的差异也并不明显。或者我们也可以放宽最优的定义，使之包含任意在最坏情况下的比较次数都在 ![N\lg N](https://private.codecogs.com/gif.latex?N\lg%20N) 的某个常数因子范围之内的排序算法。我们不这么做的原因是对于很大的 ![N](https://private.codecogs.com/gif.latex?N)，这种算法和归并排序之间的差距还是很明显的。

计算复杂度的概念可能会让人觉得很抽象，但解决可计算问题内在困难的基础性研究则不管怎么说都是非常必要的。而且，在适用的情况下，关键在于计算复杂度会影响优秀软件的开发。首先，准确的上界为软件工程师保证性能提供了空间。很多例子表明，平方级别排序的性能低于线性排序。其次，准确的下界可以为我们节省很多时间，避免因不可能的性能改进而投入资源。

但归并排序的最优性并不是结束，也不代表在实际应用中我们不会考虑其他的方法了，因为本节中的理论还是有许多局限性的，例如：

* 归并排序的空间复杂度不是最优的；
* 在实践中不一定会遇到最坏情况；
* 除了比较，算法的其他操作（例如访问数组）也可能很重要；
* **不进行**比较也能将某些数据排序。

因此在本书中我们还将继续学习其他一些排序算法。

###答疑

**问**　归并排序比希尔排序快吗？

**答**　在实际应用中，它们的运行时间之间的差距在常数级别之内（希尔排序使用的是像算法 2.3 中那样的经过验证的递增序列），因此相对性能取决于具体的实现。

```
% java SortCompare Merge Shell 100000
For 100000 random Double values
    Merge is 1.2 times faster than Shell
```

　　　理论上来说，还没有人能够证明希尔排序对于随机数据的运行时间是线性对数级别的，因此存在平均情况下希尔排序的性能的渐进增长率{1[即运行时间的近似函数。——译者注]}更高的可能性。在最坏情况下，这种差距的存在已经被证实了，但这对实际应用没有影响。

**问**　为什么不把数组 `aux[]` 声明为 `merge()` 方法的局部变量？

**答**　这是为了避免每次归并时，即使是归并很小的数组，都创建一个新的数组。如果这么做，那么创建新数组将成为归并排序运行时间的主要部分（请见练习 2.2.26）。更好的解决方案是将 `aux[]` 变为 `sort()` 方法的局部变量，并将它作为参数传递给 `merge()` 方法（为了简化代码我们没有在例子中这么做，请见练习 2.2.9）。

**问**　当数组中存在重复的元素时归并排序的表现如何？

**答**　如果所有的元素都相同，那么归并排序的运行时间将是线性的（需要一个额外的测试来避免归并已经有序的数组）。但如果有多个不同的重复值，这样做的性能收益就不是很明显了。例如，假设输入数组的 ![N](https://private.codecogs.com/gif.latex?N) 个奇数位上的元素都是同一个值，另外 ![N](https://private.codecogs.com/gif.latex?N) 个偶数位上的元素都是另一个值，此时算法的运行时间是线性对数的（这样的数组和所有元素都不重复的数组满足了相同的循环条件），而非线性的。

###练习

**2.2.1**　按照本节开头所示轨迹的格式给出原地归并的抽象 `merge()` 方法是如何将数组 `A E Q S U Y E I N O S T` 排序的。

**2.2.2**　按照算法 2.4 所示轨迹的格式给出自顶向下的归并排序是如何将数组 `E A S Y Q U E S T I O N` 排序的。

**2.2.3**　用自底向上的归并排序解答练习 2.2.2。

**2.2.4**　是否当且仅当两个输入的子数组都有序时原地归并的抽象方法才能得到正确的结果？证明你的结论，或者给出一个反例。

**2.2.5**　当输入数组的大小 ![N=39](https://private.codecogs.com/gif.latex?N=39) 时，给出自顶向下和自底向上的归并排序中各次归并子数组的大小及顺序。

**2.2.6**　编写一个程序来计算自顶向下和自底向上的归并排序访问数组的准确次数。使用这个程序将 ![N=1](https://private.codecogs.com/gif.latex?N=1) 至 512 的结果绘成曲线图，并将其和上限 ![6N\lg N](https://private.codecogs.com/gif.latex?6N\lg%20N) 比较。

**2.2.7**　证明归并排序的比较次数是单调递增的（即对于 ![N>0](https://private.codecogs.com/gif.latex?N%3E0)，![C(N+1)>C(N)](https://private.codecogs.com/gif.latex?C(N+1%29%3EC(N%29)）。

**2.2.8**　假设将算法 2.4 修改为：只要 `a[mid] <= a[mid+1]` 就不调用 `merge()` 方法，请证明用归并排序处理一个已经有序的数组所需的比较次数是线性级别的。

**2.2.9**　在库函数中使用 `aux[]` 这样的静态数组是不妥当的，因为可能会有多个程序同时使用这个类。实现一个不用静态数组的 `Merge` 类，但也**不要**将 `aux[]` 变为 `merge()` 的局部变量（请见本节的答疑部分）。**提示**：可以将辅助数组作为参数传递给递归的 `sort()` 方法。

###提高题

**2.2.10**　**快速归并**。实现一个 `merge()` 方法，按**降序**将 `a[]` 的后半部分复制到 `aux[]`，然后将其归并回 `a[]` 中。这样就可以去掉内循环中检测某半边是否用尽的代码。**注意**：这样的排序产生的结果是不稳定的（请见 2.5.1.8 节）。

**2.2.11**　**改进**。实现 2.2.2 节所述的对归并排序的三项改进：加快小数组的排序速度，检测数组是否已经有序以及通过在递归中交换参数来避免数组复制。

**2.2.12**　**次线性的额外空间**。用大小 M 将数组分为 N/M 块（简单起见，设 M 是 N 的约数）。实现一个归并方法，使之所需的额外空间减少到 ![\max(M,N/M)](https://private.codecogs.com/gif.latex?\max(M,N/M%29)：(i) 可以先将一个块看做一个元素，将块的第一个元素作为块的主键，用选择排序将块排序；(ii) 遍历数组，将第一块和第二块归并，完成后将第二块和第三块归并，等等。

**2.2.13**　**平均情况的下限**。请证明任意基于比较的排序算法的预期比较次数至少为 ![\sim N\lg N](https://private.codecogs.com/gif.latex?\sim%20N\lg%20N)（假设输入元素的所有排列的出现概率是均等的）。**提示**：比较次数至少是比较树的外部路径的长度（根结点到所有叶子结点的路径长度之和），当树平衡时该值最小。

**2.2.14**　**归并有序的队列**。编写一个静态方法，将两个有序的队列作为参数，返回一个归并后的有序队列。

**2.2.15**　**自底向上的有序队列归并排序**。用下面的方法编写一个自底向上的归并排序：给定 ![N](https://private.codecogs.com/gif.latex?N) 个元素，创建 ![N](https://private.codecogs.com/gif.latex?N) 个队列，每个队列包含其中一个元素。创建一个由这 ![N](https://private.codecogs.com/gif.latex?N) 个队列组成的队列，然后不断用练习 2.2.14 中的方法将队列的头两个元素归并，并将结果重新加入到队列结尾，直到队列的队列只剩下一个元素为止。

**2.2.16**　**自然的归并排序**。编写一个自底向上的归并排序，当需要将两个子数组排序时能够利用数组中已经有序的部分。首先找到一个有序的子数组（移动指针直到当前元素比上一个元素小为止），然后再找出另一个并将它们归并。根据数组大小和数组中递增子数组的最大长度分析算法的运行时间。

**2.2.17**　**链表排序**。实现对链表的自然排序（这是将链表排序的最佳方法，因为它不需要额外的空间，且运行时间是线性对数级别的）。

**2.2.18**　**打乱链表**。实现一个分治算法，使用线性对数级别的时间和对数级别的额外空间随机打乱一条链表。

**2.2.19**　**倒置**。编写一个线性对数级别的算法统计给定数组中的“倒置”数量（即插入排序所需的交换次数，请见 2.1 节）。这个数量和 _Kendal1 tau_ 距离有关，请见 2.5 节。

**2.2.20**　**间接排序**。编写一个不改变数组的归并排序，它返回一个 `int[]` 数组 `perm`，其中 `perm[i]` 的值是原数组中第 ![i](https://private.codecogs.com/gif.latex?i) 小的元素的位置。

**2.2.21**　**一式三份**。给定三个列表，每个列表中包含 ![N](https://private.codecogs.com/gif.latex?N) 个名字，编写一个线性对数级别的算法来判定三份列表中是否含有公共的名字，如果有，返回第一个被找到的这种名字。

**2.2.22**　**三向归并排序**。假设每次我们是把数组分成三个部分而不是两个部分并将它们分别排序，然后进行三向归并。这种算法的运行时间的增长数量级是多少？

###实验题

**2.2.23**　**改进**。用实验评估正文中所提到的归并排序的三项改进（请见练习 2.2.11）的效果，并比较正文中实现的归并和练习 2.2.10 所实现的归并之间的性能。根据经验给出应该在何时为子数组切换到插入排序。

**2.2.24**　**改进的有序测试**。在实验中用大型随机数组评估练习 2.2.8 所做的修改的效果。根据经验用 ![N](https://private.codecogs.com/gif.latex?N)（被排序的原始数组的大小）的函数描述条件语句（`a[mid] < =a[mid+1]`）成立（无论数组是否有序）的平均次数。

**2.2.25**　**多向归并排序**。实现一个 ![k](https://private.codecogs.com/gif.latex?k) 向（相对双向而言）归并排序程序。分析你的算法，估计最佳的 ![k](https://private.codecogs.com/gif.latex?k) 值并通过实验验证猜想。

**2.2.26**　**创建数组**。使用 `SortCompare` 粗略比较在你的计算机上在 `merge()` 中和在 `sort()` 中创建 `aux[]` 的性能差异。

**2.2.27**　**子数组长度**。用归并将大型随机数组排序，根据经验用 ![N](https://private.codecogs.com/gif.latex?N)（某次归并时两个子数组的长度之和）的函数估计当一个子数组用尽时另一个子数组的平均长度。

**2.2.28**　**自顶向下与自底向上**。对于 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)，使用 `SortCompare` 比较自顶向下和自底向上的归并排序的性能。

**2.2.29**　**自然的归并排序**。对于 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^6](https://private.codecogs.com/gif.latex?10^6) 和 ![10^9](https://private.codecogs.com/gif.latex?10^9)，类型为 `Long` 的随机主键数组，根据经验给出自然的归并排序（请见练习 2.2.16）所需要的遍数。**提示**：不需要实现这个排序（甚至不需要生成所有完整的 64 位主键）也能完成这道练习。

##2.3　快速排序

本节的主题是**快速排序**，它可能是应用最广泛的排序算法了。快速排序流行的原因是它实现简单、适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多。快速排序引人注目的特点包括它是原地排序（只需要一个很小的辅助栈），且将长度为 ![N](https://private.codecogs.com/gif.latex?N) 的数组排序所需的时间和 ![N\lg N](https://private.codecogs.com/gif.latex?N\lg%20N) 成正比。我们已经学习过的排序算法都无法将这两个优点结合起来。另外，快速排序的内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是在实际中都要更快。它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。已经有无数例子显示许多种错误都能致使它在实际中的性能只有平方级别。幸好我们将会看到，由这些错误中学到的教训也大大改进了快速排序算法，使它的应用更加广泛。

###2.3.1　基本算法

快速排序是一种分治的排序算法。它将一个数组**分成**两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组**之前**；在第二种情况中，递归调用发生在处理整个数组**之后**。在归并排序中，一个数组被等分为两半；在快速排序中，切分（partition）的位置取决于数组的内容。快速排序的大致过程如图 2.3.1 所示。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.022.png)

**图 2.3.1　快速排序示意图**

快速排序的实现过程如算法 2.5 所示。

>**算法 2.5　快速排序**

>```
>public class Quick
>{
>    public static void sort(Comparable[] a)
>    {
>       StdRandom.shuffle(a);          // 消除对输入的依赖
>       sort(a, 0, a.length - 1);
>    }
>
>    private static void sort(Comparable[] a, int lo, int hi)
>    {
>       if (hi <= lo) return;
>       int j = partition(a, lo, hi);  // 切分（请见“快速排序的切分”）
>       sort(a, lo, j-1);              // 将左半部分a[lo .. j-1]排序
>       sort(a, j+1, hi);              // 将右半部分a[j+1 .. hi]排序
>    }
>}
>```

>快速排序递归地将子数组 `a[lo..hi]` 排序，先用 `partition()` 方法将 `a[j]` 放到一个合适位置，然后再用递归调用将其他位置的元素排序。

>![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.023.png)

该方法的关键在于切分，这个过程使得数组满足下面三个条件：

* 对于某个 `j`，`a[j]` 已经排定；
* `a[lo]` 到 `a[j-1]` 中的所有元素都不大于 `a[j]`；
* `a[j+1]` 到 `a[hi]` 中的所有元素都不小于 `a[j]`。

我们就是通过递归地调用切分来排序的。

因为切分过程总是能排定一个元素，用归纳法不难证明递归能够正确地将数组排序：如果左子数组和右子数组都是有序的，那么由左子数组（有序且没有任何元素大于切分元素）、切分元素和右子数组（有序且没有任何元素小于切分元素）组成的结果数组也一定是有序的。算法 2.5 就是实现了这个思路的一个递归程序。它是一个**随机化**的算法，因为它在将数组排序之前会将其随机打乱。我们这么做的原因是希望能够预测（并依赖）该算法的性能特性，之后我们会详细讨论。

要完成这个实现，需要实现切分方法。一般策略是先随意地取 `a[lo]` 作为**切分元素**，即那个将会被排定的元素，然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素显然是没有排定的，因此我们交换它们的位置。如此继续，我们就可以保证左指针 `i` 的左侧元素都不大于切分元素，右指针 `j` 的右侧元素都不小于切分元素。当两个指针相遇时，我们只需要将切分元素 `a[lo]` 和左子数组最右侧的元素（`a[j]`）交换然后返回 `j` 即可。切分方法的大致过程如图 2.3.2 所示。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.024.png)

**图 2.3.2　快速排序的切分示意图**

这段快速排序的实现代码中还有几个细节问题值得一提，因为它们都可能导致实现错误或是影响性能，我们会在下面讨论。本节稍后我们会研究算法的三个高层次的改进。

快速排序的切分的实现如下所示。

>**快速排序的切分**

>```
>private static int partition(Comparable[] a, int lo, int hi)
>{  // 将数组切分为a[lo..i-1], a[i], a[i+1..hi]
>    int i = lo, j = hi+1;              // 左右扫描指针
>    Comparable v = a[lo];              // 切分元素
>    while (true)
>    {  // 扫描左右，检查扫描是否结束并交换元素
>       while (less(a[++i], v)) if (i == hi) break;
>       while (less(v, a[--j])) if (j == lo) break;
>       if (i >= j) break;
>       exch(a, i, j);
>    }
>    exch(a, lo, j);       // 将v = a[j]放入正确的位置
>    return j;             // a[lo..j-1] <= a[j] <= a[j+1..hi] 达成
>}
>```

>这段代码按照 `a[lo]` 的值 `v` 进行切分。当指针 `i` 和 `j` 相遇时主循环退出。在循环中，`a[i]` 小于 `v` 时我们增大 `i`，`a[j]` 大于 `v` 时我们减小 `j`，然后交换 `a[i]` 和 `a[j]` 来保证 `i` 左侧的元素都不大于 `v`，`j` 右侧的元素都不小于 `v`。当指针相遇时交换 `a[lo]` 和 `a[j]`，切分结束（这样切分值就留在 `a[j]` 中了）。

>![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.025.png)

>{-:-}**切分轨迹（每次交换前后的数组内容）**

####2.3.1.1　原地切分

如果使用一个辅助数组，我们可以很容易实现切分，但将切分后的数组复制回去的开销也许会使我们得不偿失。一个初级 Java 程序员甚至可能会将空数组创建在递归的切分方法中，这会大大降低排序的速度。

####2.3.1.2　别越界

如果切分元素是数组中最小或最大的那个元素，我们就要小心别让扫描指针跑出数组的边界。`partition()` 实现可进行明确的检测来预防这种情况。测试条件（`j == lo`）是冗余的，因为切分元素就是 `a[lo]`，它不可能比自己小。数组右端也有相同的情况，它们都是可以去掉的（请见练习 2.3.17）。

####2.3.1.3　保持随机性

数组元素的顺序是被打乱过的。因为算法 2.5 对所有的子数组都一视同仁，它的所有子数组也都是随机排序的。这对于预测算法的运行时间很重要。保持随机性的另一种方法是在 `partition()` 中随机选择一个切分元素。

####2.3.1.4　终止循环

有经验的程序员都知道保证循环结束需要格外小心，快速排序的切分循环也不例外。正确地检测指针是否越界需要一点技巧，并不像看上去那么容易。一个最常见的错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素。

####2.3.1.5　处理切分元素值有重复的情况

如算法 2.5 所示，左侧扫描最好是在遇到大于**等于**切分元素值的元素时停下，右侧扫描则是遇到小于等于切分元素值的元素时停下。尽管这样可能会不必要地将一些等值的元素交换，但在某些典型应用中，它能够避免算法的运行时间变为平方级别（请见练习 2.3.11）。稍后我们会讨论另一种可以更好地处理含有大量重复值的数组的方法。

####2.3.1.6　终止递归

有经验的程序员还知道保证递归总是能够结束也是需要小心的，快速排序也不例外。例如，实现快速排序时一个常见的错误就是不能保证将切分元素放入正确的位置，从而导致程序在切分元素正好是子数组的最大或是最小元素时陷入了无限的递归循环之中。

###2.3.2　性能特点

数学上已经对快速排序进行了详尽的分析，因此我们能够精确地说明它的性能。大量经验也证明了这些分析，它们是算法调优时的重要工具。

快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较。这种简洁性也是快速排序的一个优点，很难想象排序算法中还能有比这更短小的内循环了。例如，归并排序和希尔排序一般都比快速排序慢，其原因就是它们还在内循环中移动数据。

快速排序另一个速度优势在于它的比较次数很少。排序效率最终还是依赖切分数组的效果，而这依赖于切分元素的值。切分将一个较大的随机数组分成两个随机子数组，而实际上这种分割可能发生在数组的任意位置（对于元素不重复的数组而言）。下面我们来分析这个算法，看看这种方法和理想方法之间的差距。

快速排序的最好情况是每次都正好能将数组对半分。在这种情况下快速排序所用的比较次数正好满足分治递归的 ![C_N=2C_{N/2}+N](https://private.codecogs.com/gif.latex?C_N=2C_{N/2}+N) 公式。![2C_{N/2}](https://private.codecogs.com/gif.latex?2C_{N/2}) 表示将两个子数组排序的成本，![N](https://private.codecogs.com/gif.latex?N) 表示用切分元素和所有数组元素进行比较的成本。由归并排序的命题 F 的证明可知，这个递归公式的解 ![C_N\sim N\lg_N](https://private.codecogs.com/gif.latex?C_N\sim%20N\lg_N)。尽管事情并不总会这么顺利，但**平均而言**切分元素都能落在数组的中间。将每个切分位置的概率都考虑进去只会使递归更加复杂、更难解决，但最终结果还是类似的。我们对快速排序的信心来自于这个结论的证明。如果你不喜欢数学公式，可以跳过这个证明，相信它即可；如果你喜欢，你会发现它很有趣。

>**命题 K**。将长度为 ![N](https://private.codecogs.com/gif.latex?N) 的无重复数组排序，快速排序平均需要 ![\sim2N\ln N](https://private.codecogs.com/gif.latex?\sim2N\ln%20N) 次比较（以及 1/6 的交换）。

>**证明**。令 ![C_N](https://private.codecogs.com/gif.latex?C_N) 为将 ![N](https://private.codecogs.com/gif.latex?N) 个不同元素排序平均所需的比较次数。显然 ![C_0=C_1=0](https://private.codecogs.com/gif.latex?C_0=C_1=0)，对于 ![N>1](https://private.codecogs.com/gif.latex?N%3E1)，由递归程序可以得到以下归纳关系：

>![C_N=N+1(C_0+C_1+\cdots+C_{N-2}+C_{N-1})/N+(C_{N-1}+C_{N-2}+\cdots+C_0)/N](https://private.codecogs.com/gif.latex?C_N=N+1(C_0+C_1+\cdots+C_{N-2}+C_{N-1}%29/N+(C_{N-1}+C_{N-2}+\cdots+C_0%29/N)

>第一项是切分的成本（总是 ![N+1](https://private.codecogs.com/gif.latex?N+1)），第二项是将左子数组（长度可能是 0 到 ![N-1](https://private.codecogs.com/gif.latex?N-1)）排序的平均成本，第三项是将右子数组（长度和左子数组相同）排序的平均成本。将等式左右两边乘以 ![N](https://private.codecogs.com/gif.latex?N) 并整理各项得到：

>![NC_N=N(N+1)+2(C_0+C_1+\cdots+C_{N-2}+C_{N-1})](https://private.codecogs.com/gif.latex?NC_N=N(N+1%29+2(C_0+C_1+\cdots+C_{N-2}+C_{N-1}%29)

>将该等式减去 ![N-1](https://private.codecogs.com/gif.latex?N-1) 时的相同等式可得：

>![NC_N-(N-1)C_{N-1}=2N+2C_{N-1}](https://private.codecogs.com/gif.latex?NC_N-(N-1%29C_{N-1}=2N+2C_{N-1})

>整理等式并将两边除以 ![N(N+1)](https://private.codecogs.com/gif.latex?N(N+1%29) 可得：

>![C_N/(N+1)=C_{N-1}/N+2/(N+1)](https://private.codecogs.com/gif.latex?C_N/(N+1%29=C_{N-1}/N+2/(N+1%29)

>归纳法推导可得：

>![C_N\sim2(N+1)(1/3+1/4+\cdots+1/(N+1))](https://private.codecogs.com/gif.latex?C_N\sim2(N+1%29(1/3+1/4+\cdots+1/(N+1%29%29)

>括号内的量是曲线 2/_x_ 下从 3 到 ![N](https://private.codecogs.com/gif.latex?N) 的离散近似面积加一，积分得到 ![C_N\sim2N\ln N](https://private.codecogs.com/gif.latex?C_N\sim2N\ln%20N)。注意到 ![2N\ln N\approx1.39N\lg N](https://private.codecogs.com/gif.latex?2N\ln%20N\approx1.39N\lg%20N)，也就是说平均比较次数只比最好情况多39%。

>要得到命题中的交换次数需要一个类似（但更加复杂的）分析。

在实际应用中，当数组元素可能重复时，精确的分析会相当复杂，但不难证明即使存在重复的元素，平均比较次数也不会大于 ![C_N](https://private.codecogs.com/gif.latex?C_N)（在 2.3.3.3 节中我们会**改进**快速排序在这种情况下的性能）。

尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：在切分不平衡时这个程序可能会极为低效。例如，如果第一次从最小的元素切分，第二次从第二小的元素切分，如此这般，每次调用只会移除一个元素。这会导致一个大子数组需要切分很多次。我们要在快速排序前将数组随机排序的主要原因就是要避免这种情况。它能够使产生糟糕的切分的可能性降到极低，我们就无需为此担心了。

>**命题 L**。快速排序最多需要约 ![N^2/2](https://private.codecogs.com/gif.latex?N^2/2) 次比较，但随机打乱数组能够预防这种情况。

>**证明**。根据刚才的证明，在每次切分后两个子数组之一总是空的情况下，比较次数为：

>![N+(N-1)+(N-2)+\cdots+2+1=(N+1)N/2](https://private.codecogs.com/gif.latex?N+(N-1%29+(N-2%29+\cdots+2+1=(N+1%29N/2)

>这不仅说明算法所需的时间是平方级别的，也显示了算法所需的空间是线性的，而这对于大数组来说是不可接受的。但是（经过一些复杂的工作）通过扩展对一般情况的分析我们可以得到比较次数的标准差约为 ![0.65N](https://private.codecogs.com/gif.latex?0.65N)。因此，随着 ![N](https://private.codecogs.com/gif.latex?N) 的增大，运行时间会趋近于平均数，且不可能与平均数偏差太大。例如，对于一个有 100 万个元素的数组，由 Chebyshev 不等式可以粗略地估计出运行时间是平均所需时间的 10 倍的概率小于 0.000 01（且真实的概率还要小得多）。对于大数组，运行时间是平方级别的概率小到可以忽略不计（请见练习 2.3.10）。例如，快速排序所用的比较次数和插入排序或者选择排序一样多的概率比你的电脑在排序时被闪电击中的概率都要小得多！

总的来说，可以肯定的是对于大小为 ![N](https://private.codecogs.com/gif.latex?N) 的数组，算法 2.5 的运行时间在 ![1.39N\lg N](https://private.codecogs.com/gif.latex?1.39N\lg%20N) 的某个常数因子的范围之内。归并排序也能做到这一点，但是快速排序一般会更快（尽管它的比较次数多 39%），因为它移动数据的次数更少。这些保证都来自于数学概率，你完全可以相信它。

###2.3.3　算法改进

快速排序是由 C.A.R Hoare 在 1960 年发明的，从那时起就有很多人在研究并改进它。改进快速排序总是那么吸引人，发明更快的排序算法就好像是计算机科学界的“老鼠夹子”，而快速排序就是夹子里的那块奶酪。几乎从 Hoare 第一次发表这个算法开始，人们就不断地提出各种改进方法。并不是所有的想法都可行，因为快速排序的平衡性已经非常好，改进所带来的提高可能会被意外的副作用所抵消。但其中一些，也是我们现在要介绍的，非常有效。

如果你的排序代码会被执行很多次或者会被用在大型数组上（特别是如果它会被发布成一个库函数，排序的对象数组的特性是未知的），那么下面所讨论的这些改进意见值得你参考。需要注意的是，你需要通过实验来确定改进的效果并为实现选择最佳的参数。一般来说它们能将性能提升 20% ～ 30%。

####2.3.3.1　切换到插入排序

和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点：

* 对于小数组，快速排序比插入排序慢；
* 因为递归，快速排序的 `sort()` 方法在小数组中也会调用自己。

因此，在排序小数组时应该切换到插入排序。简单地改动算法 2.5 就可以做到这一点：将 `sort()` 中的语句

```
if (hi <= lo) return;
```

替换成下面这条语句来对小数组使用插入排序：

```
if (hi <= lo + M) { Insertion.sort(a, lo, hi); return; }
```

转换参数 `M` 的最佳值是和系统相关的，但是 5 ～ 15 之间的任意值在大多数情况下都能令人满意（请见练习 2.3.25）。

####2.3.3.2　三取样切分

改进快速排序性能的第二个办法是使用子数组的一小部分元素的中位数来切分数组。这样做得到的切分更好，但代价是需要计算中位数。人们发现将取样大小设为 3 并用大小居中的元素切分的效果最好（请见练习 2.3.18 和练习 2.3.19）。我们还可以将取样元素放在数组末尾作为“哨兵”来去掉 `partition()` 中的数组边界测试。使用三取样切分的快速排序轨迹如图 2.3.3 所示。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.026.png)

**图 2.3.3　使用了三取样切分和插入排序转换的快速排序**

####2.3.3.3　熵最优的排序

实际应用中经常会出现含有大量重复元素的数组，例如我们可能需要将大量人员资料按照生日排序，或是按照性别区分开来。在这些情况下，我们实现的快速排序的性能尚可，但还有巨大的改进空间。例如，一个元素全部重复的子数组就不需要继续排序了，但我们的算法还会继续将它切分为更小的数组。在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，将当前实现的线性对数级的性能提高到线性级别。

一个简单的想法是将数组切分为**三部分**，分别对应小于、等于和大于切分元素的数组元素。这种切分实现起来比我们目前使用的二分法更复杂，人们为解决它想出了许多不同的办法。这也是 E. W. Dijkstra 的**荷兰国旗问题**引发的一道经典的编程练习，因为这就好像用三种可能的主键值将数组排序一样，这三种主键值对应着荷兰国旗上的三种颜色。

Dijkstra 的解法如“三向切分的快速排序”中极为简洁的切分代码所示。它从左到右遍历数组一次，维护一个指针 `lt` 使得 `a[lo..lt-1]` 中的元素都**小于** `v`，一个指针 `gt` 使得 `a[gt+1..hi]` 中的元素都**大于** `v`，一个指针 `i` 使得 `a[lt..i-1]` 中的元素都**等于** `v`，`a[i..gt]` 中的元素都还未确定，如图 2.3.4 所示。一开始 `i` 和 `lo` 相等，我们使用 `Comparable` 接口（而非 `less()`）对 `a[i]` 进行三向比较来直接处理以下情况：

* `a[i]` 小于 `v`，将 `a[lt]` 和 `a[i]` 交换，将 `lt` 和 `i` 加一；
* `a[i]` 大于 `v`，将 `a[gt]` 和 `a[i]` 交换，将 `gt` 减一；
* `a[i]` 等于 `v`，将 `i` 加一。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.027.png)

**图 2.3.4　三向切分的示意图**

这些操作都会保证数组元素不变且缩小 `gt`-`i` 的值（这样循环才会结束）。另外，除非和切分元素相等，其他元素都会被**交换**。

20 世纪 70 年代，快速排序发布不久后这段代码就出现了，但它并没有流行开来，因为在数组中重复元素不多的普通情况下它比标准的二分法多使用了很多次交换。90 年代，J. Bently 和 D. McIlroy 找到一个聪明的方法解决了这个问题（请见练习 2.3.22），使得三向切分的快速排序比归并排序和其他排序方法在
包括重复元素很多的实际应用中更快。之后，J. Bently 和 R. Sedgewick 证明了这一点，我们会在下面讨论。

但我们已经证明过归并排序是最优的。如何才能突破它的下界？这个问题的答案在于 2.2 节的命题 I 讨论的是对任意输入的最差性能，而我们目前在讨论时已经知道输入数组的一些信息了。对于含有以任意概率分布的重复元素的输入，归并排序无法保证最佳性能。

三向切分的快速排序的实现如下所示。

>**三向切分的快速排序**

>```
>public class Quick3way
>{
>
>    private static void sort(Comparable[] a, int lo, int hi)
>    {  // 调用此方法的公有方法sort()请见算法2.5
>       if (hi <= lo) return;
>       int lt = lo, i = lo+1, gt = hi;
>       Comparable v = a[lo];
>       while (i <= gt)
>       {
>          int cmp = a[i].compareTo(v);
>          if      (cmp < 0) exch(a, lt++, i++);
>          else if (cmp > 0) exch(a, i, gt--);
>          else              i++;
>       }  // 现在 a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]成立
>       sort(a, lo, lt - 1);
>       sort(a, gt + 1, hi);
>    }
>}
>```

>这段排序代码的切分能够将和切分元素相等的元素归位，这样它们就不会被包含在递归调用处理的子数组之中了。对于存在大量重复元素的数组，这种方法比标准的快速排序的效率高得多（请见正文）。

>![{75%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.028.png)

>{-:-}**三向切分的轨迹（每次迭代循环之后的数组内容）**

>三向分切的快速排序的可视轨迹如图 2.3.5 所示。

>![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.029.png)

>**图 2.3.5　三向切分的快速排序的可视轨迹**

例如，对于只有若干不同主键的随机数组，归并排序的时间复杂度是线性对数的，而三向切分快速排序则是线性的。从上面的可视轨迹就可以看出，主键值数量的 ![N](https://private.codecogs.com/gif.latex?N) 倍是运行时间的一个保守的上界。

这些准确的结论来自于对主键概率分布的分析。给定包含 ![k](https://private.codecogs.com/gif.latex?k) 个不同值的 ![N](https://private.codecogs.com/gif.latex?N) 个主键，对于从 1 到 ![k](https://private.codecogs.com/gif.latex?k) 的每个 ![i](https://private.codecogs.com/gif.latex?i)，定义 ![f_i](https://private.codecogs.com/gif.latex?f_i) 为第 ![i](https://private.codecogs.com/gif.latex?i) 个主键值出现的次数，![p_i](https://private.codecogs.com/gif.latex?p_i) 为 ![f_i/N](https://private.codecogs.com/gif.latex?f_i/N)，即为随机抽取一个数组元素时第 ![i](https://private.codecogs.com/gif.latex?i) 个主键值出现的概率。那么所有主键的**香农信息量**（对信息含量的一种标准的度量方法）可以定义为：

![H=-(p_1\lg p_1+p_2\lg p_2+\cdots+p_k\lg p_k)](https://private.codecogs.com/gif.latex?H=-(p_1\lg%20p_1+p_2\lg%20p_2+\cdots+p_k\lg%20p_k%29)

给定任意一个待排序的数组，通过统计每个主键值出现的频率就可以计算出它包含的信息量。值得一提的是，可以通过这个信息量得出三向切分的快速排序所需要的比较次数的上下界。

>**命题 M**。不存在任何基于比较的排序算法能够保证在 ![NH-N](https://private.codecogs.com/gif.latex?NH-N) 次比较之内将 ![N](https://private.codecogs.com/gif.latex?N) 个元素排序，其中 ![H](https://private.codecogs.com/gif.latex?H) 为由主键值出现频率定义的香农信息量。

>**略证**。将 2.2 节的命题 I 中下界的证明（相对简单地）一般化即可证明该结论。

>**命题 N**。对于大小为 ![N](https://private.codecogs.com/gif.latex?N) 的数组，三向切分的快速排序需要 ![\sim(2\ln2)NH](https://private.codecogs.com/gif.latex?\sim(2\ln2%29NH) 次比较。其中 ![H](https://private.codecogs.com/gif.latex?H) 为由主键值出现频率定义的香农信息量。

>**略证**。将命题 K 中快速排序的普通情况的分析（相对困难地）通用化即可证明该结论。在所有主键都不重复的情况下，它比最优解所需比较多 39%（但仍在常数因子的范围之内）。

请注意，当所有的主键值均不重复时有 ![H=\lg N](https://private.codecogs.com/gif.latex?H=\lg%20N)（所有主键的概率均为 ![1/N](https://private.codecogs.com/gif.latex?1/N)），这和 2.2 节的命题 I 以及命题 K 是一致的。三向切分的最坏情况正是所有主键均不相同。当存在重复主键时，它的性能就会比归并排序好得多。更重要的是，这两个性质一起说明了三向切分是**信息量最优的**，即对于任意分布的输入，最优的基于比较的算法平均所需的比较次数和三向切分的快速排序平均所需的比较次数相互处于常数因子范围之内。

对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均运行时间，大幅偏离的情况非常罕见，因此可以肯定三向切分的快速排序的运行时间和输入的信息量的 ![N](https://private.codecogs.com/gif.latex?N) 倍是成正比的。在实际应用中这个性质很重要，**因为对于包含大量重复元素的数组，它将排序时间从线性对数级降低到了线性级别**。这和元素的排列顺序没有关系，因为算法会在排序之前将其打乱以避免最坏情况。元素的概率分布决定了信息量的大小，没有基于比较的排序算法能够用少于信息量决定的比较次数完成排序。这种对重复元素的适应性使得三向切分的快速排序成为排序库函数的最佳算法选择——需要将包含大量重复元素的数组排序的用例很常见。

经过精心调优的快速排序在绝大多数计算机上的绝大多数应用中都会比其他基于比较的排序算法更快。快速排序在今天的计算机业界中的广泛应用正是因为我们讨论过的数学模型说明了它在实际应用中比其他方法的性能更好，而近几十年的大量实验和经验也证明了这个结论。

在第 5 章中我们会发现，这些并不是快速排序发展的终点，因为有人研究出了完全不需要比较的排序算法！但快速排序的另一个版本在那个环境下仍然是最棒的，和这里一样。

###答疑

**问**　有没有将数组平分的办法，而不是根据切分元素的最后位置来切分数组？

**答**　这个问题困扰了专家们十多年。这和用数组的**中位数**切分的想法类似。我们在 2.5.3.4 节中讨论了寻找中位数的问题。在线性时间内找到是可能的，但用现有的算法（基于快速排序的切分），这么做的代价远远超过将数组平分而节省的 39%。

**问**　随机地将数组打乱似乎占了排序用时的一大部分，这么做值得吗？

**答**　值得。这能够防止出现最坏情况并使运行时间可以预计。Hoare 在 1960 年提出这个算法的时候就推荐了这种方法——它是一种（也是第一批）偏爱随机性的算法。

**问**　为什么都将注意力放在重复元素上？

**答**　这个问题直接影响到实际应用中的性能。它曾被忽略了数十年，结果是一些老的实现对含有大量重复元素的数组排序时用时超过平方级别，这在实际应用中肯定出现过。像算法 2.5 等较好的实现对于这种数组的复杂度是线性对数级别的，但在很多情况下，如本节最后将其改进为信息量最佳的线性级别是很值得的。

###练习

**2.3.1**　按照`partition()` 方法的轨迹的格式给出该方法是如何切分数组 `E A S Y Q U E S T I O N` 的。

**2.3.2**　按照本节中快速排序所示轨迹的格式给出快速排序是如何将数组 `E A S Y Q U E S T I O N` 排序的（出于练习的目的，可以忽略开头打乱数组的部分）。

**2.3.3**　对于长度为 ![N](https://private.codecogs.com/gif.latex?N) 的数组，在 `Quick.sort()` 执行时，其最大的元素最多会被交换多少次？

**2.3.4**　假如跳过开头打乱数组的操作，给出六个含有 10 个元素的数组，使得 `Quick.sort()` 所需的比较次数达到最坏情况。

**2.3.5**　给出一段代码将已知只有两种主键值的数组排序。

**2.3.6**　编写一段代码来计算 ![C_N](https://private.codecogs.com/gif.latex?C_N) 的准确值，在 ![N=100](https://private.codecogs.com/gif.latex?N=100)、1000 和 10 000 的情况下比较准确值和估计值 ![2N\ln N](https://private.codecogs.com/gif.latex?2N\ln%20N) 的差距。

**2.3.7**　在使用快速排序将 ![N](https://private.codecogs.com/gif.latex?N) 个不重复的元素排序时，计算大小为 0、1 和 2 的子数组的数量。如果你喜欢数学，请推导；如果你不喜欢，请做一些实验并提出猜想。

**2.3.8**　`Quick.sort()` 在处理 ![N](https://private.codecogs.com/gif.latex?N) 个全部重复的元素时大约需要多少次比较？

**2.3.9**　请说明 `Quick.sort()` 在处理只有两种主键值的数组时的行为，以及在处理只有三种主键值的数组时的行为。

**2.3.10**　Chebyshev **不等式**表明，一个随机变量的标准差距离均值大于 ![k](https://private.codecogs.com/gif.latex?k) 的概率小于 ![1/k^2](https://private.codecogs.com/gif.latex?1/k^2)。对于 ![N=100](https://private.codecogs.com/gif.latex?N=100) 万，用 Chebyshev 不等式计算快速排序所使用的比较次数大于 1000 亿次的概率（![0.1N^2](https://private.codecogs.com/gif.latex?0.1N^2)）。

**2.3.11**　假如在遇到和切分元素重复的元素时我们继续扫描数组而不是停下来，证明使用这种方法的快速排序在处理只有若干种元素值的数组时的运行时间是平方级别的。

**2.3.12**　按照代码所示轨迹的格式给出信息量最佳的快速排序第一次是如何切分数组 `B A B A B A B A C A D A B R A` 的。

**2.3.13**　在最佳、平均和最坏情况下，快速排序的**递归深度**分别是多少？这决定了系统为了追踪递归调用所需的栈的大小。在最坏情况下保证递归深度为数组大小的对数级的方法请见练习 2.3.20。

**2.3.14**　证明在用快速排序处理大小为 ![N](https://private.codecogs.com/gif.latex?N) 的不重复数组时，比较第 ![i](https://private.codecogs.com/gif.latex?i) 大和第 ![j](https://private.codecogs.com/gif.latex?j) 大元素的概率为 ![2/(j-i+1)](https://private.codecogs.com/gif.latex?2/(j-i+1%29)，并用该结论证明命题 K。

###提高题

**2.3.15**　**螺丝和螺帽**。(G. J. E. Rawlins) 假设有 ![N](https://private.codecogs.com/gif.latex?N) 个螺丝和 ![N](https://private.codecogs.com/gif.latex?N) 个螺帽混在一堆，你需要快速将它们配对。一个螺丝只会匹配一个螺帽，一个螺帽也只会匹配一个螺丝。你可以试着把一个螺丝和一个螺帽拧在一起看看谁大了，但不能直接比较两个螺丝或者两个螺帽。给出一个解决这个问题的有效方法。

**2.3.16**　**最佳情况**　编写一段程序来生成使算法 2.5 中的 `sort()` 方法表现最佳的数组（无重复元素）：数组大小为 ![N](https://private.codecogs.com/gif.latex?N) 且不包含重复元素，每次切分后两个子数组的大小最多差 1（子数组的大小与含有 ![N](https://private.codecogs.com/gif.latex?N) 个相同元素的数组的切分情况相同）。（对于这道练习，我们不需要在排序开始时打乱数组。）**以下练习描述了快速排序的几个变体。它们每个都需要分别实现，但你也很自然地希望使用 `SortCompare` 进行实验来评估每种改动的效果**。

**2.3.17**　**哨兵**。修改算法 2.5，去掉内循环 `while` 中的边界检查。由于切分元素本身就是一个哨兵（`v` 不可能小于 `a[lo]`），左侧边界的检查是多余的。要去掉另一个检查，可以在打乱数组后将数组的最大元素放在 `a[length-1]` 中。该元素永远不会移动（除非和相等的元素交换），可以在所有包含它的子数组中成为哨兵。**注意**：在处理内部子数组时，右子数组中最左侧的元素可以作为左子数组右边界的哨兵。

**2.3.18**　**三取样切分**。为快速排序实现正文所述的三取样切分（参见 2.3.3.2 节）。运行双倍测试来确认这项改动的效果。

**2.3.19**　**五取样切分**。实现一种基于随机抽取子数组中 5 个元素并取中位数进行切分的快速排序。将取样元素放在数组的一侧以保证只有中位数元素参与了切分。运行双倍测试来确定这项改动的效果，并和标准的快速排序以及三取样切分的快速排序（请见上一道练习）进行比较。**附加题**：找到一种对于任意输入都只需要少于 7 次比较的五取样算法。

**2.3.20**　**非递归的快速排序**。实现一个非递归的快速排序，使用一个循环来将弹出栈的子数组切分并将结果子数组重新压入栈。**注意**：先将较大的子数组压入栈，这样就可以保证栈最多只会有 ![\lg N](https://private.codecogs.com/gif.latex?\lg%20N) 个元素。

**2.3.21**　**将重复元素排序的比较次数的下界**。完成命题 M 的证明的第一部分。参考命题 I 的证明并注意当有 ![k](https://private.codecogs.com/gif.latex?k) 个主键值时所有元素存在 ![N!/f_1!f_2!\cdots f_k!](https://private.codecogs.com/gif.latex?N!/f_1!f_2!\cdots%20f_k!) 种不同的排列，其中第 ![i](https://private.codecogs.com/gif.latex?i) 个主键值出现的频率为 ![f_i](https://private.codecogs.com/gif.latex?f_i)（即 ![Np_i](https://private.codecogs.com/gif.latex?Np_i)，按照命题 M 的记法），且 ![f_1+\cdots+f_k=N](https://private.codecogs.com/gif.latex?f_1+\cdots+f_k=N)。

**2.3.22**　**快速三向切分**。（J. Bently，D. McIlroy）用将重复元素放置于子数组两端的方式实现一个信息量最优的排序算法。使用两个索引 `p` 和 `q`，使得 `a[lo..p-1]` 和 `a[q+1..hi]` 的元素都和 `a[lo]` 相等。使用另外两个索引 `i` 和 `j`，使得 `a[p..i-1]` 小于 `a[lo]`，`a[j+i..q]` 大于 `a[lo]`。在内循环中加入代码，在 `a[i]` 和 `v` 相当时将其与 `a[p]` 交换（并将 p 加 1），在 `a[j]` 和 `v` 相等且 `a[i]` 和 `a[j]` 尚未和 `v` 进行比较之前将其与 `a[q]` 交换。添加在切分循环结束后将和 `v` 相等的元素交换到正确位置的代码，如图 2.3.6 所示。**请注意**：这里实现的代码和正文中给出的代码是等价的，因为这里额外的交换用于和切分元素相等的元素，而正文中的代码将额外的交换用于和切分元素**不等**的元素。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.030.png)

**图 2.3.6　Bently-McIlroy 三向切分**

**2.3.23**　**Java 的排序库函数**。在练习 2.3.22 的代码中使用 Tukey's ninther 方法来找出切分元素——选择三组，每组三个元素，分别取三组元素的中位数，然后取三个中位数的中位数作为切分元素，且在排序小数组时切换到插入排序。

**2.3.24**　**取样排序**。（W. Frazer，A. McKellar）实现一个快速排序，取样大小为 ![2^k-1](https://private.codecogs.com/gif.latex?2^k-1)。首先将取样得到的元素排序，然后在递归函数中使用样品的中位数切分。分为两部分的其余样品元素无需再次排序并可以分别应用于原数组的两个子数组。这种算法被称为**取样排序**。

###实验题

**2.3.25**　**切换到插入排序**。实现一个快速排序，在子数组元素少于 ![M](https://private.codecogs.com/gif.latex?M) 时切换到插入排序。用快速排序处理大小 ![N](https://private.codecogs.com/gif.latex?N) 分别为 ![10^3](https://private.codecogs.com/gif.latex?10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6) 的随机数组，根据经验给出使其在你的计算环境中运行速度最快的 ![M](https://private.codecogs.com/gif.latex?M) 值。将 ![M](https://private.codecogs.com/gif.latex?M) 从 0 变化到 30 的每个值所得到的平均运行时间绘成曲线。**注意**：你需要为算法 2.2 添加一个需要三个参数的 `sort()` 方法以使 `Insertion.sort(a, lo, hi)` 将子数组 `a[lo..hi]` 排序。

**2.3.26**　**子数组的大小**。编写一个程序，在快速排序处理大小为 ![N](https://private.codecogs.com/gif.latex?N) 的数组的过程中，当子数组的大小小于 ![M](https://private.codecogs.com/gif.latex?M) 时，排序方法需要切换为插入排序。将子数组的大小绘制成直方图。用 ![N=10^5](https://private.codecogs.com/gif.latex?N=10^5)，![M=10](https://private.codecogs.com/gif.latex?M=10)、20 和 50 测试你的程序。

**2.3.27**　**忽略小数组**。用实验对比以下处理小数组的方法和练习 2.3.25 的处理方法的效果：在快速排序中直接忽略小数组，仅在快速排序结束后运行一次插入排序。**注意**：可以通过这些实验估计出电脑的缓存大小，因为当数组大小超出缓存时这种方法的性能可能会下降。

**2.3.28**　**递归深度**。用经验性的研究估计切换阈值为 ![M](https://private.codecogs.com/gif.latex?M) 的快速排序在将大小为 ![N](https://private.codecogs.com/gif.latex?N) 的不重复数组排序时的平均递归深度，其中 ![M=10](https://private.codecogs.com/gif.latex?M=10)、20 和 50，![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)。

**2.3.29**　**随机化**。用经验性的研究对比随机选择切分元素和正文所述的一开始就将数组随机化这两种策略的效果。在子数组大小为 ![M](https://private.codecogs.com/gif.latex?M) 时进行切换，将大小为 ![N](https://private.codecogs.com/gif.latex?N) 的不重复数组排序，其中 ![M=10](https://private.codecogs.com/gif.latex?M=10)、20 和 50，![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)。

**2.3.30**　**极端情况**。用初始随机化和非初始随机化的快速排序测试练习 2.1.35 和练习 2.1.36 中描述的大型非随机数组。在将这些大数组排序时，乱序对快速排序的性能有何影响？

**2.3.31**　**运行时间直方图**。编写一个程序，接受命令行参数 ![N](https://private.codecogs.com/gif.latex?N) 和 ![T](https://private.codecogs.com/gif.latex?T)，用快速排序对大小为 ![N](https://private.codecogs.com/gif.latex?N) 的随机浮点数数组进行 ![T](https://private.codecogs.com/gif.latex?T) 次排序，并将所有运行时间绘制成直方图。令 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)，为了使曲线更平滑，![T](https://private.codecogs.com/gif.latex?T) 值越大越好。这个练习最关键的地方在于找到适当的比例绘制出实验结果。

##2.4　优先队列

许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。很多情况下我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素，如此这般。例如，你可能有一台能够同时运行多个应用程序的电脑（或者手机）。这是通过为每个应用程序的事件分配一个优先级，并总是处理下一个优先级最高的事件来实现的。例如，绝大多数手机分配给来电的优先级都会比游戏程序的高。

在这种情况下，一个合适的数据结构应该支持两种操作：**删除最大元素**和**插入元素**。这种数据类型叫做**优先队列**。优先队列的使用和队列（删除最老的元素）以及栈（删除最新的元素）类似，但高效地实现它则更有挑战性。

在本节中，简单地讨论优先队列的基本表现形式（其一或者两种操作都能在线性时间内完成）之后，我们会学习基于**二叉堆**数据结构的一种优先队列的经典实现方法，用数组保存元素并按照一定条件排序，以实现高效地（对数级别的）**删除最大元素**和**插入元素操作**。

优先队列的一些重要的应用场景包括模拟系统，其中事件的键即为发生的时间，而系统需要按照时间顺序处理所有事件；任务调度，其中键值对应的优先级决定了应该首先执行哪些任务；数值计算，键值代表计算错误，而我们需要按照键值指定的顺序来修正它们。在第 6 章中我们会学习一个具体的例子，展示优先队列在粒子碰撞模拟中的应用。

通过插入一列元素然后一个个地删掉其中最小的元素，我们可以用优先队列实现排序算法。一种名为**堆排序**的重要排序算法也来自于基于堆的优先队列的实现。稍后在本书中我们会学习如何用优先队列构造其他算法。在第 4 章中我们会看到优先队列如何恰到好处地抽象若干重要的图搜索算法；在第 5 章中，我们将使用本节所示的方法开发出一种数据压缩算法。这些只是优先队列作为算法设计工具所起到的举足轻重的作用的一部分例子。

###2.4.1　API

优先队列是一种**抽象数据类型**（请见 1.2 节），它表示了一组值和对这些值的操作，它的抽象层使我们能够方便地将应用程序（用例）和我们将在本节中学习的各种具体实现隔离开来。和 1.2 节一样，我们会详细定义一组应用程序编程接口（API）来为数据结构的用例提供足够的信息（参见表 2.4.1）。优先队列最重要的操作就是**删除最大元素**和**插入元素**，所以我们会把精力集中在它们身上。删除最大元素的方法名为 `delMax()`，插入元素的方法名为 `insert()`。按照惯例，我们只会通过辅助函数 `less()` 来比较两个元素，和排序算法一样。如果允许重复元素，**最大**表示的是所有最大元素之一。为了将 API 定义完整，我们还需要加入构造函数（和我们在栈以及队列中使用的类似）和一个**空队列测试方法**。为了保证灵活性，我们在实现中使用了泛型，将实现了 `Comparable` 接口的数据的类型作为参数 `Key`。这使得我们可以不必再区别元素和元素的键，对数据类型和算法的描述也将更加清晰和简洁。例如，我们将用“最大元素”代替“最大键值”或是“键值最大的元素”。

**表 2.4.1　泛型优先队列的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>MaxPQ</b>&lt;Key extends Comparable&lt;Key>></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxPQ()</code></td><td>创建一个优先队列</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxPQ(int max)</code></td><td>创建一个初始容量为 <code>max</code> 的优先队列</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxPQ(Key[] a)</code></td><td>用 <code>a[]</code> 中的元素创建一个优先队列</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Insert(Key v)</code></td><td>向优先队列中插入一个元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key max()</code></td><td>返回最大元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key delMax()</code></td><td>删除并返回最大元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean isEmpty()</code></td><td>返回队列是否为空</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size()</code></td><td>返回优先队列中的元素个数</td></tr>
</table>

为了用例代码的方便，API 包含的三个构造函数使得用例可以构造指定大小的优先队列（还可以用给定的一个数组将其初始化）。为了使用例代码更加清晰，我们会在适当的地方使用另一个类 `MinPQ`。它和 `MaxPQ` 类似，只是含有一个 `delMin()` 方法来删除并返回队列中键值最小的那个元素。`MaxPQ` 的任意实现都能很容易地转化为 `MinPQ` 的实现，反之亦然，只需要改变一下 `less()` 比较的方向即可。

**优先队列的调用示例**

为了展示优先队列的抽象模型的价值，考虑以下问题：输入 ![N](https://private.codecogs.com/gif.latex?N) 个字符串，每个字符串都对映着一个整数，你的任务就是从中找出最大的（或是最小的）![M](https://private.codecogs.com/gif.latex?M) 个整数（及其关联的字符串）。这些输入可能是金融事务，你需要从中找出最大的那些；或是农产品中的杀虫剂含量，这时你需要从中找出最小的那些；或是服务请求、科学实验的结果，或是其他应用。在某些应用场景中，输入量可能非常巨大，甚至可以认为输入是无限的。解决这个问题的一种方法是将输入排序然后从中找出 ![M](https://private.codecogs.com/gif.latex?M) 个最大的元素，但我们已经说明输入将会非常庞大。另一种方法是将每个新的输入和已知的 ![M](https://private.codecogs.com/gif.latex?M) 个最大元素比较，但除非 ![M](https://private.codecogs.com/gif.latex?M) 较小，否则这种比较的代价会非常高昂。只要我们能够高效地实现 `insert()` 和 `delMin()`，下面的**优先队列用例**中调用了 `MinPQ` 的 `TopM` 就能使用优先队列解决这个问题，这就是本节中我们的目标。在现代基础性计算环境中超大的输入 ![N](https://private.codecogs.com/gif.latex?N) 非常常见，这些实现使我们能够解决以前缺乏足够资源去解决的问题，如表 2.4.2 所示。

**表 2.4.2　从 ![N](https://private.codecogs.com/gif.latex?N) 个输入中找到最大的 ![M](https://private.codecogs.com/gif.latex?M) 个元素所需成本**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="2">示例</th><th colspan="2">增长的数量级</th></tr>
<tr><th>时间</th><th>空间</th></tr>
<tr><td>排序算法的用例</td><td><img src="https://private.codecogs.com/gif.latex?N\log%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td></tr>
<tr><td>调用初级实现的优先队列</td><td><img src="https://private.codecogs.com/gif.latex?NM" /></td><td><img src="https://private.codecogs.com/gif.latex?M" /></td></tr>
<tr><td>调用基于堆实现的优先队列</td><td><img src="https://private.codecogs.com/gif.latex?N\log%20M" /></td><td><img src="https://private.codecogs.com/gif.latex?M" /></td></tr>
</table>

>**一个优先队列的用例**

>```
>public class TopM
>{
>    public static void main(String[] args)
>    {  // 打印输入流中最大的M行
>       int M = Integer.parseInt(args[0]);
>       MinPQ<Transaction> pq = new MinPQ<Transaction>(M+1);
>       while (StdIn.hasNextLine())
>       {  // 为下一行输入创建一个元素并放入优先队列中
>          pq.insert(new Transaction(StdIn.readLine()));
>          if (pq.size() > M)
>          pq.delMin();        // 如果优先队列中存在M+1个元素则删除其中最小的元素
>       }  // 最大的M个元素都在优先队列中
>
>       Stack<Transaction> stack = new Stack<Transaction>();
>       while (!pq.isEmpty()) stack.push(pq.delMin());
>       for (Transaction t : stack) StdOut.println(t);
>    }
>}
>```

>从命令行输入一个整数 ![M](https://private.codecogs.com/gif.latex?M) 从输入流获得一系列字符串，输入流的每一行表示一个交易。这段代码调用了 MinPQ 并会打印数字最大的 ![M](https://private.codecogs.com/gif.latex?M) 行。它用到了 `Transaction` 类（请见表 1.2.6、练习 1.2.19 和练习 2.1.21），构造了一个用数字作为键的优先队列。当优先队列的大小超过 ![M](https://private.codecogs.com/gif.latex?M) 时就删掉其中最小的元素。处理完所有交易，优先队列中存放着以增序排列的最大的 M 个交易，然后这段代码将它们放入到一个栈中，遍历这个栈以颠倒它们的顺序，从而将它们按降序打印出来。

>```
>% more tinyBatch.txt
>Turing      6/17/1990   644.08
>vonNeumann  3/26/2002  4121.85
>Dijkstra    8/22/2007  2678.40
>vonNeumann  1/11/1999  4409.74
>Dijkstra   11/18/1995   837.42
>Hoare       5/10/1993  3229.27
>vonNeumann  2/12/1994  4732.35
>Hoare       8/18/1992  4381.21
>Turing      1/11/2002    66.10
>Thompson    2/27/2000  4747.08
>Turing      2/11/1991  2156.86
>Hoare       8/12/2003  1025.70
>vonNeumann 10/13/1993  2520.97
>Dijkstra    9/10/2000   708.95
>Turing     10/12/1993  3532.36
>Hoare       2/10/2005  4050.20
>```

>　

>```
>% java TopM 5 < tinyBatch.txt
>Thompson    2/27/2000  4747.08
>vonNeumann  2/12/1994  4732.35
>vonNeumann  1/11/1999  4409.74
>Hoare       8/18/1992  4381.21
>vonNeumann  3/26/2002  4121.85
>```

###2.4.2　初级实现

我们在第 1 章中讨论过的 4 种基础数据结构是实现优先队列的起点。我们可以使用有序或无序的数组或链表。在队列较小时，大量使用两种主要操作之一时，或是所操作元素的顺序已知时，它们十分有用。因为这些实现相对简单，我们在这里只给出文字描述并将实现代码作为练习（请见练习 2.4.3）。

####2.4.2.1　数组实现（无序）

或许实现优先队列的最简单方法就是基于 2.1 节中下压栈的代码。`insert()` 方法的代码和栈的 `push()` 方法完全一样。要实现删除最大元素，我们可以添加一段类似于选择排序的内循环的代码，将最大元素和边界元素交换然后删除它，和我们对栈的 `pop()` 方法的实现一样。和栈类似，我们也可以加入调整数组大小的代码来保证数据结构中至少含有四分之一的元素而又永远不会溢出。

####2.4.2.2　数组实现（有序）

另一种方法就是在 `insert()` 方法中添加代码，将所有较大的元素向右边移动一格以使数组保持有序（和插入排序一样）。这样，最大的元素总会在数组的一边，优先队列的**删除最大元素操作**就和栈的 `pop()` 操作一样了。

####2.4.2.3　链表表示法

和刚才类似，我们可以用基于链表的下压栈的代码作为基础，而后可以选择修改 `pop()` 来找到并返回最大元素，或是修改 `push()` 来保证所有元素为**逆序**并用 `pop()` 来删除并返回链表的首元素（也就是最大的元素）。

使用无序序列是解决这个问题的**惰性**方法，我们仅在必要的时候才会采取行动（找出最大元素）；使用有序序列则是解决问题的**积极**方法，因为我们会尽可能未雨绸缪（在插入元素时就保持列表有序），使后续操作更高效。

实现栈或是队列与实现优先队列的最大不同在于对性能的要求。对于栈和队列，我们的实现能够在**常数**时间内完成所有操作；而对于优先队列，我们刚刚讨论过的所有初级实现中，**插入元素**和**删除最大元素**这两个操作之一在最坏情况下需要**线性**时间来完成（如表 2.4.3 所示）。我们接下来要讨论的基于数据结构**堆**的实现能够保证这两种操作都能更快地执行。

**表 2.4.3　优先队列的各种实现在最坏情况下运行时间的增长数量级**

|数据结构|插入元素|删除最大元素|
|-|-|-|
|有序数组|![N](https://private.codecogs.com/gif.latex?N)|1|
|无序数组|1|![N](https://private.codecogs.com/gif.latex?N)|
|堆|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|
|理想情况|1|1|

在一个优先队列上执行的一系列操作如表 2.4.4 所示。

**表 2.4.4　在一个优先队列上执行的一系列操作**

|操作|参数|返回值|大小|内容（无序）|内容（有序）|
|-|-|-|-|-|-|
|插入元素|`P`||`1`|**`P`**|**`P`**|
|插入元素|`Q`||`2`|<code>P&nbsp;&nbsp;<b>Q</b></code>|<code>P&nbsp;&nbsp;<b>Q</b></code>|
|插入元素|`E`||`3`|<code>P&nbsp;&nbsp;Q&nbsp;&nbsp;<b>E</b></code>|<code><b>E</b>&nbsp;&nbsp;P&nbsp;&nbsp;Q</code>|
|删除最大元素||**`Q`**|`2`|<code>P&nbsp;&nbsp;E</code>|<code>E&nbsp;&nbsp;P</code>|
|插入元素|`X`||`3`|<code>P&nbsp;&nbsp;E&nbsp;&nbsp;<b>X</b></code>|<code>E&nbsp;&nbsp;P&nbsp;&nbsp;<b>X</b></code>|
|插入元素|`A`||`4`|<code>P&nbsp;&nbsp;E&nbsp;&nbsp;X&nbsp;&nbsp;<b>A</b></code>|<code><b>A</b>&nbsp;&nbsp;E&nbsp;&nbsp;P&nbsp;&nbsp;X</code>|
|插入元素|`M`||`5`|<code>P&nbsp;&nbsp;E&nbsp;&nbsp;X&nbsp;&nbsp;A&nbsp;&nbsp;<b>M</b></code>|<code>A&nbsp;&nbsp;E&nbsp;&nbsp;<b>M</b>&nbsp;&nbsp;P&nbsp;&nbsp;X</code>|
|删除最大元素||**`X`**|`4`|<code>P&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A</code>|<code>A&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;P</code>|
|插入元素|`P`||`5`|<code>P&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A&nbsp;&nbsp;<b>P</b></code>|<code>A&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;P&nbsp;&nbsp;<b>P</b></code>|
|插入元素|`L`||`6`|<code>P&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A&nbsp;&nbsp;P&nbsp;&nbsp;<b>L</b></code>|<code>A&nbsp;&nbsp;E&nbsp;&nbsp;<b>L</b>&nbsp;&nbsp;M&nbsp;&nbsp;P&nbsp;&nbsp;<b>P</b>|
|插入元素|`E`||`7`|<code>P&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A&nbsp;&nbsp;P&nbsp;&nbsp;L&nbsp;&nbsp;<b>E</b></code>|<code>A&nbsp;&nbsp;E&nbsp;&nbsp;<b>E</b>&nbsp;&nbsp;L&nbsp;&nbsp;M&nbsp;&nbsp;<b>P</b>&nbsp;&nbsp;<b>P</b></code>|
|删除最大元素||**`P`**|`6`|<code>E&nbsp;&nbsp;E&nbsp;&nbsp;M&nbsp;&nbsp;A&nbsp;&nbsp;P&nbsp;&nbsp;L</code>|<code>A&nbsp;&nbsp;E&nbsp;&nbsp;E&nbsp;&nbsp;L&nbsp;&nbsp;M&nbsp;&nbsp;<b>P</b></code>|

###2.4.3　堆的定义

数据结构**二叉堆**能够很好地实现优先队列的基本操作。在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。相应地，这些位置的元素又至少要大于等于数组中的另两个元素，以此类推。如果我们将所有元素画成一棵二叉树，将每个较大元素和两个较小的元素用边连接就可以很容易看出这种结构。

>**定义**。当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为**堆有序**。

相应地，在堆有序的二叉树中，每个结点都小于等于它的父结点（如果有的话）。从任意结点向上，我们都能得到一列非递减的元素；从任意结点向下，我们都能得到一列非递增的元素。特别地：

>**命题 O**。根结点是堆有序的二叉树中的最大结点。

>**证明**。根据树的性质归纳可得。

**二叉堆表示法**

如果我们用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到它的上下结点（父结点和两个子结点各需要一个）。但如图 2.4.1 所示，如果我们使用完全二叉树，表达就会变得特别方便。要画出这样一棵完全二叉树，可以先定下根结点，然后一层一层地由上向下、从左至右，在每个结点的下方连接两个更小的结点，直至将 ![N](https://private.codecogs.com/gif.latex?N) 个结点全部连接完毕。完全二叉树只用数组而不需要指针就可以表示。具体方法就是将二叉树的结点按照**层级顺序**放入数组中，根结点在位置 1，它的子结点在位置 2 和 3，而子结点的子结点则分别在位置 4、5、6 和 7，以此类推。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.031.png)

**图 2.4.1　一棵堆有序的完全二叉树**

>**定义**。**二叉堆**是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。

（简单起见，在下文中我们将**二叉堆**简称为**堆**）在一个堆中，位置 ![k](https://private.codecogs.com/gif.latex?k) 的结点的父结点的位置为 ![\lfloor k/2\rfloor](https://private.codecogs.com/gif.latex?\lfloor%20k/2\rfloor)，而它的两个子结点的位置则分别为 ![2k](https://private.codecogs.com/gif.latex?2k) 和 ![2k+1](https://private.codecogs.com/gif.latex?2k+1)。这样在不使用指针的情况下（我们在第 3 章中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从 `a[k]` 向上一层就令 `k` 等于 `k/2`，向下一层则令 `k` 等于 `2k` 或 `2k+1`。

用数组（堆）实现的完全二叉树的结构是很严格的，但它的灵活性已经足以让我们高效地实现优先队列。用它们我们将能实现对数级别的**插入元素**和**删除最大元素**的操作。利用在数组中无需指针即可沿树上下移动的便利和以下性质，算法保证了对数复杂度的性能。

>**命题 P**。一棵大小为 ![N](https://private.codecogs.com/gif.latex?N) 的完全二叉树的高度为 ![\left\lfloor\lg N\right\rfloor](https://private.codecogs.com/gif.latex?\left\lfloor\lg%20N\right\rfloor)。

>**证明**。通过归纳很容易可以证明这一点，且当 ![N](https://private.codecogs.com/gif.latex?N) 达到 2 的幂时树的高度会加 1。

堆的表示如图 2.4.2 所示。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.032.png)

**图 2.4.2　堆的表示**

###2.4.4　堆的算法

我们用长度为 ![N+1](https://private.codecogs.com/gif.latex?N+1) 的私有数组 `pq[]` 来表示一个大小为 ![N](https://private.codecogs.com/gif.latex?N) 的堆，我们不会使用 `pq[0]`，堆元素放在 `pq[1]` 至 `pq[N]` 中。在排序算法中，我们只通过私有辅助函数 `less()` 和 `exch()` 来访问元素，但因为所有的元素都在数组 `pq[]` 中，我们在 2.4.4.2 节中会使用更加紧凑的实现方式，不再将数组作为参数传递。堆的操作会首先进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。我们称这个过程叫做**堆的有序化**（reheapifying）。

```
private boolean less(int i, int j)
{  return pq[i].compareTo(pq[j]) < 0;  }

private void exch(int i, int j)
{  Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;  }
```

{-:-}堆实现的比较和交换方法

堆实现的比较和交换方法如右上方的代码框所示。

在有序化的过程中我们会遇到两种情况。当某个结点的优先级上升（或是在堆底加入一个新的元素）时，我们需要**由下至上**恢复堆的顺序。当某个结点的优先级下降（例如，将根结点替换为一个较小的元素）时，我们需要**由上至下**恢复堆的顺序。首先，我们会学习如何实现这两种辅助操作，然后再用它们实现**插入元素**和**删除最大元素**的操作。

####2.4.4.1　由下至上的堆有序化（上浮）

```
private void swim(int k)
{
   while (k > 1 && less(k/2, k))
   {
      exch(k/2, k);
      k = k/2;
   }
}
```

{-:-}由下至上的堆有序化（上浮）的实现

如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。交换后，这个结点比它的两个子结点都大（一个是曾经的父结点，另一个比它更小，因为它是曾经父结点的子结点），但这个结点仍然可能比它现在的父结点更大。我们可以一遍遍地用同样的办法恢复秩序，将这个结点不断向上移动直到我们遇到了一个更大的父结点。只要记住位置 ![k](https://private.codecogs.com/gif.latex?k) 的结点的父结点的位置是 ![\lfloor k/2\rfloor](https://private.codecogs.com/gif.latex?\lfloor%20k/2\rfloor)，这个过程实现起来很简单。`swim()` 方法中的循环可以保证只有位置 ![k](https://private.codecogs.com/gif.latex?k) 上的结点大于它的父结点时堆的有序状态才会被打破。因此只要该结点不再大于它的父结点，堆的有序状态就恢复了。至于方法名，当一个结点太大的时候它需要**浮**（swim）到堆的更高层。由下至上的堆有序化的实现代码如右上方所示。

图 2.4.3 展示的是由下至上的堆有序化示意图。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.033.png)

**图 2.4.3　由下至上的堆有序化（上浮）**

####2.4.4.2　由上至下的堆有序化（下沉）

如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么我们可以通过将它和它的两个子结点中的较大者交换来恢复堆。交换可能会在子结点处继续打破堆的有序状态，因此我们需要不断地用相同的方式将其修复，将结点向下移动直到它的子结点都比它更小或是到达了堆的底部。由位置为 ![k](https://private.codecogs.com/gif.latex?k) 的结点的子结点位于 ![2k](https://private.codecogs.com/gif.latex?2k) 和 ![2k+1](https://private.codecogs.com/gif.latex?2k+1) 可以直接得到对应的代码。至于方法名，由上至下的堆有序化的示意图及实现代码分别见图 2.4.4 和下页的代码框。当一个结点太小的时候它需要**沉**（sink）到堆的更低层。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.034.png)

**图 2.4.4　由上至下的堆有序化（下沉）**

如果我们把堆想象成一个严密的黑社会组织，每个子结点都表示一个下属（父结点则表示它的直接上级），那么这些操作就可以得到很有趣的解释。`swim()` 表示一个很有能力的新人加入组织并被逐级提升（将能力不够的上级踩在脚下），直到他遇到了一个更强的领导。`sink()` 则类似于整个社团的领导退休并被外来者取代之后，如果他的下属比他更厉害，他们的角色就会交换，这种交换会持续下去直到他的能力比其下属都强为止。这些理想化的情景在现实生活中可能很罕见，但它们能够帮助你理解堆的这些基本行为。

`sink()` 和 `swim()` 方法是高效实现优先队列 API 的基础，原因如下（具体的实现请见算法 2.6）。

	private void sink(int k)
	{
	   while (2*k <= N)
	   {
	      int j = 2*k;
	      if (j < N && less(j, j+1)) j++;
	      if (!less(k, j)) break;
	      exch(k, j);
	      k = j;
	   }
	}

{-:-}由上至下的堆有序化（下沉）的实现

**插入元素**。我们将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置（如图 2.4.5 左半部分所示）。

**删除最大元素**。我们从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置（如图 2.4.5 右半部分所示）。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.035.png)

**图 2.4.5　堆的操作**

算法 2.6 解决了我们在本节开始时提出的一个基本问题：它对优先队列 API 的实现能够保证**插入元素**和**删除最大元素**这两个操作的用时和队列的大小仅成对数关系。

>**算法 2.6　基于堆的优先队列**

>```
>public class MaxPQ<Key extends Comparable<Key>>
>{
>    private Key[] pq;             // 基于堆的完全按二叉树
>    private int N = 0;            // 存储于pq[1..N]中，pq[0]没有使用
>
>    public MaxPQ(int maxN)
>    {  pq = (Key[]) new Comparable[maxN+1];  }
>
>    public boolean isEmpty()
>    {  return N == 0;  }
>
>    public int size()
>    {  return N;  }
>
>    public void insert(Key v)
>    {
>       pq[++N] = v;
>       swim(N);
>    }
>
>    public Key delMax()
>    {
>       Key max = pq[1];           // 从根结点得到最大元素
>       exch(1, N--);              // 将其和最后一个结点交换
>       pq[N+1] = null;            // 防止对象游离
>       sink(1);                   // 恢复堆的有序性
>       return max;
>    }
>
>    // 辅助方法的实现请见本节前面的代码框
>    private boolean less(int i, int j)
>    private void exch(int i, int j)
>    private void swim(int k)
>    private void sink(int k)
>}
>```

>优先队列由一个基于堆的完全二叉树表示，存储于数组 `pq[1..N]` 中，`pq[0]` 没有使用。在 `insert()` 中，我们将 `N` 加一并把新元素添加在数组最后，然后用 `swim()` 恢复堆的秩序。在 `delMax()` 中，我们从 `pq[1]` 中得到需要返回的元素，然后将 `pq[N]` 移动到 `pq[1]`，将 `N` 减一并用 `sink()` 恢复堆的秩序。同时我们还将不再使用的 `pq[N+1]` 设为 `null`，以便系统回收它所占用的空间。和以前一样（请见 1.3 节），这里省略了动态调整数组大小的代码。其他的构造函数请见练习 2.4.19。

　

>**命题 Q**。对于一个含有 ![N](https://private.codecogs.com/gif.latex?N) 个元素的基于堆的优先队列，**插入元素**操作只需不超过（![\lg N+1](https://private.codecogs.com/gif.latex?\lg%20N+1)）次比较，**删除最大元素**的操作需要不超过 ![2\lg N](https://private.codecogs.com/gif.latex?2\lg%20N) 次比较。

>**证明**。由命题 P 可知，两种操作都需要在根结点和堆底之间移动元素，而路径的长度不超过 ![\lg N](https://private.codecogs.com/gif.latex?\lg%20N)。对于路径上的每个结点，**删除最大元素**需要两次比较（除了堆底元素），一次用来找出较大的子结点，一次用来确定该子结点是否需要上浮。

对于需要大量混杂的插入和删除最大元素操作的典型应用来说，命题 Q 意味着一个重要的性能突破，总结请见表 2.4.3。使用有序或是无序数组的优先队列的初级实现总是需要线性时间来完成其中一种操作，但基于堆的实现则能够保证在对数时间内完成它们。这种差别使得我们能够解决以前无法解决的问题。

####2.4.4.3　多叉堆

基于用数组表示的完全三叉树构造堆并修改相应的代码并不困难。对于数组中 1 至 ![N](https://private.codecogs.com/gif.latex?N) 的 ![N](https://private.codecogs.com/gif.latex?N) 个元素，位置 ![k](https://private.codecogs.com/gif.latex?k) 的结点大于等于位于 ![3k-1](https://private.codecogs.com/gif.latex?3k-1)、![3k](https://private.codecogs.com/gif.latex?3k) 和 ![3k+1](https://private.codecogs.com/gif.latex?3k+1) 的结点，小于等于位于 ![\lfloor (k+1)/3\rfloor](https://private.codecogs.com/gif.latex?\lfloor%20(k+1%29/3\rfloor) 的结点。甚至对于给定的 ![d](https://private.codecogs.com/gif.latex?d)，将其修改为任意的 ![d](https://private.codecogs.com/gif.latex?d) 叉树也并不困难。我们需要在树高（![\log_dN](https://private.codecogs.com/gif.latex?\log_dN)）和在每个结点的 ![d](https://private.codecogs.com/gif.latex?d) 个子结点找到最大者的代价之间找到折中，这取决于实现的细节以及不同操作的预期相对频繁程度。

堆上的优先队列操作如图 2.4.6 所示。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.036.png)

**图 2.4.6　在堆上的优先队列操作**

####2.4.4.4　调整数组大小

我们可以添加一个没有参数的构造函数，在 `insert()` 中添加将数组长度加倍的代码，在 `delMax()` 中添加将数组长度减半的代码，就像在 1.3 节中的栈那样。这样，算法的用例就无需关注各种队列大小的限制。当优先队列的数组大小可以调整、队列长度可以是任意值时，**命题 Q** 指出的对数时间复杂度上限就只是针对一般性的队列长度 N 而言了（请见练习 2.4.22）。

####2.4.4.5　元素的不可变性

优先队列存储了用例创建的对象，但同时假设用例代码不会改变它们（改变它们就可能打破堆的有序性）。我们可以将这个假设转化为强制条件，但程序员通常不会这么做，因为增加代码的复杂性会降低性能。

####2.4.4.6　索引优先队列

在很多应用中，允许用例引用已经进入优先队列中的元素是有必要的。做到这一点的一种简单方法是给每个元素一个**索引**。另外，一种常见的情况是用例已经有了总量为 ![N](https://private.codecogs.com/gif.latex?N) 的多个元素，而且可能还同时使用了多个（平行）数组来存储这些元素的信息。此时，其他无关的用例代码可能已经在使用一个整数索引来引用这些元素了。这些考虑引导我们设计了表 2.4.5 中的 API。

**表 2.4.5　关联索引的泛型优先队列的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>IndexMinPQ</b>&lt;Item extends Comparable&lt;Item>></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexMinPQ(int maxN)</code></td><td>创建一个最大容量为 <code>maxN</code> 的优先队列，索引的取值范围为 0 至 <code>maxN-1</code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;insert(int k, Item item)</code></td><td>插入一个元素，将它和索引 <code>k</code> 相关联</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;change(int k, Item item)</code></td><td>将索引为 <code>k</code> 的元素设为 <code>item</code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;contains(int k)</code></td><td>是否存在索引为 <code>k</code> 的元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;delete(int k)</code></td><td>删去索引 <code>k</code> 及其相关联的元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;&nbsp;min()</code></td><td>返回最小元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;minIndex()</code></td><td>返回最小元素的索引</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;delMin()</code></td><td>删除最小元素并返回它的索引</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isEmpty()</code></td><td>优先队列是否为空</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size()</code></td><td>优先队列中的元素数量</td></tr>
</table>

理解这种数据结构的一个较好方法是将它看成一个能够快速访问其中最小元素的数组。事实上它还要更好——它能够快速访问数组的一个特定子集中的最小元素（指所有被插入的元素）。换句话说，可以将名为 `pq` 的 `IndexMinPQ` 类优先队列看做数组 `pq[0..N-1]` 中的一部分元素的代表。将 `pq.insert(k, item)` 看做将 `k` 加入这个子集并使 `pq[k] = item`，`pq.change(k, item)` 则代表令 `pq[k]=item`。这两种操作没有改变其他操作所依赖的数据结构，其中最重要的就是 `delMin()`（删除最小元素并返回它的索引）和 `change()`（改变数据结构中的某个元素的索引——即 `pq[i]=item`）。这些操作在许多应用中都很重要并且依赖于对元素的引用（索引）。练习 2.4.33 说明了如何用较少的代码将算法 2.6 扩展为极高效的索引优先队列。一般来说，当堆发生变化时，我们会用下沉（元素减小时）或上浮（元素变大时）操作来恢复堆的有序性。在这些操作中，我们可以用索引查找元素。能够定位堆中的任意元素也使我们能够在 API 中加入一个 `delete()` 操作。

>**命题 Q（续）**。在一个大小为 ![N](https://private.codecogs.com/gif.latex?N) 的索引优先队列中，插入元素（insert）、改变优先级（change）、删除（delete）和删除最小元素（remove the minimum）操作所需的比较次数和 ![\log N](https://private.codecogs.com/gif.latex?\log%20N) 成正比（如表 2.4.6 所示）。

>**证明**。已知堆中所有路径最长即为 ![\sim\lg N](https://private.codecogs.com/gif.latex?\sim\lg%20N)，从代码中很容易得到这个结论。

**表 2.4.6　含有 ![N](https://private.codecogs.com/gif.latex?N) 个元素的基于堆的索引优先队列所有操作在最坏情况下的成本**

|操作|比较次数的增长数量级|
|-|-|
|`insert()`|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|
|`change()`|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|
|`contains()`|1|
|`delete()`|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|
|`min()`|1|
|`minIndex()`|1|
|`delMin()`|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|

这段讨论针对的是找出最小元素的队列；和以前一样，我们也在本书网站上实现了一个找出最大元素的版本 IndexMaxPQ。

####2.4.4.7　索引优先队列用例

下面的用例调用了 IndexMinPQ 的代码 `Multiway` 解决了**多向归并**问题：它将多个有序的输入流归并成一个有序的输出流。许多应用中都会遇到这个问题。输入可能来自于多种科学仪器的输出（按时间排序），或是来自多个音乐或电影网站的信息列表（按名称或艺术家名字排序），或是商业交易（按账号或时间排序），或者其他。如果有足够的空间，你可以把它们简单地读入一个数组并排序，但如果用了优先队列，**无论输入有多长**你都可以把它们全部读入并排序。

>**使用优先队列的多向归并**

>```
>public class Multiway
>{
>    public static void merge(In[] streams)
>    {
>       int N = streams.length;
>       IndexMinPQ<String> pq = new IndexMinPQ<String>(N);
>
>       for (int i = 0; i < N; i++)
>          if (!streams[i].isEmpty())
>              pq.insert(i, streams[i].readString());
>
>       while (!pq.isEmpty())
>       {
>          StdOut.println(pq.min());
>          int i = pq.delMin();
>
>          if (!streams[i].isEmpty())
>              pq.insert(i, streams[i].readString());
>       }
>    }
>
>    public static void main(String[] args)
>    {
>      int N = args.length;
>      In[] streams = new In[N];
>      for (int i = 0; i < N; i++)
>          streams[i] = new In(args[i]);
>      merge(streams);
>    }
>}
>```

>这段代码调用了 IndexMinPQ 来将作为命令行参数输入的多行有序字符串归并为一行有序的输出（请见正文）。每个输入流的索引都关联着一个元素（输入中的下个字符串）。初始化之后，代码进入一个循环，删除并打印出队列中最小的字符串，然后将该输入的下一个字符串添加为一个元素。为了节约，下面将所有的输出排在了一行——实际输出应该是一个字符串一行。

>```
>% more m1.txt
>A B C F G I I Z
>% more m2.txt
>B D H P Q Q
>% more m3.txt
>A B E F J N
>```

>　

>```
>% java Multiway m1.txt m2.txt m3.txt
>A A B B B C D E F F G H I I J N P Q Q Z
>```

###2.4.5　堆排序

我们可以把任意优先队列变成一种排序方法。将所有元素插入一个查找最小元素的优先队列，然后再重复调用**删除最小元素**的操作来将它们按顺序删去。用无序数组实现的优先队列这么做相当于进行一次插入排序。用基于堆的优先队列这样做等同于哪种排序？一种全新的排序方法！下面我们就用堆来实现一种经典而优雅的排序算法——**堆排序**。

堆排序可以分为两个阶段。在**堆的构造**阶段中，我们将原始数组重新组织安排进一个堆中；然后在**下沉排序**阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。为了和我们已经学习过的代码保持一致，我们将使用一个面向最大元素的优先队列并重复删除最大元素。为了排序的需要，我们不再将优先队列的具体表示隐藏，并将直接使用 `swim()` 和 `sink()` 操作。这样我们在排序时就可以将需要排序的数组本身作为堆，因此无需任何额外空间。

####2.4.5.1　堆的构造

由 ![N](https://private.codecogs.com/gif.latex?N) 个给定的元素构造一个堆有多难？我们当然可以在与 ![N\log N](https://private.codecogs.com/gif.latex?N\log%20N) 成正比的时间内完成这项任务，只需从左至右遍历数组，用 `swim()` 保证扫描指针左侧的所有元素已经是一棵堆有序的完全树即可，就像连续向优先队列中插入元素一样。一个更聪明更高效的办法是从右至左用 `sink()` 函数构造子堆。数组的每个位置都已经是一个子堆的根结点了，`sink()` 对于这些子堆也适用。如果一个结点的两个子结点都已经是堆了，那么在该结点上调用 `sink()` 可以将它们变成一个堆。这个过程会递归地建立起堆的秩序。开始时我们只需要扫描数组中的一半元素，因为我们可以跳过大小为 1 的子堆。最后我们在位置 1 上调用 `sink()` 方法，扫描结束。在排序的第一阶段，堆的构造方法和我们的想象有所不同，因为它的目标是产生一个堆有序的结果，其中最大元素位于数组的开头（次大的元素在附近），而非期望的把最大元素放到最后。

>**命题 R**。用下沉操作由 ![N](https://private.codecogs.com/gif.latex?N) 个元素构造堆只需少于 ![2N](https://private.codecogs.com/gif.latex?2N) 次比较以及少于 ![N](https://private.codecogs.com/gif.latex?N) 次交换。

>**证明**。观察可知，构造过程中处理的堆都较小。例如，要构造一个 127 个元素的堆，我们会处理 32 个大小为 3 的堆，16 个大小为 7 的堆，8 个大小为 15 的堆，4 个大小为 31 的堆，2 个大小为 63 的堆和 1 个大小为 127 的堆，因此（最坏情况下）需要 32×1 + 16×2 + 8×3 + 4×4 + 2×5 + 1×6 = 120 次交换（以及两倍的比较）。完整证明请见练习 2.4.20。

堆排序的实现过程如算法 2.7 所示。

>**算法 2.7　堆排序**

>```
>public static void sort(Comparable[] a)
>{
>    int N = a.length;
>    for (int k = N/2; k >= 1; k--)
>       sink(a, k, N);
>    while (N > 1)
>    {
>       exch(a, 1, N--);
>       sink(a, 1, N);
>    }
>}
>```

>这段代码用 `sink()` 方法将 `a[1]` 到 `a[N]` 的元素排序（`sink()` 被修改过，以 `a[]` 和 `N` 作为参数）。`for` 循环构造了堆，然后 `while` 循环将最大的元素 `a[1]` 和 `a[N]` 交换并修复了堆，如此重复直到堆变空。将 `exch()` 和 `less()` 的实现中的索引减一即可得到和其他排序算法一致的实现（将 `a[0]` 至 `a[N-1]` 排序）。堆排序具体流程示意图显示在图 2.4.7 中。

>![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.037.png)

>**堆排序的轨迹（每次下沉后的数组内容）**

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.038.png)

**图 2.4.7　堆排序：堆的构造（左）和下沉排序（右）**

####2.4.5.2　下沉排序

堆排序的主要工作都是在第二阶段完成的。这里我们将堆中的最大元素删除，然后放入堆缩小后数组中空出的位置。这个过程和选择排序有些类似（按照降序而非升序取出所有元素），但所需的比较要少得多，因为堆提供了一种从未排序部分找到最大元素的有效方法。

>**命题 S**。将 ![N](https://private.codecogs.com/gif.latex?N) 个元素排序，堆排序只需少于（![2N\lg N+2N](https://private.codecogs.com/gif.latex?2N\lg%20N+2N)）次比较（以及一半次数的交换）。

>**证明**。![2N](https://private.codecogs.com/gif.latex?2N) 项来自于堆的构造（见命题 R）。![2N\lg N](https://private.codecogs.com/gif.latex?2N\lg%20N) 项来自于每次下沉操作最大可能需要 ![2\lg N](https://private.codecogs.com/gif.latex?2\lg%20N) 次比较（见命题 P 与命题 Q）。

算法 2.7 完整地实现了这些思想，也就是经典的**堆排序**算法。它的发明人是 J. W. J. Williams，并由 R. W. Floyd 在 1964 年改进。尽管这段程序中循环的任务各不同（第一段循环构造堆，第二段循环在下沉排序中销毁堆），它们都是基于 `sink()` 方法。我们将该实现和优先队列的 API 独立开来是为了突出这个排序算法的简洁性（`sort()` 方法只需 8 行代码，`sink()` 函数 8 行），并使其可以嵌入其他代码之中。

和以前一样，通过研究可视轨迹（如图 2.4.8 所示）我们可以深入了解算法的操作。一开始算法的行为似乎杂乱无章，因为随着堆的构建较大的元素都被移动到了数组的开头，但接下来算法的行为看起来就和选择排序一模一样了（除了它比较的次数少得多）。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.039.png)

**图 2.4.8　堆排序的可视轨迹**

和我们学过的其他算法一样，很多人都研究过许多改进基于堆的优先队列的实现和堆排序的方法。我们这里简要地看看其中之一。

####2.4.5.3　先下沉后上浮

大多数在下沉排序期间重新插入堆的元素会被直接加入到堆底。Floyd 在 1964 年观察发现，我们正好可以通过免去检查元素是否到达正确位置来节省时间。在下沉中总是直接提升较大的子结点直至到达堆底，然后再使元素上浮到正确的位置。这个想法几乎可以将比较次数减少一半——接近了归并排序所需的比较次数（随机数组）。这种方法需要额外的空间，因此在实际应用中只有当比较操作代价较高时才有用（例如，当我们在将字符串或者其他键值较长类型的元素进行排序时）。

**堆排序在排序复杂性的研究中有着重要的地位**，因为它是我们所知的唯一能够同时最优地利用空间和时间的方法——在最坏的情况下它也能保证使用 ![\sim2N\lg N](https://private.codecogs.com/gif.latex?\sim2N\lg%20N) 次比较和恒定的额外空间。当空间十分紧张的时候（例如在嵌入式系统或低成本的移动设备中）它很流行，因为它只用几行就能实现（甚至机器码也是）较好的性能。但现代系统的许多应用很少使用它，因为它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法，如快速排序、归并排序，甚至是希尔排序。

另一方面，用堆实现的优先队列在现代应用程序中越来越重要，因为它能在**插入操作**和**删除最大元素操作**混合的动态场景中保证对数级别的运行时间。我们会在本书后续章节见到更多的例子。

###答疑

**问**　我还是不明白优先队列是做什么用的。为什么我们不直接把元素排序然后再一个个地引用有序数组中的元素？

**答**　在某些数据处理的例子里，比如 `TopM` 和 `Multiway`，总数据量太大，无法排序（甚至无法全部装进内存）。如果你需要从 10 亿个元素中选出最大的十个，你真的想把一个 10 亿规模的数组排序吗？但有了优先队列，你就只用一个能存储十个元素的队列即可。在其他的例子中，我们甚至无法同时获取所有的数据，因此只能先从优先队列中取出并处理一部分，然后再根据结果决定是否向优先队列中添加更多的数据。

**问**　为什么不像我们在其他排序算法中那样使用 `Comparable` 接口，而在 MaxPQ 中使用泛型的 `Item` 呢？

**答**　这么做的话 `delMax()` 的用例就需要将返回值转换为某种具体的类型，比如 `String`。一般来说，应该尽量避免在用例中进行类型转换。

**问**　为什么在堆的表示中不使用 `a[0]` ？

**答**　这么做可以稍稍简化计算。实现从 0 开始的堆并不困难，`a[0]` 的子结点是 `a[1]` 和 `a[2]`，`a[1]` 的子结点是 `a[3]` 和 `a[4]`，`a[2]` 的子结点是 `a[5]` 和 `a[6]`，以此类推。但大多数程序员更喜欢我们的简单方法。另外，将 `a[0]` 的值用作哨兵（作为 `a[1]` 的父结点）在某些堆的应用中很有用。

**问**　在我看来，在堆排序中构造堆时，逐个向堆中添加元素比 2.4.5.1 节中描述的由底向上的复杂方法更简单。为什么要这么做？

**答**　对于一个排序算法来说，这么做能够快上 20%，而且所需的代码更少（不会用到 `swim()` 函数）。理解算法的难度并不一定与它的简洁性或者效率相关。

**问**　如果我去掉 MaxPQ 的实现中的 `extends Comparable<Key>` 这句话会怎样？

**答**　和以前一样，回答这类问题的最简单的办法就是你自己直接试试。如果这么做 MaxPQ 会报出一个编译错误：

```
MaxPQ.java:21: cannot find symbol
symbol  : method compareTo(Item)
```

　　　Java 这样告诉你它不知道 `Item` 对象的 `compareTo()` 方法，因为你没有声明 `Item extends Comparable<Item>`。

###练习

**2.4.1**　用序列 `P R I O * R * * I * T * Y * * * Q U E * * * U * E` （字母表示**插入元**素，星号表示**删除最大元素**）操作一个初始为空的优先队列。给出每次**删除最大元素**返回的字符。

**2.4.2**　分析以下说法：要实现在常数时间找到**最大元素**，为何不用一个栈或队列，然后记录已插入的最大元素并在找出最大元素时返回它的值？

**2.4.3**　用以下数据结构实现优先队列，支持**插入元素**和**删除最大元素**的操作：无序数组、有序数组、无序链表和链表。将你的 4 种实现中每种操作在最坏情况下的运行时间上下限制成一张表格。

**2.4.4**　一个按降序排列的数组也是一个面向最大元素的堆吗？

**2.4.5**　将 E A S Y Q U E S T I O N 顺序插入一个面向最大元素的堆中，给出结果。

**2.4.6**　按照练习 2.4.1 的规则，用序列 `P R I O * R * * I * T * Y * * * Q U E * * * U * E` 操作一个初始为空的面向最大元素的堆，给出每次操作后堆的内容。

**2.4.7**　在堆中，最大的元素一定在位置 1 上，第二大的元素一定在位置 2 或者 3 上。对于一个大小为 31 的堆，给出第 ![k](https://private.codecogs.com/gif.latex?k) 大的元素可能出现的位置和不可能出现的位置，其中 ![k=2](https://private.codecogs.com/gif.latex?k=2)、3、4（设元素值不重复）。

**2.4.8**　回答上一道练习中第 ![k](https://private.codecogs.com/gif.latex?k) **小**元素的可能和不可能的位置。

**2.4.9**　给出 `A B C D E` 五个元素可能构造出来的所有堆，然后给出 `A A A B B` 这五个元素可能构造出来的所有堆。

**2.4.10**　假设我们不想浪费堆有序的数组 `pq[]` 中的那个位置，将最大的元素放在 `pq[0]`，它的子结点放在 `pq[1]` 和 `pq[2]`，以此类推。`pq[k]` 的父结点和子结点在哪里？

**2.4.11**　如果你的应用中有大量的**插入元素**的操作，但只有若干**删除最大元素**操作，哪种优先队列的实现方法更有效：堆、无序数组、有序数组？

**2.4.12**　如果你的应用场景中大量的找出**最大元素**的操作，但**插入元素**和**删除最大元素**操作相对较少，哪种优先队列的实现方法更有效：堆、无序数组、有序数组？

**2.4.13**　想办法在 `sink()` 中避免检查 `j < N`。

**2.4.14**　对于没有重复元素的大小为 ![N](https://private.codecogs.com/gif.latex?N) 的堆，一次删除最大元素的操作中最少要交换几个元素？构造一个能够达到这个交换次数的大小为 15 的堆。连续两次**删除最大元素**呢？三次呢？

**2.4.15**　设计一个程序，在线性时间内检测数组 `pq[]` 是否是一个面向最小元素的堆。

**2.4.16**　对于 ![N=32](https://private.codecogs.com/gif.latex?N=32)，构造数组使得堆排序使用的比较次数最多以及最少。

**2.4.17**　证明：构造大小为 ![k](https://private.codecogs.com/gif.latex?k) 的面向最小元素的优先队列，然后进行 ![N-k](https://private.codecogs.com/gif.latex?N-k) 次替换最小元素操作（**删除最小元素**后再**插入元素**）后，![N](https://private.codecogs.com/gif.latex?N) 个元素中的前 ![k](https://private.codecogs.com/gif.latex?k) 大元素均会留在优先队列中。

**2.4.18**　在 MaxPQ 中，如果一个用例使用 `insert()` 插入了一个比队列中的所有元素都大的新元素，随后立即调用 `delMax()`。假设没有重复元素，此时的堆和进行这些操作之前的堆完全相同吗？进行两次 `insert()`（第一次插入一个比队列所有元素都大的元素，第二次插入一个更大的元素）操作接两次 `delMax()` 操作呢？

**2.4.19**　实现 MaxPQ 的一个构造函数，接受一个数组作为参数。使用正文 2.4.5.1 节中所述的自底向上的方法构造堆。

**2.4.20**　证明：基于下沉的堆构造方法使用的比较次数小于 ![2N](https://private.codecogs.com/gif.latex?2N)，交换次数小于 ![N](https://private.codecogs.com/gif.latex?N)。

###提高题

**2.4.21**　**基础数据结构**。说明如何使用优先队列实现第 1 章中的栈、队列和随机队列这几种数据结构。

**2.4.22**　**调整数组大小**。在 MaxPQ 中加入调整数组大小的代码，并和命题 Q 一样证明对于一般性长度为 ![N](https://private.codecogs.com/gif.latex?N) 的队列其数组访问的上限。

**2.4.23**　**Multiway 的堆**。只考虑比较的成本且假设找到 ![t](https://private.codecogs.com/gif.latex?t) 个元素中的最大者需要 ![t](https://private.codecogs.com/gif.latex?t) 次比较，在堆排序中使用 ![t](https://private.codecogs.com/gif.latex?t) 向堆的情况下找出使比较次数 ![N\lg N](https://private.codecogs.com/gif.latex?N\lg%20N) 的系数最小的 ![t](https://private.codecogs.com/gif.latex?t) 值。首先，假设使用的是一个简单通用的 `sink()` 方法；其次，假设 Floyd 方法在内循环中每轮可以节省一次比较。

**2.4.24**　**使用链接的优先队列**。用堆有序的二叉树实现一个优先队列，但使用链表结构代替数组。每个结点都需要三个链接：两个向下，一个向上。你的实现即使在无法预知队列大小的情况下也能保证优先队列的基本操作所需的时间为对数级别。

**2.4.25**　**计算数论**。编写程序 CubeSum.java，在不使用额外空间的条件下，按大小顺序打印所有 ![a^3+b^3](https://private.codecogs.com/gif.latex?a^3+b^3) 的结果，其中 ![a](https://private.codecogs.com/gif.latex?a) 和 ![b](https://private.codecogs.com/gif.latex?b) 为 0 至 ![N](https://private.codecogs.com/gif.latex?N) 之间的整数。也就是说，不要全部计算 ![N^2](https://private.codecogs.com/gif.latex?N^2) 个和然后排序，而是创建一个最小优先队列，初始状态为 ![(0^3,0,0),(1^3,1,0),(2^3,2,0),\cdots,(N^3,N,0)](https://private.codecogs.com/gif.latex?(0^3,0,0%29,(1^3,1,0%29,(2^3,2,0%29,\cdots,(N^3,N,0%29)。这样只要优先队列非空，删除并打印最小的元素 ![(i^3+j^3,i,j)](https://private.codecogs.com/gif.latex?(i^3+j^3,i,j%29)。然后如果 ![j<N](https://private.codecogs.com/gif.latex?j%3CN)，插入元素 ![(i^3+(j+1)^3,i,j+1)](https://private.codecogs.com/gif.latex?(i^3+(j+1%29^3,i,j+1%29)。用这段程序找出 0 到 ![10^6](https://private.codecogs.com/gif.latex?10^6) 之间所有满足 ![a^3+b^3=c^3+d^3](https://private.codecogs.com/gif.latex?a^3+b^3=c^3+d^3) 的不同整数 a,b,c,d。

**2.4.26**　**无需交换的堆**。因为 `sink()` 和 `swim()` 中都用到了初级函数 `exch()`，所以所有元素都被多加载并存储了一次。回避这种低效方式，用插入排序给出新的实现（请见练习 2.1.25）。

**2.4.27**　**找出最小元素**。在 MaxPQ 中加入一个 `min()` 方法。你的实现所需的时间和空间都应该是常数。

**2.4.28**　**选择过滤**。编写一个 TopM 的用例，从标准输入读入坐标 ![(x,y,z)](https://private.codecogs.com/gif.latex?(x,y,z%29)，从命令行得到值 ![M](https://private.codecogs.com/gif.latex?M)，然后打印出距离原点的欧几里得距离最小的 ![M](https://private.codecogs.com/gif.latex?M) 个点。在 ![N=10^8](https://private.codecogs.com/gif.latex?N=10^8) 且 ![M=10^4](https://private.codecogs.com/gif.latex?M=10^4) 时，预计程序的运行时间。

**2.4.29**　**同时面向最大和最小元素的优先队列**。设计一个数据类型，支持如下操作：**插入元素**、**删除最大元素**、**删除最小元素**（所需时间均为对数级别），以及**找到最大元素**、**找到最小元素**（所需时间均为常数级别）。**提示**：用两个堆。

**2.4.30**　**动态中位数查找**。设计一个数据类型，支持在对数时间内插入元素，常数时间内**找到中位数**并在对数时间内**删除中位数**。**提示**：用一个面向最大元素的堆再用一个面向最小元素的堆。

**2.4.31**　**快速插入**。用基于比较的方式实现 MinPQ 的 API，使得插入元素需要 ![\sim\log\log N](https://private.codecogs.com/gif.latex?\sim\log\log%20N) 次比较，删除最小元素需要 ![\sim2\log N](https://private.codecogs.com/gif.latex?\sim2\log%20N) 次比较。**提示**：在 `swim()` 方法中用二分查找来寻找祖先结点。

**2.4.32**　**下界**。请证明，不存在一个基于比较的对 MinPQ 的 API 的实现能够使得**插入元素**和**删除最小元素**的操作都保证只使用 ![\sim N\log\log N](https://private.codecogs.com/gif.latex?\sim%20N\log\log%20N) 次比较。

**2.4.33**　**索引优先队列的实现**。按照 2.4.4.6 节的描述修改算法 2.6 来实现索引优先队列 API 中的基本操作：

使用 `pq[]` 保存索引，添加一个数组 `keys[]` 来保存元素，再添加一个数组 `qp[]` 来保存 `pq[]` 的逆序——`qp[i]` 的值是 `i` 在 `pq[]` 中的位置（即索引 `j`，`pq[j]=i`）。修改算法 2.6 的代码来维护这些数据结构。若 `i` 不在队列之中，则总是令 `qp[i] = -1` 并添加一个方法 `contains()` 来检测这种情况。你需要修改辅助函数 `exch()` 和 `less()`，但不需要修改 `sink()` 和 `swim()`。

　　　**部分答案**：

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.040.png)

**2.4.34**　**索引优先队列的实现（附加操作）**。向练习 2.4.33 的实现中添加 `minIndex()`、`change()` 和 `delete()` 方法。

　　　**解答**：

```
public int minIndex()

{  return pq[1];  }

public void change(int k, Key Key)
{
   keys[k] = key;
   swim(qp[k]);
   sink(qp[k]);
}

public void delete(int k)
{
   int index = qp[k];
   exch(index, N--);
   swim(index);
   sink(index);
   keys[k] = null;
   qp[k] = -1;
}
```

**2.4.35**　**离散概率分布的取样**。编写一个 `Sample` 类，其构造函数接受一个 `double` 类型的数组 `p[]` 作为参数并支持以下操作：`random()`——返回任意索引 `i` 及其概率 `p[i]/T`（`T` 是 `p[]` 中所有元素之和）；`change(i, v)`——将 `p[i]` 的值修改为 `v`。**提示**：使用完全二叉树，每个结点对应一个权重 `p[i]`。在每个结点记录其下子树的权重之和。为了产生一个随机的索引，取 `0` 到 `T` 之间的一个随机数并根据各个结点的权重之和来判断沿着哪条子树搜索下去。在更新 `p[i]` 时，同时更新从根结点到 `i` 的路径上的所有结点。不要像堆的实现那样显式使用指针。

###实验题

**2.4.36**　**性能测试 I**。编写一个性能测试用例，用**插入元素**操作填满一个优先队列，然后用**删除最大元素**操作删去一半元素，再用**插入元素**操作填满优先队列，再用**删除最大元素**操作删去所有元素。用一列随机的长短不同的元素多次重复以上过程，测量每次运行的用时，打印平均用时或是将其绘制成图表。

**2.4.37**　**性能测试 II**。编写一个性能测试用例，用**插入元素**操作填满一个优先队列，然后在一秒钟之内尽可能多地连续反复调用**删除最大元素**和**插入元素**的操作。用一列随机的长短不同的元素多次重复以上过程，将程序能够完成的**删除最大元素**操作的平均次数打印出来或是绘成图表。

**2.4.38**　**练习测试**。编写一个练习用例，用算法 2.6 中实现的优先队列的接口方法处理实际应用中可能出现的高难度或是极端情况。例如，元素已经有序、元素全部逆序、元素全部相同或是所有元素只有两个值。

**2.4.39**　**构造函数的代价**。对于 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^6](https://private.codecogs.com/gif.latex?10^6) 和 ![10^9](https://private.codecogs.com/gif.latex?10^9)，根据经验判断堆排序时构造堆占总耗时的比例。

**2.4.40**　**Floyd 方法**。根据正文中 Floyd 的先沉后浮思想实现堆排序。对于 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^6](https://private.codecogs.com/gif.latex?10^6) 和 ![10^9](https://private.codecogs.com/gif.latex?10^9) 大小的随机不重复数组，记录你的程序所使用的比较次数和标准实现所使用的比较次数。

**2.4.41**　**Multiway 堆**。根据正文中的描述实现基于完全堆有序的三叉树和四叉树的堆排序。对于 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^6](https://private.codecogs.com/gif.latex?10^6) 和 ![10^9](https://private.codecogs.com/gif.latex?10^9) 大小的随机不重复数组，记录你的程序所使用的比较次数和标准实现所使用的比较次数。

**2.4.42**　**堆的前序表示**。用前序法而非级别表示一棵堆有序的树，并基于此实现堆排序。对于 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^6](https://private.codecogs.com/gif.latex?10^6) 和 ![10^9](https://private.codecogs.com/gif.latex?10^9) 大小的随机不重复数组，记录你的程序所使用的比较次数和标准实现所使用的比较次数。

##2.5　应用

排序算法和优先队列在许多场景中有着广泛的应用。本节中我们将简要地浏览一遍这些应用，研究如何能让我们已经学习过的高效算法在这些应用中大展身手，然后讨论一下应该如何使用我们的排序和优先队列的代码。

排序如此有用的一个主要原因是，在一个有序的数组中查找一个元素要比在一个无序的数组中查找简单得多。人们用了一个多世纪发现在一本按姓氏排序的电话黄页中查找某个人的电话号码最容易。现在，数字音乐作家们将歌曲文件按照作家名或是歌曲名排序，搜索引擎按照搜索结果的重要性的高低显示结果，电子表格按照某一列的排序结果显示所有栏，矩阵处理工具将一个对称矩阵的真实特征值按照降序排列，等等。只要队列是有序的，很多其他任务也更容易完成，比如在本书最后的有序索引中查找某项，或是从一列长长的邮件列表或者投票人列表或者网站列表中删去重复项，或是在统计学计算中剔除异常值、查找中位数或者计算比例。

在许多看似无关的领域中，排序其实仍然是一个重要的子问题。数据压缩、计算机图形学、计算生物学、供应链管理、组合优化、社会选择和投票等，不一而足。我们在本章中学习的算法也在开发本书其他章节的强大算法的过程中起到了关键作用。

通用排序算法是最重要的，因此我们首先会考虑一些在构建适用于多种情况的排序算法时需要注意的实际问题。虽然部分话题只适用于 Java，但每个问题都仍然是所有系统需要解决的。

我们的主要目的是为了说明，尽管我们所学习的各种算法的思想相对简单，但它们的适用领域仍然广泛。经过验证的各种排序算法的应用列表很长，我们在这里只会涉及其中的一小部分，一些是科学领域的，一些是算法领域的，还有一些是商业领域的。在练习中你们还能找到更多例子，本书的网站上还有更多。另外，为了更好的说明问题，后续章节还会不时地引用本章的内容！

###2.5.1　将各种数据排序

我们的实现的排序对象是由实现了 `Comparable` 接口的对象组成的数组。Java 的约定使得我们能够利用 Java 的**回调**机制将任意实现了 `Comparable` 接口的数据类型排序。如 2.1 节所述，实现 `Comparable` 接口只需要定义一个 `compareTo()` 函数并在其中定义该数据类型中的**大小关系**。我们的代码直接能够将 `String`、`Integer`、`Double` 和一些其他例如 `File` 和 `URL` 类型的数组排序，因为它们都实现了 `Comparable` 接口。同一段代码能够适应所有这些类型的数据是非常方便的，但一般的应用程序中需要排序的数据类型都是应用程序自己定义的。相应，在自定义的数据类型中实现一个 `compareTo()` 方法也是很常见的，这样就实现了 `Comparable` 接口，也就使得这种数据类型可以被排序了（也可以用其构造优先队列）。

####2.5.1.1　交易事务

排序算法的一种典型应用就是商业数据处理。例如，设想一家互联网商业公司为每笔交易记录都保存了所有的相关信息，包括客户名、日期、金额等。如今，一家成功的商业公司需要能够处理数百万的这种交易数据。如我们在练习 2.1.21 中看到的，一种合适的方法是将交易记录按金额大小排序，我们在类的定义中实现一个恰当的 `compareTo()` 方法就可以做到这一点。这样我们在处理 `Transaction` 类型的数组 `a[]` 时就可以先将其排序，比如这样 `Quick.sort(a)`。我们的排序算法对 `Transaction` 类型一无所知，但 Java 的 `Comparable` 接口使我们可以为该类型定义大小关系，这样我们的任意排序算法都能够用于 `Transaction` 对象了。或者我们也可以令 `Transaction` 对象按照日期排序（如下面的代码所示），将 `compareTo()` 方法实现为比较 `Date` 字段。因为 `Date` 对象本身也实现了 `Comparable` 接口，我们可以直接调用它的 `compareTo()` 方法而不用自己实现了。将这种类型按照用户名排序也是合理的。使算法的用例能够灵活地用不同的字段排序则是我们在稍后将要面对的另一项有趣的挑战。

```
public int compareTo(Transaction that)
{  return this.when.compareTo(that.when);  }
```

{-:-}将交易记录按照日期排序的 `compareTo()` 方法

####2.5.1.2　指针排序

我们使用的方法在经典教材中被称为**指针排序**，因为我们只处理元素的引用而不移动数据本身。在其他编程语言例如 C 和 C++ 之中，程序员需要明确地指出操作的是数据还是指向数据的指针，而在 Java 中，指针操作是隐式的。除了原始数字类型之外，我们操作的**总是**数据的引用（指针），而非数据本身。指针排序增加了一层间接性，因为数组保存的是待排序的对象的引用，而非对象本身。我们会简要讨论一些相关的问题。对于多个引用数组，我们可以将同一组数据的不同部分按照多种方式排序（可能会用到下面提到的多键）。

####2.5.1.3　不可变的键

如果在排序后用例还能够修改键值，那么数组就很可能不再是有序的了。类似，优先队列在用例能够修改键值的情况下也不太可能正常工作。在 Java 中，可以用不可变的数据类型作为键来避免这个问题。大多数你可能用作键的数据类型，例如 `String`、`Integer`、`Double` 和 `File` 都是不可变的。

####2.5.1.4　廉价的交换

使用引用的另一个好处是我们不必移动整个元素。对于元素大而键小的数组来说这带来的节约是巨大的，因为比较只需要访问元素的一小部分，而排序过程中元素的大部分都不会被访问到。对于几乎任意大小的元素，使用引用使得在一般情况下交换的成本和比较的成本几乎相同（代价是需要额外的空间存储这些引用）。如果键值很长，那么交换的成本甚至会低于比较的成本。研究将数字排序的算法性能的一种方法就是观察其所需的比较和交换总数，因为这里隐式地假设了比较和交换的成本是相同的。由此得出的结论则适用于 Java 中的许多应用，因为我们都是在将引用排序。

####2.5.1.5　多种排序方法

在很多应用中我们都希望根据情况将一组对象按照不同的方式排序。Java 的 `Comparator` 接口允许我们在一个类之中实现多种排序方法。它只有一个 `compare()` 方法来比较两个对象。如果一种数据类型实现了这个接口，我们可以像 2.5.1.6 节中的例子那样将另一个实现了 `Comparator` 接口的对象传递给 `sort()` 方法（`sort()` 再将其传递给 `less()`）。`Comparator` 接口允许我们为任意数据类型定义任意多种排序方法。用 `Comparator` 接口来代替 `Comparable` 接口能够更好地将数据类型的定义和两个该类型的对象应该如何比较的定义区分开来。事实上，比较两个对象的确可以有多种标准，`Comparator` 接口使得我们能够在其中进行选择。例如，想在忽略大小写的情况下将字符串数组 `a[]` 排序，可以使用 Java 的 `String` 类型中定义的 `CASE_INSENSITVE_ORDER` 比较器并调用 `Insertion.sort(a, String.CASE_INSENSITIVE_ORDER)`。你也知道，精确定义的字符串排序规则十分复杂，而各种自然语言又差异很大，所以 Java 的 `String` 类型含有很多比较器。

####2.5.1.6　多键数组

一般在应用程序中，一个元素的多种属性都可能被用作排序的键。在交易的例子中，有时可能需要将交易按照客户排序（例如，找出每个客户进行的所有交易）；有时又可能需要按照金额排序（例如，需要找出交易金额较高的交易）；有时还可能用另一个属性来排序。要实现这种灵活性，`Comparator` 接口正合适。我们可以定义多种比较器，如 2.5.1.7 节展示的 `Transaction` 类的另一种实现那样。在这样定义之后，要将 `Transaction` 对象的数组按照时间排序可以调用：

```
Insertion.sort(a, new Transaction.WhenOrder())
```

或者这样来按照金额排序：

```
Insertion.sort(a, new Transaction.HowMuchOrder())
```

`sort()` 方法在每次比较中都会**回调** `Transaction` 类中用例指定的 `compare()` 方法。为了避免每次排序都创建一个新的 `Comparator` 对象，我们使用了 `public final` 来定义这些比较器（代码如下，就像 Java 定义的 `CASE_INSENSITIVE_ORDER` 一样）。

```
public static void sort(Object[] a, Comparator c)
{
   int N = a.length;
   for (int i = 1; i < N; i++)
      for (int j = i; j > 0 && less(c, a[j], a[j-1]); j--)
         exch(a, j, j-1);
}

private static boolean less(Comparator c, Object v, Object w)
{  return c.compare(v, w) < 0;  }

private static void exch(Object[] a, int i, int j)
{  Object t = a[i]; a[i] = a[j]; a[j] = t;  }
```

{-:-}使用了 `Comparator` 的插入排序

####2.5.1.7　使用比较器实现优先队列

比较器的灵活性也可以用在优先队列上。我们可以按照以下步骤来扩展算法 2.6 的标准实现来支持比较器：

* 导入 `java.util.Comparator`；
* 为 MaxPQ 添加一个实例变量 `comparator` 以及一个构造函数，该构造函数接受一个比较器作为参数并用它将 `comparator` 初始化；
* 在 `less()` 中检查 `comparator` 属性是否为 `null`（如果不是的话就用它进行比较）。

实现代码如下：

```
import java.util.Comparator;

public class Transaction
{
   ...
   private final String who;
   private final Date when;
   private final double amount;
   ...
   public static class WhoOrder implements Comparator<Transaction>
   {
      public int compare(Transaction v, Transaction w)
      {  return v.who.compareTo(w.who);  }
   }

   public static class WhenOrder implements Comparator<Transaction>
   {
      public int compare(Transaction v, Transaction w)
      {  return v.when.compareTo(w.when);  }
   }

   public static class HowMuchOrder implements Comparator<Transaction>
   {
      public int compare(Transaction v, Transaction w)
      {
         if (v.amount < w.amount) return -1;
         if (v.amount > w.amount) return +1;
         return 0;
      }
   }
}
```

{-:-}使用了``Comparator``的插入排序

例如，修改后可以使用 `Transaction` 的多种字段构造不同的优先队列，分别按照时间、地点、账号排序。如果你在 MinPQ 中去掉了 `Key extends Comparable<Key>` 这句话，甚至可以支持尚未定义过比较方法的键。

####2.5.1.8　稳定性

如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是**稳定的**。这个性质在许多情况下很重要。例如，考虑一个需要处理大量含有地理位置和时间戳的事件的互联网商业应用程序。首先，我们在事件发生时将它们挨个存储在一个数组中，这样在数组中它们已经是按照时间顺序排好了的。现在假设在进一步处理前将按照地理位置切分。一种简单的方法是将数组按照位置排序。如果排序算法不是稳定的，排序后的每个城市的交易可能**不会**再是按照时间顺序排列的了。很多情况下，不熟悉排序稳定性的程序员在第一次遇见这种情形时会惊讶于不稳定的排序算法似乎把数据弄得一团糟。在本章中，我们学习过的一部分算法是稳定的（插入排序和归并排序），但很多不是（选择排序、希尔排序、快速排序和堆排序）。有很多办法能够将任意排序算法变成稳定的（请见练习 2.5.18），但一般只有在稳定性是必要的情况下稳定的排序算法才有优势。人们很容易觉得算法具有稳定性是理所当然的，但事实上没有任何实际应用中常见的方法不是用了大量额外的时间和空间才做到了这一点（研究人员开发了这样的算法，但应用程序员发现它们太复杂了，无法使用）。

从另一个键上排序的稳定性如图 2.5.1 所示。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.041.png)

**图 2.5.1　从另一个键上排序的稳定性**

###2.5.2　我应该使用哪种排序算法

在本章中我们学习了许多种排序算法，这个问题就变得很自然了。排序算法的好坏很大程度上取决于它的应用场景和具体实现，但我们也学习了一些通用的算法，它们能在很多情况下达到和最佳算法接近的性能。

表 2.5.1 总结了在本章中我们学习过的排序算法的各种重要性质。除了希尔排序（它的复杂度只是一个近似）、插入排序（它的复杂度取决于输入元素的排列情况）和快速排序的两个版本（它们的复杂度和概率有关，取决于输入元素的分布情况）之外，将这些运行时间的增长数量级乘以适当的常数就能够大致估计出其运行时间。这里的常数有时和算法有关（比如堆排序的比较次数是归并排序的两倍，且两者访问数组的次数都比快速排序多得多），但主要取决于算法的实现、Java 编译器以及你的计算机，这些因素决定了需要执行的机器指令的数量以及每条指令所需的执行时间。最重要的是，因为这些都是常数，你能通过较小的 ![N](https://private.codecogs.com/gif.latex?N) 得到的实验数据和我们的标准双倍测试来推测较大的 ![N](https://private.codecogs.com/gif.latex?N) 所需的运行时间。

**表 2.5.1　各种排序算法的性能特点**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="2">算法</th><th rowspan="2">是否稳定</th><th rowspan="2">是否为原地排序</th><th colspan="2">将 <i>N</i> 个元素排序的复杂度</th><th rowspan="2">备注</th></tr>
<tr><th>时间复杂度</th><th>空间复杂度</th></tr>
<tr><td>选择排序</td><td>否</td><td>是</td><td><img src="https://private.codecogs.com/gif.latex?N^2" /></td><td>1</td><td></td></tr>
<tr><td>插入排序</td><td>是</td><td>是</td><td>介于 <img src="https://private.codecogs.com/gif.latex?N" /> 和 <img src="https://private.codecogs.com/gif.latex?N^2" /> 之间</td><td>1</td><td>取决于输入元素的排列情况</td></tr>
<tr><td>希尔排序</td><td>否</td><td>是</td><td><img src="https://private.codecogs.com/gif.latex?N\log%20N?" /><br><img src="https://private.codecogs.com/gif.latex?N^{6/5}?" /></td><td>1</td><td></td></tr>
<tr><td>快速排序</td><td>否</td><td>是</td><td><img src="https://private.codecogs.com/gif.latex?N\log%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td>运行效率由概率提供保证</td></tr>
<tr><td>三向快速排序</td><td>否</td><td>是</td><td>介于 <img src="https://private.codecogs.com/gif.latex?N" /> 和 <img src="https://private.codecogs.com/gif.latex?N\log%20N" /> 之间</td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td>运行效率由概率保证，同时也取决于输入元素的分布情况</td></tr>
<tr><td>归并排序</td><td>是</td><td>否</td><td><img src="https://private.codecogs.com/gif.latex?N\log%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td></td></tr>
<tr><td>堆排序</td><td>否</td><td>是</td><td><img src="https://private.codecogs.com/gif.latex?N\log%20N" /></td><td>1</td><td></td></tr>
</table>

>**性质 T**。快速排序是最快的通用排序算法。

>**例证**。自从数十年前快速排序发明以来，它在无数计算机系统中的无数实现已经证明了这一点。总的来说，快速排序之所以最快是因为它的内循环中的指令很少（而且它还能利用缓存，因为它总是顺序地访问数据），所以它的运行时间的增长数量级为 ![\sim cN\lg N](https://private.codecogs.com/gif.latex?\sim%20cN\lg%20N)，而这里的c比其他线性对数级别的排序算法的相应常数都要小。在使用三向切分之后，快速排序对于实际应用中可能出现的某些分布的输入变成线性级别的了，而其他的排序算法则仍然需要线性对数时间。

因此，在大多数实际情况中，快速排序是最佳选择。当然，面对多种排序方法和各式计算机及系统，这么一句干巴巴的话很难让人信服。例如，我们已经见过一个明显的例外：如果稳定性很重要而空间又不是问题，归并排序可能是最好的。我们会在第 5 章中见到更多例外。有了 `SortCompare` 这样的工具，再加上一点时间和努力，你能够更仔细地比较这些算法的性能并实现我们讨论过的各种改进方案，详见本节最后的若干练习。也许证明性质 T 的最好方式正如这里所说，在运行时间至关重要的任何排序应用中认真地考虑使用快速排序。

####2.5.2.1　将原始类型数据排序

一些性能优先的应用的重点可能是将数字排序，因此更合理的做法是跳过引用直接将原始数据类型的数据排序。例如，想想将一个 `double` 类型的数组和一个 `Double` 类型的数组排序的差别。对于前者我们可以直接交换这些数并将数组排序；而对于后者，我们交换的是存储了这些数字的 `Double` 对象的引用。如果我们只是在将一大组数排序的话，跳过引用可以为我们节省存储所有引用所需的空间和通过引用来访问数字的成本，更不用说那些调用 `compareTo()` 和 `less()` 方法的开销了。把 `Comparable` 接口替换为原始数据类型名，重定义 `less()` 方法或者干脆将调用 `less()` 的地方替换为 `a[i] < a[j]` 这样的代码，我们就能得到可以将原始数据类型的数据更快地排序的各种算法（请见练习 2.1.26）。

####2.5.2.2　Java 系统库的排序算法

为了演示表 2.5.1 所示的数据，这里我们考虑 Java 系统库中的主要排序方法 `java.util.Arrays.sort()`。根据不同的参数类型，它实际上代表了一系列排序方法：

* 每种原始数据类型都有一个不同的排序方法；
* 一个适用于所有实现了 `Comparable` 接口的数据类型的排序方法；
* 一个适用于实现了比较器 `Comparator` 的数据类型的排序方法。

Java 的系统程序员选择对原始数据类型使用（三向切分的）快速排序，对引用类型使用归并排序。这些选择实际上也暗示着用速度和空间（对于原始数据类型）来换取稳定性（对于引用类型），如刚才讨论的那样。

**我们讨论过的这些算法和思想**是包括 Java 的许多现代系统的核心组成部分。当为实际应用开发 Java 程序时，你会发现 Java 的 `Arrays.sort()` 实现（可能再加上你自己实现的 `compareTo()` 或者 `compare()`）已经基本够用了，因为它使用的三向快速排序和归并排序都是经典。

在本书中我们一般都会使用我们自己的 `Quick.sort()` 或者 `Merge.sort()`（在稳定性比空间更重要时）。你也可以使用 `Arrays.sort()`，或者在特殊的情况下使用其他排序算法。

###2.5.3　问题的归约

使用排序算法来解决其他问题的思想是算法设计领域的基本技巧——**归约**的一个例子。因为归约十分重要，我们会在第 6 章详细讨论它，同时研究几个具体实例。**归约**指的是为解决某个问题而发明的算法正好可以用来解决另一种问题。应用程序员对于归约的概念已经很熟悉了（无论是否明确地知道这一点）——每次你在使用解决问题 B 的方法来解决问题 A 时，你都是在将 A 归约为 B。实际上，实现算法的一个目标就是使算法的适用性尽可能广泛，使得问题的归约更简单。作为例子，我们先看看几个简单的排序问题。很多这种问题都以算法测验的形式出现，而解决它们的第一想法往往是平方级别的暴力破解。但很多情况下如果先将数据排序，那么解决剩下的问题就只需要线性级别的时间了，这样归约后的运行时间的增长数量级就由平方级别降低到了线性对数级别。

####2.5.3.1　找出重复元素：

在一个 `Comparable` 对象的数组中是否存在重复元素？有多少重复元素？哪个值出现得最频繁？对于小数组，用平方级别的算法将所有元素互相比较一遍就足以解答这些问题。但这么做对于大数组行不通。但有了排序，你就能在线性对数的时间内回答这些问题：首先将数组排序，然后遍历有序的数组，记录连续出现的重复元素即可。例如，下面就是一段统计数组中不重复的元素个数的代码。只要稍稍修改这段代码你就能回答上面的问题，还可以打印所有不同元素的值、所有重复元素的值，等等，即使数组很大也无妨。

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.042.png)

{-:-}统计 `a[]` 中不重复元素的个数

####2.5.3.2　排名

一组**排列**（或是排名）就是一组 ![N](https://private.codecogs.com/gif.latex?N) 个整数的数组，其中 0 到 ![N-1](https://private.codecogs.com/gif.latex?N-1) 的每个数都只出现一次。两个排列之间的 Kendall tau **距离**就是在两组数列中顺序不同的数对的数目。例如，0 3 1 6 2 5 4 和 1 0 3 6 4 2 5 之间的 Kendall tau **距离**是 4，因为 0-1、3-1、2-4、5-4 这 4 对数字在两组排列中的相对顺序不同，但其他数字的相对顺序都是相同的。这种统计方法的应用十分广泛。在社会学中它被用于研究社会选择和投票理论，在分子生物学中被用于使用基因表达图谱比较基因，在网络中被用于搜索引擎结果的排名，等等。某个排列和标准排列（即每个元素都在正确位置上的排列）的 Kendall tau **距离**就是其中逆序数对的数量。根据插入排序设计一个平方级别的算法来计算它并不困难（请回想 2.1 节中的命题 C）。高效地计算 Kendall tau 距离可以留给已经熟悉那些经典的排序算法的程序员（或者学生）作为一个有趣的练习（请见练习 2.5.19）。

####2.5.3.3　优先队列

在 2.4 节中我们已经见过两个被归约为优先队列操作的问题的例子。一个是 2.4.2.1 节中的 TopM，它能够找到输入流中 ![M](https://private.codecogs.com/gif.latex?M) 个最大的元素；另一个是 2.4.4.7 节中的 Multiway，它能够将 ![M](https://private.codecogs.com/gif.latex?M) 个输入流归并为一个有序的输出流。这两个问题都可以轻易用长度为 ![M](https://private.codecogs.com/gif.latex?M) 的优先队列解决。

####2.5.3.4　中位数与顺序统计

一个和排序有关但又不需要完全排序的重要应用就是找出一组元素的**中位数**（中间值，它不大于一半的元素又不小于另一半元素）。查找中位数在统计学计算和许多数据处理的应用程序中都很常见。它是一种特殊的**选择**：找到一组数中的第 ![k](https://private.codecogs.com/gif.latex?k) 小的元素（如下页代码所示）。“选择”在处理实验数据和其他数据中应用广泛，使用中位数和其他**顺序统计**来切分一个数组也很常见。一般，我们只需要处理一个很大的数组中的一小部分，在这种情况下，一个程序可以选择，比如将前 10% 的元素完全排序即可。2.4 节中我们的 TopM 用优先队列为无界限输入解决了这个问题。除了 TopM，另一种选择是直接将数组中的元素排序。在调用 `Quick.sort(a)` 之后，数组中的 ![k](https://private.codecogs.com/gif.latex?k) 个最小的元素就是数组的前 ![k](https://private.codecogs.com/gif.latex?k) 个元素，其中 ![k](https://private.codecogs.com/gif.latex?k) 小于数组长度。但这种方法需要调用排序，所以运行时间的增长数量级是线性对数的。

```
public static Comparable
select(Comparable[] a, int k)
{
   StdRandom.shuffle(a);
   int lo = 0, hi = a.length - 1;
   while (hi > lo)
   {
      int j = partition(a, lo, hi);
      if     (j == k)  return a[k];
      else if (j > k)  hi = j - 1;
      else if (j < k)  lo = j + 1;
   }
   return a[k];
}
```

{-:-}找到一组数中的第 ![k](https://private.codecogs.com/gif.latex?k) 小元素

还有更好的办法吗？当 ![k](https://private.codecogs.com/gif.latex?k) 很小或者很大时找出数组中的 ![k](https://private.codecogs.com/gif.latex?k) 个最小值都很简单，但当 ![k](https://private.codecogs.com/gif.latex?k) 和数组大小成一定比例时这个任务就变得比较困难了，比如找到中位数（![k=N/2](https://private.codecogs.com/gif.latex?k=N/2)）。让人惊讶的是其实上面的 `select()` 方法能够在**线性时间**内解决这个问题（这个实现需要在用例中进行类型转换；去掉这个限制的代码请见本书的网站）。为了完成这个任务，`select()` 用两个变量 `hi` 和 `lo` 来限制含有要选择的 ![k](https://private.codecogs.com/gif.latex?k) 元素的子数组，并用快速排序的切分法来缩小子数组的范围。请回想 `partition()` 方法，它会将数组的 `a[lo]` 至 `a[hi]` 重新排列并返回一个整数 `j` 使得 `a[lo..j-1]` 小于等于 `a[j]` 且 `a[j+1..hi]` 大于等于 `a[j]`。那么，如果 `k = j`，问题就解决了。如果 `k < j`，我们就需要切分左子数组（令 `hi = j-1`）；如果 `k > j`，我们则需要切分右子数组（令 `lo = j+1`）。这个循环保证了数组中 `lo` 左边的元素都小于等于 `a[lo..hi]`，而 `hi` 右边的元素都大于等于 `a[lo..hi]`。我们不断地切分直到子数组中只含有第 ![k](https://private.codecogs.com/gif.latex?k) 个元素，此时 `a[k]` 含有最小的（![k+1](https://private.codecogs.com/gif.latex?k+1)）个元素，`a[0]` 到 `a[k-1]` 都小于等于 `a[k]`，而 `a[k+1]` 及其后的元素都大于等于 `a[k]`。至于为何这个算法是线性级别的，是因为假设每次都正好将数组二分，那么比较的总次数为（![N+N/2+N/4+N/8\cdots](https://private.codecogs.com/gif.latex?N+N/2+N/4+N/8\cdots)），直到找到第 ![k](https://private.codecogs.com/gif.latex?k) 的元素，这个和显然小于 ![2N](https://private.codecogs.com/gif.latex?2N)。和快速排序一样，这里也需要一点数学知识来得到比较的上界，它比快速排序略高。这个算法和快速排序的另一个共同点是这段分析依赖于使用随机的切分元素，因此它的性能保证也来自于概率。

用快速排序的切分来查找中位数的可视轨迹如图 2.5.2 所示。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/06.d02z.043.png)

**图 2.5.2　用切分找出中位数**

>**命题 U**。平均来说，基于切分的选择算法的运行时间是线性级别的。

>**证明**。该命题的分析和快速排序的命题 K 的证明类似，但要复杂得多。结论就是算法的平均比较次数为 ![\sim2N+2k\ln(N/k)+2(N-k)\ln(N/(N-k))](https://private.codecogs.com/gif.latex?\sim2N+2k\ln(N/k%29+2(N-k%29\ln(N/(N-k%29%29)，这对于所有合法的 ![k](https://private.codecogs.com/gif.latex?k) 值都是线性的。例如，这个公式说明找到中位数 (![k=N/2](https://private.codecogs.com/gif.latex?k=N/2)) 平均需要 ![\sim(2+2\ln2)N](https://private.codecogs.com/gif.latex?\sim(2+2\ln2%29N) 次比较。注意，最坏的情况下算法的运行时间仍然是平方级别的，但与快速排序一样，将数组乱序化可以有效防止这种情况出现。

设计一个能够保证在**最坏情况下**也只需要线性比较次数的算法是计算复杂性领域的一个经典问题，但到目前为止仍然没有一个能够实用的算法。

###2.5.4　排序应用一览

排序的直接应用极为普遍和广泛，无法一一列举。你可以将歌曲按照曲名或是歌手排序，将邮件按照时间或是发件人排序（或者来电按照时间或来电者排序），将照片按照日期排序。大学会将学生的账户按照姓名或是 ID 排序。信用卡公司会将上百万甚至上亿的交易按照日期或是金额排序。科学家会将实验数据按照时间或其他标准排序来精确地模拟现实世界，从粒子或者天体的运动，到物质的结构，到社会中的人际关系。实际上，很难找到和排序**无关**的任何计算性应用！为了更好地说明这一点，我们在这一小节中举几个比应用归约更加复杂的例子，其中几个我们会在本书的其他章节更加详细地研究。

####2.5.4.1　商业计算

世界已经被信息的海洋所淹没。政府组织、金融机构和商业公司都依赖排序来管理大量的信息。无论这些信息是按照名字或者数字排序的账号、按照日期或者金额排序的交易、按照邮编或者地址排序的邮件、按照名称或者日期排序的文件等，处理这些数据必然需要排序算法。一般这些信息都会存储在大型的数据库里，能够按照多个键排序以提高搜索效率。一个普遍使用的有效方法是先收集新的信息并添加到数据库，将其按感兴趣的键排序，然后将每个键的排序结果归并到已存在的数据库中。从计算机发明的早期开始，我们学习过的这些方法就已经被用来构建庞大的基础数据，处理它们的方法则是所有这些商业活动的基石。今天，我们能够按部就班地处理上百万甚至上亿大小的数组——没有线性对数级别的排序算法也就没法将它们排序，进一步处理这些数据也会极端困难，甚至是不可能的。

####2.5.4.2　信息搜索

有序的信息确保我们可以用经典的**二分查找法**（见第 1 章）来进行高效的搜索。你会看到许多其他种类的查询也可以用相同的方式完成。有多少元素小于给定的元素？有哪些在给定的范围之内？在第 3 章中我们不但会解答这些问题，还会具体学习排序算法和二分查找的各种扩展，使得我们能够用删除和插入的混合操作解答这些问题，并保证所有操作的对数级别的性能。

####2.5.4.3　运筹学

**运筹学**指的是研究数学模型并将其应用于问题解决和决策的领域。在本书中我们会看到若干运筹学和算法研究的关系的例子。这里我们先来看排序算法在运筹学的经典问题——**调度**中的应用。假设我们需要完成 ![N](https://private.codecogs.com/gif.latex?N) 个任务，第 ![j](https://private.codecogs.com/gif.latex?j) 个任务需要耗时 ![t_j](https://private.codecogs.com/gif.latex?t_j) 秒。我们需要在完成所有任务的同时尽量确保客户满意，将每个任务的平均完成时间最小化。按照**最短优先**的原则，只要我们将任务按照处理时间升序排列就可以达到目标。因此我们可以将任务按照耗时排序，或是将它们插入到一个最小优先队列中。如果加上其他各种限制，我们可以得到不同的调度问题，这在工业界的应用中很常见，也被很好地研究过。另一个例子是**负载均衡**问题。假设我们有 ![M](https://private.codecogs.com/gif.latex?M) 个相同的处理器以及 ![N](https://private.codecogs.com/gif.latex?N) 个任务，我们的目标是用尽可能短的时间在这些处理器上完成所有的任务。这个问题是 NP- 困难的（请见第 6 章），因此我们实际上不可能算出一种最优的方案。但一种较优调度方法是**最大优先**。我们将任务按照耗时降序排列，将每个任务依次分配给当前可用的处理器。要实现这种算法，我们先要逆序排列这些任务，然后为 ![M](https://private.codecogs.com/gif.latex?M) 个处理器维护一个优先队列，每个元素的优先级就是对应的处理器上运行的任务的耗时之和。每一步中，我们都删去优先级最低的那个处理器，将下一个任务分配给这个处理器，然后再将它重新插入优先队列。

####2.5.4.4　事件驱动模拟

很多科学上的应用都涉及模拟，用大量计算来将现实世界的某个方面建模以期能够更好地理解它。在计算机发明之前，科学家们除了构建数学模型之外别无选择，而现在计算机模型很好地补充了这些数学模型。逼真地模拟现实世界是很有挑战的，而使用正确的算法使得我们能够在有限的时间内完成这些模拟，而不是无奈地接受不精确的实验结果或是无尽地等待计算的完成。我们会在第 6 章中展示能够说明这一点的一个具体例子。

####2.5.4.5　数值计算

在科学计算中，精确度非常重要（我们距离真正的答案有多远），特别是当我们在计算机中使用的只是真正的实数的近似值——浮点数来进行上百万次计算的时候。一些数值计算算法使用优先队列和排序来控制计算中的精确度。例如，在求曲线下区域的面积时，数值积分的一个方法就是使用一个优先队列存储一组小间隔中每段的近似精确度。积分的过程就是删去精确度最低的间隔并将其分为两半（这样两半都能变得更加精确），然后将两半都重新加入优先队列。如此这般，直到达到预期的精确程度。

####2.5.4.6　组合搜索

人工智能领域一个解决“疑难杂症”的经典范式就是定义一组**状态**、由一组状态演化到另一组状态可能的**步骤**以及每个步骤的优先级，然后定义一个**起始**状态和**目标**状态（也就是问题的解决办法）。著名的 A\* **算法**的解决办法就是将起始状态放入优先队列中，然后重复下面的方法直到到达目的地：删去优先级最高的状态，然后将能够从该状态在一步之内达到的所有状态全部加入优先队列（除了刚刚删去的那个状态之外）。和事件驱动模拟一样，这个过程简直就是为优先队列量身定做的。它将问题的解决转化为了定义一个适当的优先级函数问题。例子请见练习 2.5.32。

除了这些直接应用之外（我们只说了很小的一部分而已），排序和优先队列在算法设计领域也是很重要的抽象概念，因此本书会经常用到它们。下面我们举了一些本书后续内容中的应用作为例子，它们都依赖于本章中的排序算法和优先队列数据类型的高效实现。

* **Prim 算法和 Dijkstra 算法**

	它们都是第 4 章中的经典算法。第 4 章的主题是**图**的处理算法，图是由**结点**和连接两个结点的**边**组成的一种重要的基础模型。图算法的基石就是**图的搜索**，也就是一个结点一个结点地查找，优先队列在其中扮演了重要的角色。

* **Kruskal 算法**

	这是图中的加权图的另一个经典算法，其中边的处理顺序取决于它的权重。算法的运行时间是由排序所需的时间决定的。

* **霍夫曼压缩**

	这是一个经典的**数据压缩**算法。它处理的数据中的每个元素都有一个小整数作为权重，而处理的过程就是将权重最小的两个元素归并成一个新元素，并将其权重相加得到新元素的权重。使用优先队列可以立即实现这个算法。其他几种数据压缩算法也是基于排序的。

* **字符串处理**

	字符串处理算法在现代密码学和基因组学中起着关键性的作用。它们也常常依赖于排序算法（一般都会使用第 5 章中所讨论的特殊的字符串排序算法）。例如，在第 6 章中我们在学习找出给定字符串中的**最长重复子字符串**算法时会先将字符串的后缀排序。

###答疑

**问**　Java 的系统库中有优先队列这种数据类型吗？

**答**　有，请见 `java.util.PriorityQueue`。

###练习

**2.5.1**　在下面这段 `String` 类型的 `compareTo()` 方法的实现中，第三行对提高运行效率有何帮助？

```
public int compareTo(String that)
{
   if (this == that) return 0;  // 这一行
   int n = Math.min(this.length(), that.length());
   for (int i = 0; i < n; i++)

   {
      if      (this.charAt(i) < that.charAt(i)) return -1;

      else if (this.charAt(i) > that.charAt(i)) return +1;
   }
   return this.length() - that.length();
}
```

**2.5.2**　编写一段程序，从标准输入读入一列单词并打印出其中所有由两个单词组成的组合词。例如，如果输入的单词为 after、thought 和 afterthought，那么 afterthought 就是一个组合词。

**2.5.3**　找出下面这段账户余额 `Balance` 类的实现代码的错误。为什么 `compareTo()` 方法对 `Comparable` 接口的实现有缺陷？

```
public class Balance implements Comparable<Balance>
{
   ...
   private double amount;
   public int compareTo(Balance that)
   {
      if (this.amount < that.amount - 0.005) return -1;
      if (this.amount > that.amount + 0.005) return +1;
      return 0;
   }
   ...
}
```

　　　说明如何修正这个问题。

**2.5.4**　实现一个方法 `String[] dedup(String[] a)`，返回一个有序的 `a[]`，并删去其中的重复元素。

**2.5.5**　说明为何选择排序是不稳定的。

**2.5.6**　用递归实现 `select()`。

**2.5.7**　用 `select()` 找出 ![N](https://private.codecogs.com/gif.latex?N) 个元素中的最小值平均大约需要多少次比较？

**2.5.8**　编写一段程序 Frequency，从标准输入读取一列字符串并按照字符串出现频率由高到低的顺序打印出每个字符串及其出现次数。

**2.5.9**　为将右侧所示的数据排序编写一个新的数据类型。

```
输入DJIA每天的成交量

  1-Oct-28 3500000
  2-Oct-28 3850000
  3-Oct-28 4060000
  4-Oct-28 4330000
  5-Oct-28 4360000
 ...
 30-Dec-99 554680000
 31-Dec-99 374049984
  3-Jan-00 931800000
  4-Jan-00 1009000000
  5-Jan-00 1085500032
  ...

输出

 19-Aug-40 130000
 26-Aug-40 160000
 24-Jul-40 200000
 10-Aug-42 210000
 23-Jun-42 210000
 ...
 23-Jul-02 2441019904
 17-Jul-02 2566500096
 15-Jul-02 2574799872
 19-Jul-02 2654099968
 24-Jul-02 2775559936
```

**2.5.10**　创建一个数据类型 `Version` 来表示软件的版本，例如 115.1.1、115.10.1、115.10.2。为它实现 `Comparable` 接口，其中 115.1.1 的版本低于 115.10.1。

**2.5.11**　描述排序结果的一种方法是创建一个保存 `0` 到 `a.length-1` 的排列 `p[]`，使得 `p[i]` 的值为 `a[i]` 元素的最终位置。用这种方法描述插入排序、选择排序、希尔排序、归并排序、快速排序和堆排序对一个含有 7 个相同元素的数组的排序结果。

###提高题

**2.5.12**　**调度**。编写一段程序 SPT.java，从标准输入中读取任务的名称和所需的运行时间，用 2.5.4.3 节所述的最短处理时间优先的原则打印出一份调度计划，使得任务完成的平均时间最小。

**2.5.13**　**负载均衡**。编写一段程序 LPT.java，接受一个整数 `M` 作为命令行参数，从标准输入中读取任务的名称和所需的运行时间，用 2.5.4.3 节所述的最长处理时间优先原则打印出一份调度计划，将所有任务分配给 `M` 个处理器并使得所有任务完成所需的总时间最少。

**2.5.14**　**逆域名排序**。为域名编写一个数据类型 `Domain` 并为它实现一个 `compareTo()` 方法，使之能够按照**逆向**的域名排序。例如，域名 cs.princeton.edu 的逆是 edu.princeton.cs。这在网络日志处理时很有用。**提示**：使用 `s.split("\\.")` 将域名用点分为若干部分。编写一个 `Domain` 的用例，从标准输入读取域名并将它们按照逆域名有序地打印出来。

**2.5.15**　**垃圾邮件大战**。在非法垃圾邮件之战的伊始，你有一大串来自各个域名（也就是电子邮件地址中 @ 符号后面的部分）的电子邮件地址。为了更好地伪造回信地址，你应该总是从相同的域中向目标用户发送邮件。例如，从 wayne@cs.princeton.edu 向 rs@cs.princeton.edu 发送垃圾邮件就很不错。你会如何处理这份电子邮件列表来高效地完成这个任务呢？

**2.5.16**　**公正的选举**。为了避免对名字排在字母表靠后的候选人的偏见，加州在 2003 年的州长选举中将所有候选人按照以下字母顺序排列：

```
R W Q O J M V A H B S G Z X N T C I E K U P D Y F L
```

　　　创建一个遵守这种顺序的数据类型并编写一个用例 California，在它的静态方法 `main()` 中将字符串按照这种方式排序。假设所有字符串全部都是大写的。

**2.5.17**　**检测稳定性**。扩展练习 2.1.16 中的 `check()` 方法，对指定数组调用 `sort()`，如果排序结果是稳定的则返回 `true`，否则返回 `false`。不要假设 `sort()` 只会使用 `exch()` 移动数据。

**2.5.18**　**强制稳定**。编写一段能够将任意排序方法变得稳定的封装代码，创建一种新的数据类型作为键，将键的原始索引保存在其中，并在调用 `sort()` 之后再恢复原始的键。

**2.5.19**　**Kendall tau 距离**。编写一段程序 KendallTau.java，在线性对数时间内计算两组排列之间的 Kendall tau 距离。

**2.5.20**　**空闲时间**。假设有一台计算机能够并行处理 ![N](https://private.codecogs.com/gif.latex?N) 个任务。编写一段程序并给定一系列任务的起始时间和结束时间，找出这台机器最长的空闲时间和最长的繁忙时间。

**2.5.21**　**多维排序**。编写一个 `Vector` 数据类型并将 ![d](https://private.codecogs.com/gif.latex?d) 维整型向量排序。排序方法是先按照一维数字排序，一维数字相同的向量则按照二维数字排序，再相同的向量则按照三维数字排序，如此这般。

**2.5.22**　**股票交易**。投资者对一只股票的买卖交易都发布在电子交易市场中。他们会指定最高买入价和最低卖出价，以及在该价位买卖的笔数。编写一段程序，用优先队列来匹配买家和卖家并用模拟数据进行测试。可以使用两个优先队列，一个用于买家一个用于卖家，当一方的报价能够和另一方的一份或多份报价匹配时就进行交易。

**2.5.23**　选择的取样：实验使用取样来改进 `select()` 函数的想法。**提示**：使用中位数可能并不总是有效。

**2.5.24**　**稳定的优先队列**。实现一个**稳定**的优先队列（将重复的元素按照它们被插入的顺序返回）

**2.5.25**　**平面上的点**。为表 1.2.3 的 `Point2D` 类型编写三个静态的比较器，一个按照 ![x](https://private.codecogs.com/gif.latex?x) 坐标比较，一个按照 ![y](https://private.codecogs.com/gif.latex?y) 坐标比较，一个按照点到原点的距离进行比较。编写两个非静态的比较器，一个按照两点到第三点的距离比较，一个按照两点相对于第三点的幅角比较。

**2.5.26**　**简单多边形**。给定平面上的 ![N](https://private.codecogs.com/gif.latex?N) 个点，用它们画出一个多边形。**提示**：找到 ![y](https://private.codecogs.com/gif.latex?y) 坐标最小的点 ![p](https://private.codecogs.com/gif.latex?p)，在有多个最小 ![y](https://private.codecogs.com/gif.latex?y) 坐标的点时取 ![x](https://private.codecogs.com/gif.latex?x) 坐标最小者，然后将其他点按照以 ![p](https://private.codecogs.com/gif.latex?p) 为原点的幅角大小的顺序依次连接起来。

**2.5.27**　**平行数组的排序**。在将平行数组排序时，可以将索引排序并返回一个 `index[]` 数组。为 `Insertion` 添加一个 `indirectSort()` 方法，接受一个 `Comparable` 的对象数组 `a[]` 作为参数，但它不会将 `a[]` 中的元素重新排列，而是返回一个整形数组 `index[]` 使得 `a[index[0]]` 到 `a[index[N-1]]` 正好是升序的。

**2.5.28**　**按文件名排序**。编写一个 FileSorter 程序，从命令行接受一个目录名并打印出按照文件名排序后的所有文件。提示：使用 `File` 数据类型。

**2.5.29**　**按大小和最后修改日期将文件排序**。为 `File` 数据类型编写比较器，使之能够将文件按照大小、文件名或最后修改日期将文件升序或者降序排列。在程序 LS 中使用这些比较器，它接受一个命令行参数并根据指定的顺序列出目录的内容。例如，`"-t"` 指按照时间戳排序。支持多个选项以消除排序位次相同者，同时必须确保排序的稳定性。

**2.5.30**　**Boerner 定理**。真假判断：如果你先将一个矩阵的每一列排序，再将矩阵的每一行排序，所有的列仍然是有序的。证明你的结论。

###实验题

**2.5.31**　**重复元素**。编写一段程序，接受命令行参数 `M`、`N` 和 `T`，然后使用正文中的代码进行 `T` 遍实验：生成 ![N](https://private.codecogs.com/gif.latex?N) 个 0 到 ![M-1](https://private.codecogs.com/gif.latex?M-1) 间的 `int` 值并计算重复值的个数。令 ![T=10](https://private.codecogs.com/gif.latex?T=10)，![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6) 以及 ![M=N/2](https://private.codecogs.com/gif.latex?M=N/2)、![N](https://private.codecogs.com/gif.latex?N) 和 ![2N](https://private.codecogs.com/gif.latex?2N)。根据概率论，重复值的个数应该约为 ![(1-{\rm e}^{-\alpha})](https://private.codecogs.com/gif.latex?(1-{\rm%20e}^{-\alpha}%29)，其中 ![\alpha=N/M](https://private.codecogs.com/gif.latex?\alpha=N/M)。打印一张表格来确认你的实验验证了这个公式。

**2.5.32**　**8 字谜题**。8 字谜题是 S. Loyd 于 19 世纪 70 年代发明的一个游戏。游戏需要一个三乘三的九宫格，其中八格中填上了 1 到 8 这 8 个数字，一格空着。你的目标就是将所有的格子排序。可以将一个格子向上下或者左右移动（但不能是对角线方向）到空白的格子中。编写一个程序用 A\* 算法解决这个问题。**先用到达九宫格的当前位置所需的步数加上错位的格子数量作为优先级函数（注意，步数至少大于等于错位的格子数）**。尝试用其他函数代替错位的格子数量，比如每个格子距离它的正确位置的曼哈顿距离，或是这些距离的平方之和。

**2.5.33**　**随机交易**。开发一个接受参数 ![N](https://private.codecogs.com/gif.latex?N) 的生成器，根据你能想到的任意假设条件生成 ![N](https://private.codecogs.com/gif.latex?N) 个随机的 `Transaction` 对象（请见练习 2.1.21 和练习 2.1.22）。对于 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)，比较用希尔排序、归并排序、快速排序和堆排序将 ![N](https://private.codecogs.com/gif.latex?N) 个交易排序的性能。