#第 4 章　图

在许多计算机应用中，由相连的结点所表示的模型起到了关键的作用。这些结点之间的连接很自然地会让人们产生一连串的疑问：沿着这些连接能否从一个结点到达另一个结点？有多少个结点和指定的结点相连？两个结点之间最短的连接是哪一条？

要描述这些问题，我们要使用一种抽象的数学对象，叫做**图**。本章中，我们会详细研究图的基本性质，为学习各种算法并回答这种类型的疑问作好准备。这些算法是解决许多重要的实际问题的基础，没有优秀的算法，这些问题的解决无法想象。

图论作为数学领域中的一个重要分支已经有数百年的历史了。人们发现了图的许多重要而实用的性质，发明了许多重要的算法，其中许多困难问题的研究仍然十分活跃。本章中，我们会介绍一系列基础的图算法，它们在各种应用中都十分重要。

和我们已经研究过的许多其他问题域一样，关于图的算法研究相对来说才开始不久。尽管有些基础的算法在几个世纪前就已发现了，但大多数有趣的结论都是近几十年才被发现。得益于我们已经学习过的那些算法，即使是由最简单的图论算法得到的程序也是很有用的，而那些我们将要学习的复杂算法则都是已知的最优美和最有意思的算法的一部分。

为了展示图论应用的广泛领域，在探索这片富饶之地之前，我们先来看以下几个示例。

**地图**。正在计划旅行的人也许想知道“从普罗维登斯到普林斯顿的最短路线”。对最短路径上经历过交通堵塞的旅行者可能会问：“从普罗维登斯到普林斯顿的哪条路线最快？”要回答这些问题，我们都要处理有关结点（十字路口）之间多条连接（公路）的信息。

**网页信息**。当我们在浏览网页时，页面上都会包含其他网页的引用（链接）。通过单击链接，我们可以从一个页面跳到另一个页面。整个互联网就是一张图，结点是网页，连接就是超链接。图算法是帮助我们在网络上定位信息的搜索引擎的关键组件。

**电路**。在一块电路板上，晶体管、电阻、电容等各种元件是精密连接在一起的。我们使用计算机来控制制造电路板的机器并检查电路板的功能是否正常。我们既要检查短路这类简单问题，也要检查这幅电路图中的导线在蚀刻到芯片上时是否会出现交叉等复杂问题。第一类问题的答案仅取决于连接（导线）的属性，而第二个问题则会涉及导线、各种元件以及芯片的物理特性等详细信息。

**任务调度**。商品的生产过程包含了许多工序以及一些限制条件，这些条件会决定某些任务的先后次序。如何安排才能在满足限制条件的情况下用最少的时间完成这些生产工序呢？

**商业交易**。零售商和金融机构都会跟踪市场中的买卖信息。在这种情形下，一条连接可以表示现金和商品在买方和卖方之间的转移。在此情况下，理解图的连接结构原理可能有助于增强人们对市场的理解。

**配对**。学生可以申请加入各种机构，例如社交俱乐部、大学或是医学院等。这里结点就对应学生和机构，而连接则对应递交的申请。我们希望找到申请者与他们感兴趣的空位之间配对的方法。

**计算机网络**。计算机网络是由能够发送、转发和接收各种消息的站点互相连接组成的。我们感兴趣的是这种互联结构的性质，因为我们希望网络中的线路和交换设备能够高效率地处理网络流量。

**软件**。编译器会使用图来表示大型软件系统中各个模块之间的关系。图中的结点即构成整个系统的各种类和模块，连接则为类的方法之间的可能调用关系（静态分析），或是系统运行时的实际调用关系（动态分析）。我们需要分析这幅图来决定如何以最优的方式为程序分配资源。

**社交网络**。当你在使用社交网站时，会和你的朋友之间建立起明确的关系。这里，结点对应人而连接则联系着你和你的朋友或是关注者。分析这些社交网络的性质是当前图算法的一个重要应用。对它感兴趣的不止是社交网络的公司，还包括政治、外交、娱乐、教育、市场等许多其他机构（参见表 4.0.1）。

**表 4.0.1　图的典型应用**

|应用|结点|连接|
|-|-|-|
|地图|十字路口|公路|
|网络内容|网页|超链接|
|电路|元器件|导线|
|任务调度|任务|限制条件|
|商业交易|客户|交易|
|配对|学生|申请|
|计算机网络|网站|物理连接|
|软件|方法|调用关系|
|社交网络|人|友谊关系|

这些示例展示了图作为一种抽象模型的应用范围以及我们在处理图时可能会遇到的各种计算问题。人们研究过的关于图的问题数以千计，但它们大多数都能用一些简单的图模型解决——本章我们将会学习几个最重要的模型。在实际应用中，处理庞大的数据是很常见的，因此解决方法是否可行完全取决于算法的效率。

在本章中，我们会依次学习 4 种最重要的图模型：**无向图**（简单连接）、**有向图**（连接有方向性）、**加权图**（连接带有权值）和**加权有向图**（连接既有方向性又带有权值）。

##4.1　无向图

在我们首先要学习的这种图模型中，**边**（edge）仅仅是两个**顶点**（vertex）之间的连接。为了和其他图模型相区别，我们将它称为**无向图**。这是一种最简单的图模型，我们先来看一下它的定义。

>**定义**。图是由一组顶点和一组能够将两个顶点相连的边组成的。

就定义而言，顶点叫什么名字并不重要，但我们需要一个方法来指代这些顶点。一般使用 0 至 ![V-1](https://private.codecogs.com/gif.latex?V-1) 来表示一张含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点的图中的各个顶点。这样约定是为了方便使用数组的索引来编写能够高效访问各个顶点中信息的代码。用一张符号表来为顶点的名字和 0 到 ![V-1](https://private.codecogs.com/gif.latex?V-1) 的整数值建立一一对应的关系并不困难（请见 4.1.7 节），因此直接使用数组索引作为结点的名称更方便且不失一般性（也不会损失什么效率）。我们用 `v-w` 的记法来表示连接 `v` 和 `w` 的边，`w-v` 是这条边的另一种表示方法。

在绘制一幅图时，用圆圈表示顶点，用连接两个顶点的线段表示边，这样就能直观地看出图的结构。但这种直觉有时也可能会误导我们，因为图的定义和绘出的图像是无关的。例如，图 4.1.1 中的两组图表示的是同一幅图，因为图的构成只有（无序的）顶点和边（顶点对）。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.001.png)

**图 4.1.1　同一幅图的两种表示**

**特殊的图**。我们的定义允许出现两种简单而特殊的情况，参见图 4.1.2：

* **自环**，即一条连接一个顶点和其自身的边；
* 连接同一对顶点的两条边称为**平行边**。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.002.png)

**图 4.1.2　特殊的图**

数学家常常将含有平行边的图称为**多重图**，而将没有平行边或自环的图称为**简单图**。一般来说，实现允许出现自环和平行边（因为它们会在实际应用中出现），但我们不会将它们作为示例。因此，我们用两个顶点就可以指代一条边了。

###4.1.1　术语表

和图有关的术语非常多，其中大多数定义都很简单，我们在这里集中介绍。

当两个顶点通过一条边相连时，我们称这两个顶点是**相邻的**，并称这条边**依附于**这两个顶点。某个顶点的**度数**即为依附于它的边的总数。**子图**是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。许多计算问题都需要识别各种类型的子图，特别是由能够**顺序**连接一系列顶点的边所组成的子图。

>**定义**。在图中，**路径**是由边顺序连接的一系列顶点。**简单路径**是一条没有重复顶点的路径。**环**是一条至少含有一条边且起点和终点相同的路径。**简单环**是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或者环的**长度**为其中所包含的边数。

大多数情况下，我们研究的都是简单环和简单路径并会省略掉**简单**二字。当允许重复的顶点时，我们指的都是**一般的**路径和环。当两个顶点之间存在一条连接双方的路径时，我们称一个顶点和另一个顶点是**连通**的。我们用类似 `u-v-w-x` 的记法来表示 `u` 到 `x` 的一条路径，用 `u-v-w-x-u` 表示从 `u` 到 `v` 到 `w` 到 `x` 再回到 `u` 的一条环。我们会学习几种查找路径和环的算法。另外，路径和环也会帮我们从整体上考虑一幅图的性质，参见图 4.1.3。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.003.png)

**图 4.1.3　图的详解**

>**定义**。如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这幅图是**连通图**。一幅**非连通的图**由若干连通的部分组成，它们都是其极大连通子图。

直观上来说，如果顶点是物理存在的对象，例如绳节或是念珠，而边也是物理存在的对象，例如绳子或是电线，那么将任意顶点提起，连通图都将是一个整体，而非连通图则会变成两个或多个部分。一般来说，要处理一张图就需要一个个地处理它的连通分量（子图）。

**无环图**是一种不包含环的图。我们将要学习的几个算法就是要找出一幅图中满足一定条件的无环子图。我们还需要一些术语来表示这些结构。

>**定义**。**树**是一幅无环连通图。互不相连的树组成的集合称为**森林**。连通图的**生成树**是它的一幅子图，它含有图中的所有顶点且是一棵树。图的**生成树森林**是它的所有连通子图的生成树的集合，参见图 4.1.4 和图 4.1.5。

![{40%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.004.png)

**图 4.1.4　一棵树**

![{35%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.005.png)

**图 4.1.5　生成树森林**

树的定义非常通用，稍做改动就可以变成用来描述程序行为的（函数调用层次）模型和数据结构（二叉查找树、2-3 树等）。树的数学性质很直观并且已被系统地研究过，因此我们就不给出它们的证明了。例如，当且仅当一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个结点的图 ![G](https://private.codecogs.com/gif.latex?G) 满足下列 5 个条件之一时，它就是一棵树：

* ![G](https://private.codecogs.com/gif.latex?G) 有 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边且不含有环；
* ![G](https://private.codecogs.com/gif.latex?G) 有 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边且是连通的；
* ![G](https://private.codecogs.com/gif.latex?G) 是连通的，但删除任意一条边都会使它不再连通；
* ![G](https://private.codecogs.com/gif.latex?G) 是无环图，但添加任意一条边都会产生一条环；
* ![G](https://private.codecogs.com/gif.latex?G) 中的任意一对顶点之间仅存在一条简单路径。

我们会学习几种寻找生成树和森林的算法，以上这些性质在分析和实现这些算法的过程中扮演着重要的角色。

图的**密度**是指已经连接的顶点对占所有可能被连接的顶点对的比例。在**稀疏**图中，被连接的顶点对很少；而在**稠密**图中，只有少部分顶点对之间没有边连接。一般来说，如果一幅图中不同的边的数量在顶点总数 ![V](https://private.codecogs.com/gif.latex?V) 的一个小的常数倍以内，那么我们就认为这幅图是稀疏的，否则则是稠密的，参见图 4.1.6。这条经验规律虽然会留下一片灰色地带（比如当边的数量为 ![\sim cV^{3/2}](https://private.codecogs.com/gif.latex?\sim%20cV^{3/2}) 时），但实际应用中稀疏图和稠密图之间的区别是十分明显的。我们将会遇到的应用使用的几乎都是稀疏图。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.006.png)

**图 4.1.6　两幅图 (![V=50](https://private.codecogs.com/gif.latex?V=50))**

**二分图**是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。图 4.1.7 即为一幅二分图的示例，其中红色的结点是一个集合，黑色的结点是另一个集合。二分图会出现在许多场景中，我们会在本节的最后详细研究其中的一个场景。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.007.png)

**图 4.1.7　二分图**

现在，我们已经做好了学习图处理算法的准备。我们首先会研究一种表示图的数据类型的 API 及其实现，然后会学习一些查找图和鉴别连通分量的经典算法。最后，我们会考虑真实世界中的一些图的应用，它们的顶点的名字可能不是整数并且会含有数目庞大的顶点和边。

###4.1.2　表示无向图的数据类型

要开发处理图问题的各种算法，我们首先来看一份定义了图的基本操作的 API，参见表 4.1.1。有了它我们才能完成从简单的基本操作到解决复杂问题的各种任务。

**表 4.1.1　无向图的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>Graph</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graph(int V)</code></td><td>创建一个含有 <img src="https://private.codecogs.com/gif.latex?V" /> 个顶点但不含有边的图</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graph(In in)</code></td><td>从标准输入流 <code>in</code> 读入一幅图</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;V()</code></td><td>顶点数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;E()</code></td><td>边数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;addEdge(int v, int w)</code></td><td>向图中添加一条边 <code>v-w</code></td></tr>
<tr><td><code>Iterable&lt;Integer>&nbsp;&nbsp;adj(int v)</code></td><td>和 <code>v</code> 相邻的所有顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>
</table>

这份 API 含有两个构造函数，有两个方法用来分别返回图中的顶点数和边数，有一个方法用来添加一条边，`toString()` 方法和 `adj()` 方法用来允许用例遍历给定顶点的所有相邻顶点（遍历顺序不确定）。值得注意的是，本节将学习的所有算法都基于 `adj()` 方法所抽象的基本操作。

第二个构造函数接受的输入由 ![2E+2](https://private.codecogs.com/gif.latex?2E+2) 个整数组成：首先是 ![V](https://private.codecogs.com/gif.latex?V)，然后是 ![E](https://private.codecogs.com/gif.latex?E)，再然后是 ![E](https://private.codecogs.com/gif.latex?E) 对 0 到 ![V-1](https://private.codecogs.com/gif.latex?V-1) 之间的整数，每个整数对都表示一条边。例如，我们使用了由图 4.1.8 中的 tinyG.txt 和 mediumG.txt 所描述的两个示例。

![{93%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.008.png)

**图 4.1.8　`Graph` 的构造函数的输入格式（两个示例）**

调用 `Graph` 的几段用例代码请见表 4.1.2。

**表 4.1.2　最常用的图处理代码**

|任务|实现|
|-|-|
|计算 `v` 的度数|<pre>public static int degree(Graph G, int v)<br>{<br>   int degree = 0;<br>   for (int w : G.adj(v)) degree++;<br>   return degree;<br>}</pre>|
|计算所有顶点的最大度数|<pre>public static int maxDegree(Graph G)<br>{<br>   int max = 0;<br>   for (int v = 0; v &lt; G.V(); v++)<br>      if (degree(G, v) > max)<br>         max = degree(G, v);<br>   return max;<br>}</pre>|
|计算所有顶点的平均度数|<pre>public static double avgDegree(Graph G)<br>{ return 2.0 * G.E() / G.V(); }</pre>|
|计算自环的个数|<pre>public static int numberOfSelfLoops(Graph G)<br>{<br>   int count = 0;<br>   for (int v = 0; v &lt; G.V(); v++)<br>      for (int w : G.adj(v))<br>         if (v == w) count++;<br>   return count/2; //每条边都被记过两次<br>}</pre>|
|图的邻接表的字符串表示（`Graph` 的实例方法）|<pre>public String toString()<br>{<br>   String s = V + " vertices, " + E + " edges\n";<br>   for (int v = 0; v &lt; V; v++)<br>   {<br>      s += v + ": ";<br>      for (int w : this.adj(v))<br>         s += w + " ";<br>      s += "\n";<br>   }<br>   return s;<br>}</pre>|

####4.1.2.1　图的几种表示方法

我们要面对的下一个图处理问题就是用哪种方式（数据结构）来表示图并实现这份 API，这包含以下两个要求：

* 它必须为可能在应用中碰到的各种类型的图预留出足够的**空间**；
* `Graph` 的实例方法的实现一定要快——它们是开发处理图的各种用例的基础。

这些要求比较模糊，但它们仍然能够帮助我们在三种图的表示方法中进行选择。

* **邻接矩阵**。我们可以使用一个 ![V](https://private.codecogs.com/gif.latex?V) 乘 ![V](https://private.codecogs.com/gif.latex?V) 的布尔矩阵。当顶点 `v` 和顶点 `w` 之间有相连接的边时，定义 `v` 行 `w` 列的元素值为 `true`，否则为 `false`。这种表示方法不符合第一个条件——含有上百万个顶点的图是很常见的，![V^2](https://private.codecogs.com/gif.latex?V^2) 个布尔值所需的空间是不能满足的。
* **边的数组**。我们可以使用一个 `Edge` 类，它含有两个 `int` 实例变量。这种表示方法很简洁但不满足第二个条件——要实现 `adj()` 需要检查图中的所有边。
* **邻接表数组**。我们可以使用一个以顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表，参见图 4.1.9。这种数据结构能够同时满足典型应用所需的以上两个条件，我们会在本章中一直使用它。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.009.png)

**图 4.1.9　邻接表数组示意（无向图）**

除了这些性能目标之外，经过缜密的检查，我们还发现了另一些在某些应用中可能会很重要的东西。例如，允许存在平行边相当于排除了邻接矩阵，因为邻接矩阵无法表示它们。

####4.1.2.2　邻接表的数据结构

非稠密图的标准表示称为**邻接表**的数据结构，它将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。我们使用这个数组就是为了快速访问给定顶点的邻接顶点列表。这里使用 1.3 节中的 `Bag` 抽象数据类型来实现这个链表，这样我们就可以在常数时间内添加新的边或遍历任意顶点的所有相邻顶点。后面框注“`Graph` 数据类型”中的 `Graph` 类的实现就是基于这种方法，而图 4.1.9 中所示的正是用这种方法处理 tinyG.txt 所得到的数据结构。要添加一条连接 `v` 与 `w` 的边，我们将 `w` 添加到 `v` 的邻接表中并把 `v` 添加到 `w` 的邻接表中。因此，在这个数据结构中每条边都会出现**两次**。这种 `Graph` 的实现的性能有如下特点：

* 使用的空间和 ![V+E](https://private.codecogs.com/gif.latex?V+E) 成正比；
* 添加一条边所需的时间为常数；
* 遍历顶点 `v` 的所有相邻顶点所需的时间和 `v` 的度数成正比（处理每个相邻顶点所需的时间为常数）。

对于这些操作，这样的特性已经是最优的了，这已经可以满足图处理应用的需要，而且支持平行边和自环（我们不会检测它们）。注意，边的插入顺序决定了 `Graph` 的邻接表中顶点的出现顺序，参见图 4.1.10。多个不同的邻接表可能表示着同一幅图。当使用构造函数从标准输入中读入一幅图时，这就意味着输入的格式和边的顺序决定了 `Graph` 的邻接表数组中顶点的出现顺序。因为算法在使用 `adj()` 来处理所有相邻的顶点时不会考虑它们在邻接表中的出现顺序，这种差异不会影响算法的正确性，但在调试或是跟踪邻接表的轨迹时我们还是需要注意这一点。为了简化操作，假设 `Graph` 有一个测试用例来从命令行参数指定的文件中读取一幅图并将它打印出来（参见表 4.1.2 中的 `toString()` 方法的实现），以显示邻接表中的各个顶点的出现顺序，这也是算法处理它们的顺序（请见练习 4.1.7）。

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.010.png)

**图 4.1.10　由边得到的邻接表**

>**`Graph` 数据类型**

>```
>public class Graph
>{
>    private final int V;          // 顶点数目
>    private int E;                // 边的数目
>    private Bag<Integer>[] adj;   // 邻接表
>    public Graph(int V)
>    {
>       this.V = V; this.E = 0;
>       adj = (Bag<Integer>[]) new Bag[V];      // 创建邻接表
>       for (int v = 0; v < V; v++)             // 将所有链表初始化为空
>          adj[v] = new Bag<Integer>();
>    }
>    public Graph(In in)
>    {
>       this(in.readInt());          // 读取V并将图初始化
>       int E = in.readInt();        // 读取E
>       for (int i = 0; i < E; i++)
>       {  // 添加一条边
>          int v = in.readInt();        // 读取一个顶点
>          int w = in.readInt();        // 读取另一个顶点
>          addEdge(v, w);               // 添加一条连接它们的边
>       }
>    }
>    public int V()  {  return V;  }
>    public int E()  {  return E;  }
>    public void addEdge(int v, int w)
>    {
>       adj[v].add(w);                            // 将w添加到v的链表中
>       adj[w].add(v);                            // 将v添加到w的链表中
>       E++;
>     }
>    public Iterable<Integer> adj(int v)
>    {  return adj[v];  }
>}
>```

>这份 `Graph` 的实现使用了一个由顶点索引的整型链表数组。每条边都会出现两次，即当存在一条连接 `v` 与 `w` 的边时，`w` 会出现在 `v` 的链表中，`v` 也会出现在 `w` 的链表中。第二个构造函数从输入流中读取一幅图，开头是 ![V](https://private.codecogs.com/gif.latex?V)，然后是 ![E](https://private.codecogs.com/gif.latex?E)，再然后是一列整数对，大小在 0 到 ![V-1](https://private.codecogs.com/gif.latex?V-1) 之间。`toString()` 方法请见表 4.1.2。

在实际应用中还有一些操作可能是很有用的，例如：

* 添加一个顶点；
* 删除一个顶点。

实现这些操作的一种方法是扩展之前的 API，使用符号表（`ST`）来代替由顶点索引构成的数组（这样修改之后就不需要约定顶点名必须是整数了）。我们可能还需要：

* 删除一条边；
* 检查图是否含有边 `v-w`。

要实现这些方法（不允许存在平行边），我们可能需要使用 `SET` 代替 `Bag` 来实现邻接表。我们称这种方法为**邻接集**。本书中不会使用这些数据结构，因为：

* 用例代码不需要添加顶点、删除顶点和边或是检查一条边是否存在；
* 当用例代码需要进行上述操作时，由于频率很低或者相关的邻接链表很短，因此可以直接使用穷举法遍历链表来实现；
* 使用 `SET` 和 `ST` 会令算法的实现变得更加复杂，分散了读者对算法本身的注意力；
* 在某些情况下，它们会使性能损失 ![\log V](https://private.codecogs.com/gif.latex?\log%20V)。

使我们的算法适应其他设计（例如，不允许出现平行边或是自环）并避免不必要的性能损失并不困难。表 4.1.3 总结了之前提到过的所有其他实现方法的性能特点。常见的应用场景都需要处理庞大的稀疏图，因此我们会一直使用邻接表。

**表 4.1.3　典型 `Graph` 实现的性能复杂度**

|数据结构|所需空间|添加一条边 `v-w`|检查 `w` 和 `v` 是否相邻|遍历 `v` 的所有相邻顶点|
|-|-|-|-|-|
|边的列表|<img src="https://private.codecogs.com/gif.latex?E" />|1|<img src="https://private.codecogs.com/gif.latex?E" />|<img src="https://private.codecogs.com/gif.latex?E" />|
|邻接矩阵|<img src="https://private.codecogs.com/gif.latex?V^2" />|1|1|`V`|
|邻接表|<img src="https://private.codecogs.com/gif.latex?E+V" />|1|<img src="https://private.codecogs.com/gif.latex?degree" />(`v`)|<img src="https://private.codecogs.com/gif.latex?degree" />(`v`)|
|邻接集|<img src="https://private.codecogs.com/gif.latex?E+V" />|<img src="https://private.codecogs.com/gif.latex?\log%20V" />|<img src="https://private.codecogs.com/gif.latex?\log%20V" />|<img src="https://private.codecogs.com/gif.latex?\log%20V+degree" />(`v`)|

####4.1.2.3　图的处理算法的设计模式

因为我们会讨论大量关于图处理的算法，所以设计的首要目标是将图的表示和实现分离开来。为此，我们会为每个任务创建一个相应的类，用例可以创建相应的对象来完成任务。类的构造函数一般会在预处理中构造各种数据结构，以有效地响应用例的请求。典型的用例程序会构造一幅图，将图传递给实现了某个算法的类（作为构造函数的参数），然后调用用例的方法来获取图的各种性质。作为热身，我们先来看看这份 API，参见表 4.1.4。

**表 4.1.4　图处理算法的 API（热身）**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>Search</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Search(Graph G, int s)</code></td><td>找到和起点 <code>s</code> 连通的所有顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;marked(int v)</code></td><td><code>v</code> 和 <code>s</code> 是连通的吗</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;count()</code></td><td>与 <code>s</code> 连通的顶点总数</td></tr>
</table>

我们用**起点**（source）区分作为参数传递给构造函数的顶点与图中的其他顶点。在这份 API 中，构造函数的任务是找到图中与起点连通的其他顶点。用例可以调用 `marked()` 方法和 `count()` 方法来了解图的性质。方法名 `marked()` 指的是这种基本算法使用的一种实现方式，本章中会一直使用到这种算法：在图中从起点开始沿着路径到达其他顶点并标记每个路过的顶点。后面框注中的图处理用例 `TestSearch` 接受由命令行得到的一个输入流的名称和起始结点的编号，从输入流中读取一幅图（使用 `Graph` 的第二个构造函数），用这幅图和给定的起始结点创建一个 `Search` 对象，然后用 `marked()` 打印出图中和起点连通的所有顶点。它也调用了 `count()` 并打印了图是否是连通的（当且仅当搜索能够标记图中的所有顶点时图才是连通的）。

```
public class TestSearch
{
   public static void main(String[] args)
   {
      Graph G = new Graph(new In(args[0]));
      int s = Integer.parseInt(args[1]);
      Search search = new Search(G, s);

      for (int v = 0; v < G.V(); v++)
         if (search.marked(v))
            StdOut.print(v + " ");
      StdOut.println();

      if (search.count() != G.V())
         StdOut.print("NOT ");
      StdOut.println("connected");
   }
}
```

{-:-}图处理的用例（热身）

```
% java TestSearch tinyG.txt 0
0 1 2 3 4 5 6
NOT connected

% java TestSearch tinyG.txt 9
9 10 11 12
NOT connected
```

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.011.png)

我们已经见过 `Search` API 的一种实现：第 1 章中的 union-find 算法。它的构造函数会创建一个 `UF` 对象，对图中的每一条边进行一次 `union()` 操作并调用 `connected(s,v)` 来实现 `marked(v)` 方法。实现 `count()` 方法需要一个加权的 `UF` 实现并扩展它的 API，以便使用 `count()` 方法返回 `wt[find(v)]`（请见练习 4.1.8）。这种实现简单而高效，但下面我们要学习的实现还可以更进一步。它基于的是**深度优先搜索**（DFS）的。这是一种重要的递归方法，它会沿着图的边寻找和起点连通的所有顶点。深度优先搜索是本章中将学习的好几种关于图的算法的基础。

###4.1.3　深度优先搜索　通道

我们常常通过系统地检查每一个顶点和每一条边来获取图的各种性质。要得到图的一些简单性质（比如，计算所有顶点的度数）很容易，只要检查每一条边即可（任意顺序）。但图的许多其他性质和路径有关，因此一种很自然的想法是沿着图的边从一个顶点移动到另一个顶点。尽管存在各种各样的处理策略，但后面将要学习的几乎所有与图有关的算法都使用了这个简单的抽象模型，其中最简单的就是下面介绍的这种经典的方法。

####4.1.3.1　走迷宫

思考图的搜索过程的一种有益的方法是，考虑另一个和它等价但历史悠久而又特别的问题——在一个由各种通道和路口组成的迷宫中找到出路。有些迷宫的规则很简单，但大多数迷宫则需要很复杂的策略才行。用**迷宫**代替**图**、**通道**代替**边**、**路口**代替**顶点**仅仅只是一些文字游戏，但就目前来说，这么做可以帮助我们直观地认识问题，参见图 4.1.11。探索迷宫而不迷路的一种古老办法（至少可以追溯到忒修斯和米诺陶的传说）叫做 **Tremaux 搜索**，参见图 4.1.12。要探索迷宫中的所有通道，我们需要：

* 选择一条没有标记过的通道，在你走过的路上铺一条绳子；
* 标记所有你第一次路过的路口和通道；
* 当来到一个标记过的路口时（用绳子）回退到上个路口；
* 当回退到的路口已没有可走的通道时继续回退。

![{37%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.012.png)

**图 4.1.11　等价的迷宫模型**

![{30%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.013.png)

**图 4.1.12　Tremaux搜索**

绳子可以保证你总能找到一条出路，标记则能保证你不会两次经过同一条通道或者同一个路口。要知道是否完全探索了整个迷宫需要的证明更复杂，只有用图搜索才能够更好地处理问题。Tremaux 搜索很直接，但它与完全搜索一张图仍然稍有不同，因此我们接下来看看图的搜索方法。

```
public class DepthFirstSearch
{
   private boolean[] marked;
   private int count;

   public DepthFirstSearch(Graph G, int s)
   {
      marked = new boolean[G.V()];
      dfs(G, s);
   }

   private void dfs(Graph G, int v)
   {
      marked[v] = true;
      count++;
      for (int w : G.adj(v))
         if (!marked[w]) dfs(G, w);
   }

   public boolean marked(int w)
   {  return marked[w];  }

   public int count()
   {  return count;  }
}
```

{-:-}深度优先搜索

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.014.png)

####4.1.3.2　热身

搜索连通图的经典递归算法（遍历所有的顶点和边）和 Tremaux 搜索类似，但描述起来更简单。要搜索一幅图，只需用一个递归方法来遍历所有顶点。在访问其中一个顶点时：

* 将它标记为已访问；
* 递归地访问它的所有没有被标记过的邻居顶点。

这种方法称为**深度优先搜索**（DFS）。`Search` API 的一种实现使用了这种方法，如深度优先搜索框注所示。它使用一个 `boolean` 数组来记录和起点连通的所有顶点。递归方法会标记给定的顶点并调用自己来访问该顶点的相邻顶点列表中所有没有被标记过的顶点。如果图是连通的，每个邻接链表中的元素都会被检查到。

>**命题 A**。深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比。

>**证明**。首先，我们要证明这个算法能够标记与起点 `s` 连通的所有顶点（且不会标记其他顶点）。因为算法仅通过边来寻找顶点，所以每个被标记过的顶点都与 `s` 连通。现在，假设某个没有被标记过的顶点 `w` 与 `s` 连通。因为 `s` 本身是被标记过的，由 `s` 到 `w` 的任意一条路径中至少有一条边连接的两个顶点分别是被标记过的和没有被标记过的，例如 `v-x`。根据算法，在标记了 `v` 之后必然会发现 `x`，因此这样的边是不存在的。前后矛盾。每个顶点都只会被访问一次保证了时间上限（检查标记的耗时和度数成正比）。

####4.1.3.3　单向通道

代码中方法的调用和返回机制对应迷宫中绳子的作用：当已经处理过依附于一个顶点的所有边时（搜索了路口连接的所有通道），我们就只能“返回”（return，两者的意义相同）。为了更好地与迷宫的 Tremaux 搜索对应起来，我们可以想象一座完全由单向通道构造的迷宫（每个方向都有一个通道）。和在迷宫中会经过一条通道**两次**（方向不同）一样，在图中我们也会路过每条边两次（在它的两个端点各一次）。在 Tremaux 搜索中，要么是第一次访问区别了边的遍历方向的画法一条边，要么是沿着它从一个被标记过的顶点退回。在无向图的深度优先搜索中，在碰到边 `v-w` 时，要么进行递归调用（`w` 没有被标记过），要么跳过这条边（`w` 已经被标记过）。第二次从另一个方向 `w-v` 遇到这条边时，总是会忽略它，因为它的另一端 `v` 肯定已经被访问过了（在第一次遇到这条边的时候）。

####4.1.3.4　跟踪深度优先搜索

通常，理解算法的最好方法是在一个简单的例子中跟踪它的行为。深度优先算法尤其是这样。在跟踪它的轨迹时，首先要注意的是，算法遍历边和访问顶点的顺序与图的**表示**是有关的，而不只是与图的结构或是算法有关。因为深度优先搜索只会访问和起点连通的顶点，所以使用图 4.1.13 所示的一幅小型连通图为例。在示例中，顶点 `2` 是顶点 `0` 之后第一个被访问的顶点，因为它正好是 `0` 的邻接表的第一个元素。要注意的第二点是，如前文所述，深度优先搜索中每条边都会被访问两次，且在第二次时总会发现这个顶点已经被标记过。这意味着深度优先搜索的轨迹可能会比你想象的长一倍！示例图仅含有 8 条边，但需要追踪算法在邻接表的 16 个元素上的操作。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.015.png)

**图 4.1.13　一幅连通的无向图**

####4.1.3.5　深度优先搜索的详细轨迹

图 4.1.14 显示的是示例中每个顶点被标记后算法使用的数据结构，起点为顶点 `0`。查找开始于构造函数调用递归的 `dfs()` 来标记和访问顶点 `0`，后续处理如下所述。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.016.png)

**图 4.1.14　使用深度优先搜索的轨迹，寻找所有和顶点 0 连通的顶点**

* 因为顶点 `2` 是 `0` 的邻接表的第一个元素且没有被标记过，`dfs()` 递归调用自己来标记并访问顶点 `2`（效果是系统会将顶点 `0` 和 `0` 的邻接表的当前位置压入栈中）。
* 现在，顶点 `0` 是 `2` 的邻接表的第一个元素且已经被标记过了，因此 `dfs()` 跳过了它。接下来，顶点 `1` 是 `2` 的邻接表的第二个元素且没有被标记，`dfs()` 递归调用自己来标记并访问顶点 `1`。
* 对顶点 `1` 的访问和前面有所不同：因为它的邻接表中的所有顶点（`0` 和 `2`）都已经被标记过了，因此不需要再进行递归，方法从 `dfs(1)` 中返回。下一条被检查的边是 `2-3`（在 `2` 的邻接表中顶点 `1` 之后的顶点是 `3`），因此 `dfs()` 递归调用自己来标记并访问顶点 `3`。
* 顶点 `5` 是 `3` 的邻接表的第一个元素且没有被标记，因此 `dfs()` 递归调用自己来标记并访问顶点 `5`。
* 顶点 `5` 的邻接表中的所有顶点（`3` 和 `0`）都已经被标记过了，因此不需要再进行递归。
* 顶点 `4` 是 `3` 的邻接表的下一个元素且没有被标记过，因此 `dfs()` 递归调用自己来标记并访问顶点 `4`。这是最后一个需要被标记的顶点。
* 在顶点 `4` 被标记了之后，`dfs()` 会检查它的邻接表，然后再检查 `3` 的邻接表，然后是 `2` 的邻接表，然后是 `0` 的，最后发现不需要再进行任何递归调用，因为所有的顶点都已经被标记过了。

**这种简单的递归模式只是一个开始**——深度优先搜索能够有效处理许多和图有关的任务。例如，本节中，我们已经可以用深度优先搜索来解决在第 1 章首次提到的一个问题。

**连通性**。**给定一幅图，回答“两个给定的顶点是否连通？”或者“图中有多少个连通子图？”等类似问题**。

我们可以轻易地用处理图问题的标准设计模式给出这些问题的答案，还要将这些解答与在 1.5 节中学习的 union-find 算法进行比较。

问题“两个给定的顶点是否连通？”等价于“两个给定的顶点之间是否存在一条路径？”，也许也可以叫做**路径检测**问题。但是，在 1.5 节学习的 union-find 算法的数据结构并不能解决**找出**这样一条路径的问题。深度优先搜索是我们已经学习过的几种方法中第一个能够解决这个问题的算法。它能够解决的另一个问题如下所述。

**单点路径**。**给定一幅图和一个起点 `s`，回答“从 `s` 到给定目的顶点 `v` 是否存在一条路径？如果有，找出这条路径。”等类似问题**。

深度优先搜索算法之所以极为简单，是因为它所基于的概念为人所熟知并且非常容易实现。事实上，它是一个既小巧而又强大的算法，研究人员用它解决了无数困难的问题。上述两个问题只是我们将要研究的许多问题的开始。

###4.1.4　寻找路径

单点路径问题在图的处理领域中十分重要。根据标准设计模式，我们将使用如下 API（请见表 4.1.5）。

**表 4.1.5　路径的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>Paths</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Paths(Graph G, int s)</code></td><td>在 <code>G</code> 中找出所有起点为 <code>s</code> 的路径</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;hasPathTo(int v)</code></td><td>是否存在从 <code>s</code> 到 <code>v</code> 的路径</td></tr>
<tr><td><code>Iterable&lt;Integer>&nbsp;&nbsp;pathTo(int v)</code></td><td><code>s</code> 到 <code>v</code> 的路径，如果不存在则返回 <code>null</code></td></tr>
</table>

构造函数接受一个起点 `s` 作为参数，计算 `s` 到与 `s` 连通的每个顶点之间的路径。在为起点 `s` 创建了 `Paths` 对象后，用例可以调用 `pathTo()` 实例方法来遍历从 `s` 到任意和 `s` 连通的顶点的路径上的所有顶点。现在暂时查找所有路径，以后会实现只查找具有某些属性的路径。

```
% java Paths tinyCG.txt 0
0 to 0: 0
0 to 1: 0-2-1
0 to 2: 0-2
0 to 3: 0-2-3
0 to 4: 0-2-3-4
0 to 5: 0-2-3-5
```

　

```
public static void main(String[] args)
{
   Graph G = new Graph(new In(args[0]));
   int s = Integer.parseInt(args[1]);
   Paths search = new Paths(G, s);
   for (int v = 0; v < G.V(); v++)
   {
      StdOut.print(s + " to " + v + ": ");
      if (search.hasPathTo(v))
         for (int x : search.pathTo(v))
            if (x == s) StdOut.print(x);
            else StdOut.print("-" + x);
      StdOut.println();
   }
}
```

{-:-}`Paths` 实现的测试用例

上一页右下角框注中的用例从输入流中读取了一个图并从命令行得到一个起点，然后打印出从起点到与它连通的每个顶点之间的一条路径。

####4.1.4.1　实现

算法 4.1 基于深度优先搜索实现了 `Paths`。它扩展了 4.1.3.2 节中的热身代码 `DepthFirstSearch`，添加了一个实例变量 `edgeTo[]` 整型数组来起到 Tremaux 搜索中绳子的作用。这个数组可以找到从每个与 `s` 连通的顶点回到 `s` 的路径。它会记住**每个**顶点到起点的路径，而不是记录当前顶点到起点的路径。为了做到这一点，在由边 `v-w` **第一次访问**任意 `w` 时，将 `edgeTo[w]` 设为 `v` 来记住这条路径。换句话说，`v-w` 是从 `s` 到 `w` 的路径上的最后一条已知的边。这样，搜索的结果是一棵以起点为根结点的树，`edgeTo[]` 是一棵由父链接表示的树。算法 4.1 的代码的右侧是一个小示例。要找出 `s` 到任意顶点 `v` 的路径，算法 4.1 实现的 `pathTo()` 方法用变量 `x` 遍历整棵树，将 `x` 设为 `edgeTo[x]`，就像 1.5 节中的 union-find 算法一样，然后在到达 s 之前，将遇到的所有顶点都压入栈中。将这个栈返回为一个 `Iterable` 对象帮助用例遍历 `s` 到 `v` 的路径。

>**算法 4.1　使用深度优先搜索查找图中的路径**

>![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.017.png)

>　

>![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.018.png)

>{-:-}`pathTo(5)` 的计算轨迹

>这段 `Graph` 的用例使用了深度优先搜索，以找出图中从给定的起点 `s` 到它连通的所有顶点的路径。来自 `DepthFirstSearch`（4.1.3.2 节）的代码均为灰色。为了保存到达每个顶点的已知路径，这段代码使用了一个以顶点编号为索引的数组 `edgeTo[]`，`edgeTo[w]=v` 表示 `v-w` 是第一次访问 `w` 时经过的边。`edgeTo[]` 数组是一棵用父链接表示的以 `s` 为根且含有所有与 `s` 连通的顶点的树。

####4.1.4.2　详细轨迹

图 4.1.15 显示的是示例中每个顶点被标记后 `edgeTo[]` 的内容，起点为顶点 `0`。`marked[]` 和 `adj[]` 的内容与 4.1.3.5 节中的 `DepthFirstSearch` 的轨迹相同，递归调用和边检查的详细描述也完全一样，这里不再赘述。深度优先搜索向 `edgeTo[]` 数组中顺序添加了 `0-2`、`2-1`、`2-3`、`3-5` 和 `3-4`。这些边构成了一棵以起点为根结点的树并提供了 `pathTo()` 方法所需的信息，使得调用者可以按照前文所述的方法找到从 `0` 到顶点 `1`、`2`、`3`、`4`、`5` 的路径。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.019.png)

**图 4.1.15　使用深度优先搜索的轨迹，寻找所有起点为 0 的路径**

`DepthFirstPaths` 与 `DepthFirstSearch` 的构造函数仅有几条赋值语句不同，因此 4.1.3.2 节中的命题 A 仍然适用。另外，我们还有以下命题。

>**命题 A（续）**。使用深度优先搜索得到从给定起点到任意标记顶点的路径所需的时间与路径的长度成正比。

>**证明**。根据对已经访问过的顶点数量的归纳可得，`DepthFirstPaths` 中的 `edgeTo[]` 数组表示了一棵以起点为根结点的树。`pathTo()` 方法构造路径所需的时间和路径的长度成正比。

###4.1.5　广度优先搜索

深度优先搜索得到的路径不仅取决于图的结构，还取决于图的表示和递归调用的性质。我们很自然地还经常对下面这些问题感兴趣。

>单点最短路径。给定一幅图和一个起点 `s`，回答“从 `s` 到给定目的顶点 `v` 是否存在一条路径？如果有，找出其中最短的那条（所含边数最少）。”等类似问题。

解决这个问题的经典方法叫做**广度优先搜索**（BFS)。它也是许多图算法的基石，因此我们会在本节中详细学习。深度优先搜索在这个问题上没有什么作为，因为它遍历整个图的顺序和找出最短路径的目标没有任何关系。相比之下，广度优先搜索正是为了这个目标才出现的。要找到从 `s` 到 `v` 的最短路径，从 `s` 开始，在所有由一条边就可以到达的顶点中寻找 `v`，如果找不到我们就继续在与 `s` 距离两条边的所有顶点中查找 `v`，如此一直进行。深度优先搜索就好像是一个人在走迷宫，广度优先搜索则好像是一组人在一起朝各个方向走这座迷宫，每个人都有自己的绳子。当出现新的叉路时，可以假设一个探索者可以分裂为更多的人来搜索它们，当两个探索者相遇时，会合二为一（并继续使用先到达者的绳子），参见图 4.1.16。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.020.png)

**图 4.1.16　广度优先的迷宫搜索**

在程序中，在搜索一幅图时遇到有多条边需要遍历的情况时，我们会选择其中一条并将其他通道留到以后再继续搜索。在深度优先搜索中，我们用了一个可以下压的栈（这是由系统管理的，以支持递归搜索方法）。使用 LIFO（后进先出）的规则来描述压栈和走迷宫时先探索相邻的通道类似。从有待搜索的通道中选择最晚遇到过的那条。在广度优先搜索中，我们希望按照与起点的距离的顺序来遍历所有顶点，看起来这种顺序很容易实现：使用（FIFO，先进先出）队列来代替栈（LIFO，后进先出）即可。我们将从有待搜索的通道中选择最早遇到的那条。

**实现**

算法 4.2 实现了广度优先搜索算法。它使用了一个队列来保存所有已经被标记过但其邻接表还未被检查过的顶点。先将起点加入队列，然后重复以下步骤直到队列为空：

* 取队列中的下一个顶点 `v` 并标记它；
* 将与 `v` 相邻的所有未被标记过的顶点加入队列。

算法 4.2 中的 `bfs()` 方法**不是**递归的。不像递归中隐式使用的栈，它显式地使用了一个队列。和深度优先搜索一样，它的结果也是一个数组 `edgeTo[]`，也是一棵用父链接表示的根结点为 `s` 的树。它表示了 `s` 到每个与 `s` 连通的顶点的最短路径。用例也可以使用算法 4.1 中为深度优先搜索实现的相同的 `pathTo()` 方法得到这些路径。

图 4.1.17 和图 4.1.18 显示了用广度优先搜索处理样图时，算法使用的数据结构在每次循环的迭代开始时的内容。首先，顶点 `0` 被加入队列，然后循环开始搜索。

![{75%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.021.png)

**图 4.1.17　使用广度优先搜索寻找所有起点为 `0` 的路径的结果**

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.022.png)

**图 4.1.18　使用广度优先搜索的轨迹，寻找所有起点为 `0` 的路径**

* 从队列中删去顶点 `0` 并将它的相邻顶点 `2`、`1` 和 `5` 加入队列中，标记它们并分别将它们在 `edgeTo[]` 中的值设为 `0`。
* 从队列中删去顶点 `2` 并检查它的相邻顶点 `0` 和 `1`，发现两者都已经被标记。将相邻的顶点 `3` 和 `4` 加入队列，标记它们并分别将它们在 `edgeTo[]` 中的值设为 `2`。
* 从队列中删去顶点 `1` 并检查它的相邻顶点 `0` 和 `2`，发现它们都已经被标记了。
* 从队列中删去顶点 `5` 并检查它的相邻顶点 `3` 和 `0`，发现它们都已经被标记了。
* 从队列中删去顶点 `3` 并检查它的相邻顶点 `5`、`4` 和 `2`，发现它们都已经被标记了。
* 从队列中删去顶点 `4` 并检查它的相邻顶点 `3` 和 `2`，发现它们都已经被标记了。

>**算法 4.2　使用广度优先搜索查找图中的路径**

>```
>public class BreadthFirstPaths
>{
>    private boolean[] marked; // 到达该顶点的最短路径已知吗？
>    private int[] edgeTo;     // 到达该顶点的已知路径上的最后一个顶点
>    private final int s;      // 起点
>
>    public BreadthFirstPaths(Graph G, int s)
>    {
>       marked = new boolean[G.V()];
>       edgeTo = new int[G.V()];
>       this.s = s;
>       bfs(G, s);
>    }
>
>    private void bfs(Graph G, int s)
>    {
>       Queue<Integer> queue = new Queue<Integer>();
>       marked[s] = true;          // 标记起点
>       queue.enqueue(s);          // 将它加入队列
>       while (!queue.isEmpty())
>       {
>          int v = queue.dequeue(); // 从队列中删去下一顶点
>          for (int w : G.adj(v))
>             if (!marked[w])       // 对于每个未被标记的相邻顶点
>             {
>                edgeTo[w] = v;     // 保存最短路径的最后一条边
>                marked[w] = true;  // 标记它，因为最短路径已知
>                queue.enqueue(w);  // 并将它添加到队列中
>             }
>       }
>    }
>
>    public boolean hasPathTo(int v)
>    {  return marked[v];  }
>
>    public Iterable<Integer> pathTo(int v)
>    // 和深度优先搜索中的实现相同（请见算法4.1）
>
>}
>```

>　

>```
>% java BreadthFirstPaths tinyCG.txt 0
>0 to 0: 0
>0 to 1: 0-1
>0 to 2: 0-2
>0 to 3: 0-2-3
>0 to 4: 0-2-4
>0 to 5: 0-5
>```

>这段 `Graph` 的用例使用了广度优先搜索，以找出图中从构造函数得到的起点 `s` 到与其他所有顶点的最短路径。`bfs()` 方法会标记所有与 `s` 连通的顶点，因此用例可以调用 `hasPathTo()` 来判定一个顶点与 `s` 是否连通并使用 `pathTo()` 得到一条从 `s` 到 `v` 的路径，确保没有其他从 `s` 到 `v` 的路径所含的边比这条路径更少。

对于这个例子来说，`edgeTo[]` 数组在第二步之后就已经完成了。和深度优先搜索一样，一旦所有的顶点都已经被标记，余下的计算工作就只是在检查连接到各个已被标记的顶点的边而已。

>**命题 B**。对于从 `s` 可达的任意顶点 `v`，广度优先搜索都能找到一条从 s 到 v 的最短路径（没有其他从 s 到 v 的路径所含的边比这条路径更少）。

>**证明**。由归纳易得队列总是包含零个或多个到起点的距离为 ![k](https://private.codecogs.com/gif.latex?k) 的顶点，之后是零个或多个到起点的距离为 ![k+1](https://private.codecogs.com/gif.latex?k+1) 的顶点，其中 ![k](https://private.codecogs.com/gif.latex?k) 为整数，起始值为 0。这意味着顶点是按照它们和 `s` 的距离的顺序加入或者离开队列的。从顶点 `v` 加入队列到它离开队列之前，不可能找出到 `v` 的更短的路径，而在`v`离开队列之后发现的所有能够到达 `v` 的路径都不可能短于 `v` 在树中的路径长度。

　

>**命题 B（续）**。广度优先搜索所需的时间在最坏情况下和 ![V+E](https://private.codecogs.com/gif.latex?V+E) 成正比。

>**证明**。和命题 A 一样（请见 4.1.3.2 节），广度优先搜索标记所有与 `s` 连通的顶点所需的时间也与它们的度数之和成正比。如果图是连通的，这个和就是所有顶点的度数之和，也就是 ![2E](https://private.codecogs.com/gif.latex?2E)。

注意，我们也可以用广度优先搜索来实现已经用深度优先搜索实现的 `Search` API，因为它检查所有与起点连通的顶点和边的方法只取决于查找的能力。

我们在本章开头说过，深度优先搜索和广度优先搜索是我们首先学习的几种通用的图搜索的算法之一。在搜索中我们都会先将起点存入数据结构中，然后重复以下步骤直到数据结构被清空：

* 取其中的下一个顶点并标记它；
* 将 `v` 的所有相邻而又未被标记的顶点加入数据结构。

这两个算法的不同之处仅在于从数据结构中获取下一个顶点的规则（对于广度优先搜索来说是最早加入的顶点，对于深度优先搜索来说是最晚加入的顶点）。这种差异得到了处理图的两种完全不同的视角，尽管无论使用哪种规则，所有与起点连通的顶点和边都会被检查到。

图 4.1.19 和图 4.1.20 显示了深度优先搜索和广度优先搜索处理样图 mediumG.txt 的过程，它们清晰地展示了两种方法中搜索路径的不同。深度优先搜索不断深入图中并在栈中保存了所有分叉的顶点；广度优先搜索则像扇面一般扫描图，用一个队列保存访问过的最前端的顶点。深度优先搜索探索一幅图的方式是寻找离起点更远的顶点，只在碰到死胡同时才访问近处的顶点；广度优先搜索则会首先覆盖起点附近的顶点，只在临近的所有顶点都被访问了之后才向前进。深度优先搜索的路径通常较长而且曲折，广度优先搜索的路径则短而直接。根据应用的不同，所需要的性质也会有所不同（也许路径的性质也会变得无关紧要）。在 4.4 节中，我们会学习 `Paths` 的 API 的其他实现来寻找有特定属性的路径。

![{30%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.023.png)

**图 4.1.19　使用深度优先搜索查找路径（250 个顶点）**

![{30%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.024.png)

**图 4.1.20　使用广度优先搜索查找最短路径（250 个顶点）**

###4.1.6　连通分量

深度优先搜索的下一个直接应用就是找出一幅图的所有连通分量。回忆 1.5 节中“与……连通”是一种**等价关系**，它能够将所有顶点切分为**等价类**（连通分量）。对于这个常见的任务，我们定义如下 API（请见表 4.1.6）。

**表 4.1.6　连通分量的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>CC</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CC(Graph G)</code></td><td>预处理构造函数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;connected(int v, int w)</code></td><td><code>v</code> 和 <code>w</code> 连通吗</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;count()</code></td><td>连通分量数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;id(int v)</code></td><td><code>v</code> 所在的连通分量的标识符（<code>0</code>～<code>count()-1</code>）</td></tr>
</table>

用例可以用 `id()` 方法将连通分量用数组保存，如框注中的用例所示。它能够从标准输入中读取一幅图并打印其中的连通分量数，其后是每个子图中的所有顶点，每行一个子图。为了实现这些，它使用了一个 `Bag` 对象数组，然后用每个顶点所在的子图的标识符作为数组的索引，以将所有顶点加入相应的 `Bag` 对象中。当我们希望独立处理每个连通分量时这个用例就是一个模型。

####4.1.6.1　实现

CC 的实现（请见算法 4.3）使用了 `marked[]` 数组来寻找一个顶点作为每个连通分量中深度优先搜索的起点。递归的深度优先搜索第一次调用的参数是顶点 `0`——它会标记所有与 `0` 连通的顶点。然后构造函数中的 `for` 循环会查找每个没有被标记的顶点并递归调用 `dfs()` 来标记和它相邻的所有顶点。另外，它还使用了一个以顶点作为索引的数组 `id[]`，将同一个连通分量中的顶点和连通分量的标识符关联起来（`int` 值）。这个数组使得 `connected()` 方法的实现变得十分简单，和 1.5 节中的 `connected()` 方法完全相同（只需检查标识符是否相同）。这里，标识符 `0` 会被赋予第一个连通分量中的所有顶点，`1` 会被赋予第二个连通分量中的所有顶点，依此类推。这样所有的标识符都会如 API 中指定的那样在 `0` 到 `count()-1` 之间。这个约定使得以子图作为索引的数组成为可能，如右侧框注用例所示。

```
public static void main(String[] args)
{
   Graph G = new Graph(new In(args[0]));
   CC cc = new CC(G);

   int M = cc.count();
   StdOut.println(M + " components");

   Bag<Integer>[] components;
   components = (Bag<Integer>[]) new Bag[M];
   for (int i = 0; i < M; i++)
      components[i] = new Bag<Integer>();
   for (int v = 0; v < G.V(); v++)
      components[cc.id(v)].add(v);
   for (int i = 0; i < M; i++)
   {
      for (int v: components[i])
         StdOut.print(v + " ");
      StdOut.println();
   }
}
```

{-:-}查找连通分量 API 的测试用例

>**算法 4.3　使用深度优先搜索找出图中的所有连通分量**

>![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.025.png)

>　

>```
>% java Graph tinyG.txt
>13 vertices, 13 edges
>0: 6 2 1 5
>1: 0
>2: 0
>3: 5 4
>4: 5 6 3
>5: 3 4 0
>6: 0 4
>7: 8
>8: 7
>9: 11 10 12
>10: 9
>11: 9 12
>12: 11 9
>
>% java CC tinyG.txt
>3 components
>6 5 4 3 2 1 0
>8 7
>12 11 10 9
>```

>这段 `Graph` 的用例使得它的用例可以独立处理一幅图中的每个连通分量。来自 `DepthfirstSearch`（请见 4.1.3.2 节）的代码均为灰色。这里的实现是基于一个由顶点索引的数组 `id[]`。如果 `v` 属于第 `i` 个连通分量，则 `id[v]` 的值为 `i`。构造函数会找出一个未被标记的顶点并调用递归函数 dfs() 来标记并区分出所有和它连通的顶点，如此重复直到所有的顶点都被标记并区分。`connected()`、`count()` 和 `id()` 方法的实现非常简单（另见图 4.1.21）。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.026.png)

**图 4.1.21　使用深度优先搜索寻找所有连通分量的轨迹**

>**命题 C**。深度优先搜索的预处理使用的时间和空间与 ![V+E](https://private.codecogs.com/gif.latex?V+E) 成正比且可以在常数时间内处理关于图的连通性查询。

>**证明**。由代码可以知道每个邻接表的元素都只会被检查一次，共有 ![2E](https://private.codecogs.com/gif.latex?2E) 个元素（每条边两个）。实例方法会检查或者返回一个或两个变量。

####4.1.6.2　union-find 算法

`CC` 中基于深度优先搜索来解决图连通性问题的方法与第 1 章中的 union-find 算法相比孰优孰劣？理论上，深度优先搜索比 union-find 算法快，因为它能保证所需的时间是常数而 union-find 算法不行；但在实际应用中，这点差异微不足道。union-find 算法其实更快，因为它不需要完整地构造并表示一幅图。更重要的是，union-find 算法是一种动态算法（我们在任何时候都能用接近常数的时间检查两个顶点是否连通，甚至是在添加一条边的时候），但深度优先搜索则必须要对图进行预处理。因此，我们在完成只需要判断连通性或是需要完成有大量连通性查询和插入操作混合等类似的任务时，更倾向使用 union-find 算法，而深度优先搜索则更适合实现图的抽象数据类型，因为它能更有效地利用已有的数据结构。

我们已经用深度优先搜索解决了几个非常基础的问题。这种方法很简单，递归实现使我们能够进行复杂的运算并为一些图的处理问题给出简洁的解决方法。在表 4.1.7 中，我们为下面两个问题作出了解答。

**检测环**。**给定的图是无环图吗**？

**双色问题**。**能够用两种颜色将图的所有顶点着色，使得任意一条边的两个端点的颜色都不相同吗？这个问题也等价于：这是一幅二分图吗**？

深度优先搜索和已学习过的其他算法一样，它简洁的代码下隐藏着复杂的计算。因此，研究这些例子、在样图中跟踪算法的轨迹并加以扩展、用算法来解决环和着色的问题都是非常值得的（留作练习）。

**表 4.1.7　使用深度优先搜索处理图的其他示例**

|任务|实现|
|-|-|
|G 是无环图吗？（假设不存在自环或平行边）|![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.027.png)|
|G 是二分图吗？（双色问题）|![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.028.png)|

###4.1.7　符号图

在典型应用中，图都是通过文件或者网页定义的，使用的是字符串而非整数来表示和指代顶点。为了适应这样的应用，我们定义了拥有以下性质的输入格式：

* 顶点名为字符串；
* 用指定的分隔符来隔开顶点名（允许顶点名中含有空格）；
* 每一行都表示一组边的集合，每一条边都连接着这一行的第一个名称表示的顶点和其他名称所表示的顶点；
* 顶点总数 ![V](https://private.codecogs.com/gif.latex?V) 和边的总数 ![E](https://private.codecogs.com/gif.latex?E) 都是隐式定义的。

图 4.1.22 是一个简单的示例。routes.txt 文件表示的是一个小型运输系统的模型，其中表示每个顶点的是美国机场的代码，连接它们的边则表示顶点之间的航线。文件只是一组边的列表。图 4.1.23 所示的是一个更庞大的例子，取自 movies.txt，即 3.5 节中介绍的**互联网电影数据库**。还记得吗？这个文件的每一行都列出了一个电影名以及出演该部电影的一系列演员。从图的角度来说，我们可以将它看作一幅图的定义，电影和演员都是顶点，而邻接表中的每一条边都将电影和它的表演者联系起来。注意，这是一幅二分图——电影顶点之间或者演员结点之间都没有边相连。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.029.png)

**图 4.1.22　符号图示例（边的列表）**

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.030.png)

**图 4.1.23　符号图示例（邻接表）**

####4.1.7.1　API

表 4.1.8 中，API 定义的 `Graph` 用例可以直接使用已有的图算法来处理这种文件定义的图。

**表 4.1.8　用符号作为顶点名的图的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class <b>SymbolGraph</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SymbolGraph(String filename, String delim)</code></td><td>根据 <code>filename</code> 指定的文件构造图，使用 <code>delim</code> 来分隔顶点名</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;contains(String key)</code></td><td><code>key</code> 是一个顶点吗</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;index(String key)</code></td><td><code>Key</code> 的索引</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;name(int v)</code></td><td>索引 <code>v</code> 的顶点名</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graph&nbsp;&nbsp;G()</code></td><td>隐藏的 <code>Graph</code> 对象</td></tr>
</table>

这份 API 定义了一个构造函数来读取并构造图，用 `name()` 方法和 `index()` 方法将输入流中的顶点名和图算法使用的顶点索引对应起来。

####4.1.7.2　测试用例

下一页框注所示的是符号图的测试用例，它用第一个命令行参数指定的文件（第二个命令行参数指定了分隔符）来构造一幅图并从标准输入接受查询。用户可以输入一个顶点名并得到该顶点的相邻结点的列表。这个用例提供的正好是 3.5 节中研究过的反向索引的功能。以 routes.txt 为例，你可以输入一个机场的代码来查找能从该机场直飞到达的城市，但这些信息并不是直接就能从文件中得到的。对于 movies.txt，你可以输入一个演员的名字来查看数据库中他所出演的影片列表。输入一部电影的名字来得到它的演员列表，这不过是在照搬文件中对应行数据，但输入演员的名字来得到影片的列表则相当于查找反向索引。尽管数据库的构造是为了将电影名连接到演员，二分图模型同时也意味着将演员连接到电影名。二分图的性质自动完成了反向索引。以后我们将会看到，这将成为处理更复杂的和图有关的问题的基础。

```
public static void main(String[] args)
{
   String filename = args[0];
   String delim = args[1];
   SymbolGraph sg = new SymbolGraph(filename, delim);

   Graph G = sg.G();

   while (StdIn.hasNextLine())
   {
      String source = StdIn.readLine();
      for (int w : G.adj(sg.index(source)))
         StdOut.println("   " + sg.name(w));
   }
}
```

{-:-}符号图 API 的测试用例

```
% java SymbolGraph routes.txt " "
JFK
   ORD
   ATL
   MCO
LAX
   LAS
   PHX
```

　

```
% java SymbolGraph movies.txt "/"
Tin Men (1987)
   DeBoy, David
   Blumenfeld, Alan
   ...
   Geppi, Cindy
   Hershey, Barbara
   ...
Bacon, Kevin
   Mystic River (2003)
   Friday the 13th (1980)
   Flatliners (1990)
   Few Good Men, A (1992)
   ...
```

很显然，这种方法适用于我们遇到过的所有图算法：用例可以用 `index()` 将顶点名转化为索引并在图的处理算法中使用，然后将处理结果用 `name()` 转化为顶点名以方便在实际应用中使用。

####4.1.7.3　实现

`SymbolGraph` 的完整实现请见下面的框注“符号图的数据类型”。它用到了以下 3 种数据结构，参见图 4.1.24。

* 一个符号表 `st`，键的类型为 `String`（顶点名），值的类型为 `int`（索引）；
* 一个数组 `keys[]`，用作反向索引，保存每个顶点索引所对应的顶点名；
* 一个 `Graph` 对象 `G`，它使用索引来引用图中顶点。

`SymbolGraph` 会遍历两遍数据来构造以上数据结构，这主要是因为构造 `Graph` 对象需要顶点总数 ![V](https://private.codecogs.com/gif.latex?V)。在典型的实际应用中，在定义图的文件中指明 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E)（见本节开头 `Graph` 的构造函数）可能会有些不便，而有了 `SymbolGraph`，我们就可以方便地在 routes.txt 或者 movies.txt 中添加或者删除条目而不用担心需要维护边或顶点的总数。

![{95%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.031.png)

**图 4.1.24　符号图中用到的数据结构**

>**符号图的数据类型**

>```
>public class SymbolGraph
>{
>    private ST<String, Integer> st;              // 符号名 → 索引
>    private String[] keys;                       // 索引 → 符号名
>    private Graph G;                             // 图
>
>    public SymbolGraph(String stream, String sp)
>    {
>       st = new ST<String, Integer>();
>       In in = new In(stream);                   // 第一遍
>       while (in.hasNextLine())                  // 构造索引
>       {
>          String[] a = in.readLine().split(sp);  // 读取字符串
>
>          for (int i = 0; i < a.length; i++)     // 为每个不同的字符串关联一个索引
>             if (!st.contains(a[i]))
>
>                st.put(a[i], st.size());
>       }
>       keys = new String[st.size()];             // 用来获得顶点名的反向索引是一个数组
>
>       for (String name : st.keys())
>          keys[st.get(name)] = name;
>
>       G = new Graph(st.size());
>       in = new In(stream);                      // 第二遍
>       while (in.hasNextLine())                  // 构造图
>       {
>          String[] a = in.readLine().split(sp);  // 将每一行的第一个顶点和该行的其他顶点相连
>          int v = st.get(a[0]);
>          for (int i = 1; i < a.length; i++)
>             G.addEdge(v, st.get(a[i]));
>       }
>    }
>
>    public boolean contains(String s) {  return st.contains(s);  }
>    public int index(String s)        {  return st.get(s);  }
>    public String name(int v)         {  return keys[v];  }
>    public Graph G()                  {  return G;  }
>}
>```

>这个 `Graph` 实现允许用例用字符串代替数字索引来表示图中的顶点。它维护了实例变量 `st`（符号表用来映射顶点名和索引）、`keys`（数组用来映射索引和顶点名）和 `G`（使用索引表示顶点的图）。为了构造这些数据结构，代码会将图的定义处理两遍（定义的每一行都包含一个顶点及它的相邻顶点列表，用分隔符 `sp` 隔开）。

####4.1.7.4　间隔的度数

图处理的一个经典问题就是，找到一个社交网络之中两个人间隔的度数。为了弄清楚概念，我们用一个最近很流行的名为 _Kevin Bacon_ 的游戏来说明这个问题。这个游戏用到了刚才讨论的“电影 - 演员”图。Kevin Bacon 是一个活跃的演员，曾出演过许多电影。我们为图中的每个演员赋一个 Kevin Bacon **数**：Bacon 本人为 0，所有和 Kevin Bacon 出演过同一部电影的人的值为 1，所有（除了 Kevin Bacon）和 Kevin Bacon 数为 1 的演员出演过同一部电影的其他演员的值为 2，依次类推。例如，Meryl Streep 的 Kevin Bacon 数为 1，因为她和 Kevin Bacon 一同出演过 _The River Wild_。Nicole Kidman 的值为 2，因为她虽然没有和 Kevin Bacon 同台演出过任何电影，但她和 Tom Cruise 一起演过 _Days of Thunder_，而 Tom Cruise 和 Kevin Bacon 一起演过 _A Few Good Men_。给定一个演员的名字，游戏最简单的玩法就是找出一系列的电影和演员来回溯到 Kevin Bacon。例如，有些影迷可能知道 Tom Hanks 和 Lloyd Bridges 一起演过 _Joe Versus the Volcano_，而 Bridges 和 Grace Kelly 一起演过 _High Noon_，Kelly 又和 Patrick Allen 一起演过 _Dial M for Murder_，Allen 和 Donald Sutherland 一起演过 _The Eagle has Landed_，Sutherland 和 Kevin Bacon 一起出演了 _Animal House_。但知道这些也并不足以确定 Tom Hanks 的 Kevin Bacon 数。（他的值实际上应该是 1，因为他和 Kevin Bacon 在 _Apollo 13_ 中合作过）。你可以看到 Kevin Bacon 数必须定义为**最短**电影链的长度，因此如果不用计算机，人们很难知道游戏中到底谁赢了。当然，如后面框注“间隔的度数”中 `SymbolGraph` 的用例 `DegreesOfSeparation` 所示，`BreadthFirstPaths` 才是我们所要的程序，它通过最短路径来找出 movies.txt 中任意演员的 Kevin Bacon 数。这个程序从命令行得到一个起点，从标准输入中接受查询并打印出一条从起点到被查询顶点的最短路径。因为 movies.txt 所构造的是一幅二分图，每条路径上都会交替出现电影和演员的顶点。打出的结果可以证明这样的路径是存在的（但并不能证明它是最短的——你需要向你的朋友证明命题 B 才行）。`DegreesOfSeparation` 也能够在非二分图中找到最短路径。例如，在 routes.txt 中，它能够用最少的边找到一种从一个机场到达另一个机场的方法。

```
% java DegreesOfSeparation movies.txt "/" "Bacon, Kevin"
Kidman, Nicole
   Bacon, Kevin
   Woodsman,The(2004)
   Grier,David Alan
   Bewitched(2005)
   Kidman, Nicole
Grant, Cary
Bacon, Kevin
   Planes,Trains Automobiles(1987)
   Martin,Steve(I)
   Dead Men Don't Wear Plaid(1982)
   Grant, Cary
```

你可能会发现用 `DegreesOfSeparation` 来回答一些关于电影行业的问题很有趣。例如，你不但可以找到演员和演员之间的间隔，还可以找到电影和电影之间的间隔。更重要的是，间隔的概念在其他许多领域也被广泛研究。例如，数学家也会玩这个游戏，但他们的图是用一些论文的作者到 P.Erdös（20 世纪的一位多产的数学家）的距离来定义的。类似地，似乎新泽西州的每个人的 Bruce Springsteen 数都为 2，因为每个人都声称自己认识某个认识 Bruce 的人。要玩 Erdös 的游戏，你需要一个包含所有数学论文的数据库；要玩 Sprintsteen 的游戏还要困难一些。从更严肃的角度来说，间隔度数的理论在计算机网络的设计以及理解各个科学领域中的自然网络中都能起到重要的作用。

```
% java DegreesOfSeparation movies.txt "/" "Animal House (1978)"
Titanic (1997)
   Animal House (1978)
   Allen, Karen (I)
   Raiders of the Lost Ark (1981)
   Taylor, Rocky (I)
   Titanic (1997)
To Catch a Thief (1955)
   Animal House (1978)
   Vernon, John (I)
   Topaz (1969)
   Hitchcock, Alfred (I)
   To Catch a Thief (1955)
```

>**间隔的度数**

>```
>public class DegreesOfSeparation
>{
>    public static void main(String[] args)
>    {
>       SymbolGraph sg = new SymbolGraph(args[0], args[1]);
>
>       Graph G = sg.G();
>
>       String source = args[2];
>       if (!sg.contains(source))
>       {  StdOut.println(source + "not in database."); return;  }
>
>       int s = sg.index(source);
>       BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);
>
>       while (!StdIn.isEmpty())
>       {
>          String sink = StdIn.readLine();
>          if (sg.contains(sink))
>          {
>             int t = sg.index(sink);
>             if (bfs.hasPathTo(t))
>                for (int v : bfs.pathTo(t))
>                   StdOut.println("   " + sg.name(v));
>             else StdOut.println("Not connected");
>          }
>          else StdOut.println("Not in database.");
>       }
>    }
>}
>```

>　

>```
>% java DegreesOfSeparation routes.txt " " JFK
>LAS
>    JFK
>    ORD
>    PHX
>    LAS
>DFW
>    JFK
>    ORD
>    DFW
>```

>这段代码使用了 `SymbolGraph` 和 `BreadthFirstPaths` 来查找图中的最短路径。对于 movies.txt，可以用它来玩 Kevin Bacon 游戏。

###4.1.8　总结

在本节中，我们介绍了几个基本的概念，本章的其余部分会继续扩展并研究：

* 图的术语；
* 一种图的表示方法，能够处理大型而稀疏的图；
* 和图处理相关的类的设计模式，其实现算法通过在相关的类的构造函数中对图进行预处理、构造所需的数据结构来高效支持用例对图的查询；
* 深度优先搜索和广度优先搜索；
* 支持使用符号作为图的顶点名的类。

表 4.1.9 总结了我们已经学习过的所有图算法的实现。这些算法非常适合作为图处理的入门学习。随后学习更加复杂类型的图以及处理更加困难的问题时，我们还会用到这些代码的变种。在考虑了边的方向以及权重之后，同样的问题会变得困难得多，但同样的算法仍然奏效并将成为解决更加复杂问题的起点。

**表 4.1.9　本节中得到解决的无向图处理问题**

|问题|解决方法|参阅|
|-|-|-|
|单点连通性|`DepthFirstSearch`|4.1.3.2 节|
|单点路径|`DepthFirstPaths`|算法 4.1|
|单点最短路径|`BreadthFirstPaths`|算法 4.2|
|连通性|`CC`|算法 4.3|
|检测环|`Cycle`|表 4.1.7|
|双色问题（图的二分性）|`TwoColor`|表 4.1.7|

###答疑

**问**　为什么不把所有的算法都实现在 Graph.java 中？

**答**　可以这么做，可以向基本的 `Graph` 抽象数据类型的定义中添加查询方法（以及它们需要的私有变量和方法等）。尽管这种方式可以用到一些我们所使用的数据结构的优点，它还是有一些严重的缺陷，因为图处理的成本比 1.3 节中遇到那些基本数据结构要高得多。这些缺点主要有：

* 在图处理中，需要实现的操作还有很多，我们无法在一份 API 中全部精确地定义它们；
* 简单任务的 API 和复杂任务所使用的 API 是相同的；
* 一个方法将可以访问另外一个方法专用的变量，这有悖我们需要遵守的封装原则。

这种情况并不罕见：这种 API 被称为**宽**接口（请见 1.2.5.2 节）。本章包含如此众多的图算法，将导致这种 API 变得非常宽。

**问**　`SymbolGraph` 真需要将图的定义遍历两遍吗？

**答**　不，你也可以将用时变为原来的 ![\lg V](https://private.codecogs.com/gif.latex?\lg%20V) 倍并直接用 `ST` 而非 `Bag` 来实现 `adj()`。我们的另一本书 _An Introduction to Programming in Java: An Interdisciplinary Approach_ 中含有使用这种方法的一个实现。

###练习

**4.1.1**　一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点且不含有平行边的图中至多含有多少条边？一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点的连通图中至少含有多少条边？

**4.1.2**　按照正文中示意图的样式（请见图 4.1.9）画出 `Graph` 的构造函数在处理图 4.1.25 的 tinyGex2.txt 时构造的邻接表。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.032.png)

**图　4.1.25**

**4.1.3**　为 `Graph` 添加一个复制构造函数，它接受一幅图 `G` 然后创建并初始化这幅图的一个副本。`G` 的用例对它作出的任何改动都不应该影响到它的副本。

**4.1.4**　为 `Graph` 添加一个方法 `hasEdge()`，它接受两个整型参数 `v` 和 `w`。如果图含有边 `v-w`，方法返回 `true`，否则返回 `false`。

**4.1.5**　修改 `Graph`，不允许存在平行边和自环。

**4.1.6**　有一张含有四个顶点的图，其中的边为 `0-1`、`1-2`、`2-3` 和 `3-0`。给出一种邻接表数组，无论以任何顺序调用 `addEdge()` 来添加这些边都无法创建它。

**4.1.7**　为 `Graph` 编写一个测试用例，用命令行参数指定名字的输入流中接受一幅图，然后用 `toString()` 方法将其打印出来。

**4.1.8**　按照正文中的要求，用 union-find 算法实现 4.1.2.3 中搜索的 API。

**4.1.9**　使用 `dfs(0)` 处理由 `Graph` 的构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图并按照 4.1.3.5 节的图 4.1.14 的样式给出详细的轨迹。同时，画出 `edgeTo[]` 所表示的树。

**4.1.10**　证明在任意一幅连通图中都存在一个顶点，删去它（以及和它相连的所有边）不会影响到图的连通性，编写一个深度优先搜索的方法找出这样一个顶点。**提示**：留心那些相邻顶点全部都被标记过的顶点。

**4.1.11**　使用算法 4.2 中的 `bfs(G,0)` 处理由 `Graph` 的构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图并画出 `edgeTo[]` 所表示的树。

**4.1.12**　如果 `v` 和 `w` 都不是根结点，能够由广度优先搜索得到的树中计算它们之间的距离吗？

**4.1.13**　为 `BreadthFirstPaths` 的 API 添加并实现一个方法 `distTo()`，返回从起点到给定的顶点的最短路径的长度，它所需的时间应该为常数。

**4.1.14**　如果用栈代替队列来实现广度优先搜索，我们还能得到最短路径吗？

**4.1.15**　修改 `Graph` 的输入流构造函数，允许从标准输入读入图的邻接表（方法类似于 `SymbolGraph`），如图 4.1.26 的 tinyGadj.txt 所示。在顶点和边的总数之后，每一行由一个顶点和它的所有相邻顶点组成。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.033.png)

**图　4.1.26**

**4.1.16**　顶点 `v` 的**离心率**是它和离它最远的顶点的最短距离。图的**直径**即所有顶点的最大离心率，**半径**为所有顶点的最小离心率，**中点**为离心率和半径相等的顶点。实现以下 API，如表 4.1.10 所示。

**表 4.1.10**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>GraphProperties</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GraphProperties(Graph G)</code></td><td>构造函数（如果 <code>G</code> 不是连通的，抛出异常）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;eccentricity(int v)</code></td><td><code>v</code> 的离心率</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;diameter()</code></td><td><code>G</code> 的直径</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;radius()</code></td><td><code>G</code> 的半径</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;center()</code></td><td><code>G</code> 的某个中点</td></tr>
</table>

**4.1.17**　图的**周长**为图中最短环的长度。如果是无环图，则它的周长为无穷大。为 `GraphProperties` 添加一个方法 `girth()`，返回图的周长。**提示**：在每个顶点都进行广度优先搜索。含有 `s` 的最小环为 `s` 到某个顶点 `v` 的最短路径加上从 `v` 返回到 `s` 的边。

**4.1.18**　使用 `CC` 找出由 `Graph` 的输入流构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图中的所有连通分量并按照图 4.1.21 的样式给出详细的轨迹。

**4.1.19**　使用 `Cycle` 在由 `Graph` 的输入流构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图中找到的一个环并按照本节示意图的样式给出详细的轨迹。在最坏情况下，`Cycle` 构造函数的运行时间的增长数量级是多少？

**4.1.20**　使用 `TwoColor` 给出由 `Graph` 的构造函数从 tinyGex2.txt（请见练习 4.1.2）得到的图的一个着色方案并按照本节示意图的样式给出详细的轨迹。在最坏情况下，`TwoColor` 构造函数的运行时间的增长数量级是多少？

**4.1.21**　用 `SymbolGraph` 和 movie.txt 找到今年获得奥斯卡奖提名的演员的 Kevin Bacon 数。

**4.1.22**　编写一段程序 `BaconHistogram`，打印一幅 Kevin Bacon 数的柱状图，显示 movies.txt 中 Kevin Bacon 数为 0、1、2、3……的演员分别有多少。将值为无穷大的人（不与 Kevin Bacon 连通）归为一类。

**4.1.23**　计算由 movies.txt 得到的图的连通分量的数量和包含的顶点数小于 10 的连通分量的数量。计算最大的连通分量的离心率、直径、半径和中点。Kevin Bacon 在最大的连通分量之中吗？

**4.1.24**　修改 `DegreesOfSeparation`，从命令行接受一个整型参数 `y`，忽略上映年数超过 `y` 的电影。

```
% java DegreesOfSeparationDFS movies.txt
Source: Bacon, Kevin
Query:  Kidman, Nicole
   Bacon, Kevin
   Mystic River (2003)
   O’Hara, Jenny
   Matchstick Men (2003)
   Grant, Beth
  ... [123 movies ] (!)
   Law, Jude
   Sky Captain... (2004)
   Jolie, Angelina
   Playing by Heart (1998)
   Anderson, Gillian (I)
   Cock and Bull Story, A (2005)
   Henderson, Shirley (I)
   24 Hour Party People (2002)
   Eccleston, Christopher
   Gone in Sixty Seconds (2000)
   Balahoutis, Alexandra
   Days of Thunder (1990)
   Kidman, Nicole
```

**4.1.25**　编写一个类似于 `DegreesOfSeparation` 的 `SymbolGraph` 用例，使用**深度优先搜索**代替广度优先搜索来查找两个演员之间的路径，输出类似右侧框注所示的数据。

**4.1.26**　使用 1.4 节中的内存使用模型评估用 `Graph` 表示一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的图所需的内存。

**4.1.27**　如果重命名一幅图中的顶点就能够使之变得和另一幅图完全相同，这两幅图就是**同构**的。画出含有 2、3、4、5 个顶点的所有非同构的图。

**4.1.28**　修改 `Cycle`，允许图含有自环和平行边。

###提高题

**4.1.29**　**欧拉环**和**汉密尔顿环**。考虑以下 4 组边定义的图：

```
0-1 0-2 0-3 1-3 1-4 2-5 2-9 3-6 4-7 4-8 5-8 5-9 6-7 6-9 7-8
0-1 0-2 0-3 1-3 0-3 2-5 5-6 3-6 4-7 4-8 5-8 5-9 6-7 6-9 8-8
0-1 1-2 1-3 0-3 0-4 2-5 2-9 3-6 4-7 4-8 5-8 5-9 6-7 6-9 7-8
4-1 7-9 6-2 7-3 5-0 0-2 0-8 1-6 3-9 6-3 2-8 1-5 9-8 4-5 4-7
```

　　　哪几幅图含有欧拉环（恰好包含了所有的边且没有重复的环）？哪几幅图含有汉密尔顿环（恰好包含了所有的顶点且没有重复的环）？

**4.1.30**　**图的枚举**。含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边（不含平行边）的不同的无向图共有多少种？

**4.1.31**　**检测平行边**。设计一个线性时间的算法来统计图中的平行边的总数。

**4.1.32**　**奇环**。证明一幅图能够用两种颜色着色（二分图）当且仅当它不含有长度为奇数的环。

**4.1.33**　**符号图**。实现一个 `SymbolGraph`（不一定必须使用 `Graph`），只需要遍历一遍图的定义数据。由于需要查找符号表，实现中图的各种操作时耗可能会变为原来的 ![\log V](https://private.codecogs.com/gif.latex?\log%20V) 倍。

**4.1.34**　**双向连通性**。如果任意一对顶点都能由两条不同（没有重叠的边或顶点）的路径连通则图就是**双向连通**的。在一幅连通图中，如果一个顶点（以及和它相连的边）被删掉后图不再连通，该顶点就被称为**关节点**。证明没有关节点的图是双向连通的。**提示**：给定任意一对顶点 `s` 和 `t` 和一条连接两点的路径，由于路径上没有任何顶点为关节点，构造另一条不同的路径连接 `s` 和 `t`。

**4.1.35**　**边的连通性**。在一幅连通图中，如果一条边被删除后图会被分为两个独立的连通分量，这条边就被称为**桥**。没有桥的图称为**边连通**图。开发一种基于深度优先搜索算法的数据类型，判断一个图是否是边连通图。

**4.1.36**　**欧几里得图**。为平面上的图设计并实现一份叫做 `EuclideanGraph` 的 API，其中图所有顶点均有坐标。实现一个 `show()` 方法，用 `StdDraw` 将图绘出。

**4.1.37**　**图像处理**。在一幅图像中将所有相邻的、颜色相同的点相连就可以得到一幅图，为这种隐式定义的图实现**填充**（flood fill）操作。

###实验题

**4.1.38**　**随机图**。编写一个程序 `ErdosRenyiGraph`，从命令行接受整数 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E)，随机生成 ![E](https://private.codecogs.com/gif.latex?E) 对 0 到 ![V-1](https://private.codecogs.com/gif.latex?V-1) 之间的整数来构造一幅图。**注意**：生成器可能会产生自环和平行边。

**4.1.39**　**随机简单图**。编写一个程序 `RandomSimpleGraph`，从命令行接受整数 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E)，用均等的几率生成含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的所有可能的简单图。

**4.1.40**　**随机稀疏图**。编写一个程序 `RandomSparseGraph`，根据精心选择的一组 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E) 的值生成随机的稀疏图，以便用它对由 Erdös-Renyi 模型得到的图进行有意义的经验性测试。

**4.1.41**　**随机欧几里得图**。编写一个 `EuclideanGraph` 的用例（请见练习 4.1.36）`RandomEuclideanGraph`，用随机在平面上生成 ![V](https://private.codecogs.com/gif.latex?V) 个点的方式生成随机图，然后将每个点和在以该点为中心半径为 ![d](https://private.codecogs.com/gif.latex?d) 的圆内的其他点相连。**注意**：如果 ![d](https://private.codecogs.com/gif.latex?d) 大于阈值 ![\sqrt{{\rm\"u}~V~~\pi~V}](https://private.codecogs.com/gif.latex?\sqrt{{\rm\%22u}~V~~\pi~V})，那么得到的图几乎必然是连通的，否则得到的图几乎必然是不连通的。

**4.1.42**　**随机网格图**。编写一个 `EuclideanGraph` 的用例 `RandomGridGraph`，将 ![\sqrt{V}](https://private.codecogs.com/gif.latex?\sqrt{V}) 乘 ![\sqrt{V}](https://private.codecogs.com/gif.latex?\sqrt{V}) 的网格中的所有顶点和它们的相邻顶点相连（参考练习 1.5.18）。修改代码为图额外添加 ![R](https://private.codecogs.com/gif.latex?R) 条随机的边。对于较大的 ![R](https://private.codecogs.com/gif.latex?R)，缩小网格使得总边数保持在 ![V](https://private.codecogs.com/gif.latex?V) 个左右。添加一个选项，使得出现一条从顶点 `s` 到顶点 `v` 的边的概率与 `s` 到 `t` 的欧几里得距离成反比。

**4.1.43**　**真实世界中的图**。从网上找出一幅巨型加权图——可以是一张标记了距离的地图，或者是标明了费用的电话连接，或是航班价目表。编写一段程序 `RandomRealGraph`，从这幅图中随机迭取 ![V](https://private.codecogs.com/gif.latex?V) 个顶点，然后再从这些顶点构成的子图中随机选取 ![E](https://private.codecogs.com/gif.latex?E) 条边来构造一幅图。

**4.1.44**　**随机区间图**。考虑数轴上的 ![V](https://private.codecogs.com/gif.latex?V) 个区间的集合。这样的一个集合定义了一幅**区间图**，图中的每个顶点都对应一个区间，而边则对应两个区间的交集（大小不限）。编写一段程序，随机生成大小均为 ![d](https://private.codecogs.com/gif.latex?d) 的 ![V](https://private.codecogs.com/gif.latex?V) 个区间，然后构造相应的区间图。**提示**：使用二分查找树。

**4.1.45**　**随机运输图**。定义运输系统的一种方法是定义一个顶点链的集合，每条顶点链都表示一条连接了多个顶点的路径。例如，链 `0-9-3-2` 定义了边 `0-9`、`9-3` 和 `3-2`。编写一个 `EuclideanGraph` 的用例 `RandomTransportation`，从一个输入文件中构造一幅图，文件的每行均为一条链，使用符号名。编辑一份合适的输入使得程序能够从中构造一幅和巴黎地铁系统相对应的图。

>　　测试所有的算法并研究所有图模型的所有参数是不现实的。请为下面的每一道题都编写一段程序来处理从输入得到的任意图。这段程序可以调用上面的任意生成器并对相应的图模型进行实验。可以根据上次实验的结果自己作出判断来选择不同实验。陈述结果以及由此得出的任何结论。

**4.1.46**　**深度优先搜索中的路径长度**。对于各种图的模型，运行实验并根据经验判断 `DepthFirstPaths` 在两个随机选定的顶点之间找到一条路径的概率并计算找到的路径的平均长度。

**4.1.47**　**广度优先搜索中的路径长度**。对于各种图的模型，运行实验并根据经验判断 `BreadthFirstPaths` 在两个随机选定的顶点之间找到一条路径的概率并计算找到的路径的平均长度。

**4.1.48**　**连通分量**。运行实验随机生成大量的图并画出柱状图，根据经验判断各种类型的随机图中连通分量的数量的分布情况。

**4.1.49**　**双色问题**。大多数的图都无法用两种颜色着色，深度优先搜索能够很快发现这一点。对于各种图模型，使用经验性的测试来研究 `TwoColor` 检查的边的数量。

##4.2　有向图

在**有向图**中，边是单向的：每条边所连接的两个顶点都是一个有序对，它们的邻接性是单向的（表 4.2.1）。许多应用（比如表示网络、任务调度条件或是电话的图）都是天然的有向图。为实现添加这种单向性的限制很容易也很自然，看起来没什么坏处。但实际上这种组合性的结构对算法有深刻的影响，使得有向图和无向图的处理大有不同。本节中，我们会学习搜索和处理有向图的一些经典算法。

**表 4.2.1　实际生活中的典型有向图**

|应用|顶点|边|
|-|-|-|
|食物链|物种|捕食关系|
|互联网连接|网页|超链接|
|程序|模块|外部引用|
|手机|电话|呼叫|
|学术研究|论文|引用|
|金融|股票|交易|
|网络|计算机|网络连接|

###4.2.1　术语

虽然我们为有向图的定义和无向图几乎相同（将使用的部分算法和代码也是），但仍然需要在这里重复一遍。为了说明边的方向性而产生的细小文字差异所代表的结构特性正是本节的重点。

>**定义**。一幅有**方向性的图**（或**有向图**）是由一组**顶点**和一组有**方向的边**组成的，每条有方向的边都连接着有序的一对顶点。

我们称一条有向边由第一个顶点**指出**并**指向**第二个顶点。在一幅有向图中，一个顶点的**出度**为由该顶点指出的边的总数；一个顶点的**入度**为指向该顶点的边的总数（请见图 4.2.1）。当上下文的意义明确时，我们在提到有向图中的边时会省略**有向**二字。一条有向边的第一个顶点称为它的**头**，第二个顶点则被称为它的**尾**。将有向边画为由头指向尾的一个箭头。用 `v` → `w` 来表示有向图中一条由 `v` 指向 `w` 的边。和无向图一样，本节的代码也能处理自环和平行边，但它们不会出现在例子中，在正文中一般也不会提到它们。除了特殊的图，一幅有向图中的两个顶点的关系可能有 4 种：没有边相连；存在从 `v` 到 `w` 的边 `v` → `w`；存在从 `w` 到 `v` 的边 `w` → `v`；既存在 `v` → `w` 也存在 `w` → `v`，即双向的连接。

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.034.png)

**图 4.2.1　有向图详解**

>**定义**。在一幅有向图中，**有向路径**由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。**有向环**为一条至少含有一条边且起点和终点相同的有向路径。**简单有向环**是一条（除了起点和终点必须相同之外）不含有重复的顶点和边的环。路径或者环的**长度**即为其中所包含的边数。

和无向图一样，我们假设有向路径都是简单的，除非我们明确指出了某个重复了的顶点（像有向环的定义中那样）或是指明是**一般性**的有向路径。当存在从 `v` 到 `w` 的有向路径时，称顶点 w 能够由顶点 `v` **达到**。我们约定，每个顶点都能够达到它自己。除了这种情况之外，在有向图中由 `v` 能够到达 `w` 并不意味着由 `w` 也能到达 `v`。这个不同虽然很明显但非常重要，后面将会看到这一点。

要理解本节中的算法，你就必须要理解有向图中的可达性和无向图中的连通性的区别。理解这种区别可能比你想象得更困难。例如，尽管你可能一眼就能看出一小幅无向图中的两个顶点之间是否连通，但是在一小幅有向图中快速找出一条有向路径就不那么容易了，比如图 4.2.2 所示的例子。处理有向图就如同在一座只有单行道的城市中穿梭，而且这些单行道的方向是杂乱无章的。在这种情况下，想从一处到达另一处会是一件很麻烦的事。但与直觉相反，我们用来表示有向图的标准数据结构甚至比无向图的表示更加简单！

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.035.png)

**图 4.2.2　在这幅有向图中，从 `v` 能够到达 `w` 吗**

###4.2.2　有向图的数据类型

以下这份 API 以及下一页中的 `Digraph` 类和 `Graph` 类本质上是相同的（请见 4.1.2.2 节框注“`Graph` 数据类型”）。

**表 4.2.2　有向图的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>Digraph</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Digraph(int V)</code></td><td>创建一幅含有 <img src="https://private.codecogs.com/gif.latex?V" /> 个顶点但没有边的有向图</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Digraph(In in)</code></td><td>从输入流 <code>in</code> 中读取一幅有向图</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;V()</code></td><td>顶点总数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;E()</code></td><td>边的总数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;addEdge(int v, int w)</code></td><td>向有向图中添加一条边 <code>v</code> → <code>w</code></td></tr>
<tr><td><code>Iterable&lt;Integer>&nbsp;&nbsp;adj(int v)</code></td><td>由 <code>v</code> 指出的边所连接的所有顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Digraph&nbsp;&nbsp;reverse()</code></td><td>该图的反向图</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>
</table>

####4.2.2.1　有向图的表示

我们使用邻接表来表示有向图，其中边 `v` → `w` 表示为顶点 `v` 所对应的邻接链表中包含一个 `w` 顶点。这种表示方法和无向图几乎相同而且更明晰，因为每条边都只会出现一次，如后面框注“有向图（diagraph）的数据类型”所示。

####4.2.2.2　输入格式

由输入流读取有向图的构造函数的代码与 `Graph` 类中相应构造函数的代码完全相同——因为两者的输入格式是一样的，但所有的边都是有向边。在边列表的格式中，一对顶点 `v` 和 `w` 表示边 `v` → `w`。

####4.2.2.3　有向图取反

`Digraph` 的 API 中还添加了一个方法 `reverse()`。它返回该有向图的一个副本，但将其中所有边的方向反转。在处理有向图时这个方法有时很有用，因为这样用例就可以找出“指向”每个顶点的所有边，而 `adj()` 给出的是由每个顶点**指出**的边所连接的所有顶点。

####4.2.2.4　顶点的符号名

在有向图中，允许用例使用符号作为顶点名也更加简单。要实现与 `SymbolGraph` 类似的 `SymbolDigraph` 类，只需要将其中的 `Graph` 字样都替换成 `Digraph` 即可。

花一点时间对比一下后面框注中的代码和示意图与 4.1.2.1 节及 4.1.2.2 节的框注“`Graph` 数据类型”中无向图的代码是非常有价值的。在用邻接表表示无向图时，如果 `v` 在 `w` 的链表中，那么 `w` 必然也在 `v` 的链表中。但在有向图中这种对称性是不存在的。这个区别在有向图的处理中影响深远。

>**Digraph 数据类型**

>![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.036.png)

>　

>![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.037.png)

>{-:-}有向图的输入格式和邻接表的表示

>`Digraph` 数据类型与 `Graph` 数据类型（请见 4.1.2.2 框注“`Graph` 数据类型”）基本相同，区别是 `addEdge()` 只调用了一次 `add()`，而且它还有一个 `reverse()` 方法来返回图的反向图。因为两者的代码非常相似，所以省略了 `toString()` 方法（请见表 4.1.2）和从输入流中读取图的构造函数。

###4.2.3　有向图中的可达性

在无向图中介绍的第一个算法就是 4.1.3.2 节中的 `DepthFirstSearch`，它解决了单点连通性的问题，使得用例可以判定其他顶点和给定的起点是否连通。使用**完全相同**的代码，将其中的 `Graph` 替换为 `Digraph`，也可以解决一个有向图中的类似问题。

**单点可达性**。给定一幅有向图和一个起点 `s`，回答“**是否存在一条从 `s` 到达给定顶点 `v` 的有向路径？**”等类似问题。

算法 4.4 中的 `DirectedDFS` 类将 `DepthFirstSearch` 稍加润色并实现了以下 API。

**表 4.2.3　有向图的可达性 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>DirectedDFS</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirectedDFS(Digraph G, int s)</code></td><td>在 <code>G</code> 中找到从 <code>s</code> 可达的所有顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirectedDFS(Digraph G, Iterable&lt;Integer> sources)</code></td><td>在 <code>G</code> 中找到从 <code>sources</code> 中的所有顶点可达的所有顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;marked(int v)</code></td><td><code>v</code> 是可达的吗</td></tr>
</table>

在添加了一个接受多个顶点的构造函数之后，这份 API 使得用例能够解决一个更加一般的问题。

**多点可达性**。给定一幅有向图和顶点的**集合**，回答“**是否存在一条从集合中的任意顶点到达给定顶点 `v` 的有向路径？**”等类似问题。

我们在 5.4 节中解决经典的字符串处理问题时会再次遇到这个问题。

`DirectedDFS` 使用了解决图处理的标准范例和标准的深度优先搜索来解决这些问题。它对每个起点调用递归方法 `dfs()`，以标记遇到的任意顶点。

>**命题 D**。在有向图中，深度优先搜索标记由一个集合的顶点可达的所有顶点所需的时间与被标记的所有顶点的出度之和成正比。

>**证明**。同 4.1.3.2 节的命题A。

图 4.2.3 显示了这个算法在处理示例有向图时的操作轨迹。这份轨迹比相应的无向图算法的轨迹稍稍简单些，因为深度优先搜索本质上是一种适用于处理有向图的算法，每条边都只会被表示一次。研究这些轨迹有助于巩固你对有向图中深度优先搜索的理解。

![{73%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.038.png)

**图 4.2.3　使用深度优先搜索在一幅有向图中寻找能够从顶点 `0` 到达的所有顶点的轨迹**

>**算法 4.4　有向图的可达性**

>```
>public class DirectedDFS
>{
>    private boolean[] marked;
>
>    public DirectedDFS(Digraph G, int s)
>    {
>       marked = new boolean[G.V()];
>       dfs(G, s);
>    }
>
>    public DirectedDFS(Digraph G, Iterable<Integer> sources)
>    {
>       marked = new boolean[G.V()];
>       for (int s : sources)
>          if (!marked[s]) dfs(G, s);
>
>
>    }
>    private void dfs(Digraph G, int v)
>    {
>       marked[v] = true;
>       for (int w : G.adj(v))
>          if (!marked[w]) dfs(G, w);
>    }
>
>    public boolean marked(int v)
>    {  return marked[v];  }
>
>    public static void main(String[] args)
>    {
>       Digraph G = new Digraph(new In(args[0]));
>
>       Bag<Integer> sources = new Bag<Integer>();
>       for (int i = 1; i < args.length; i++)
>          sources.add(Integer.parseInt(args[i]));
>
>       DirectedDFS reachable = new DirectedDFS(G, sources);
>
>       for (int v = 0; v < G.V(); v++)
>          if (reachable.marked(v)) StdOut.print(v + " ");
>       StdOut.println();
>    }
>}
>```

>　

>```
>% java DirectedDFS tinyDG.txt 1
>1
>
>% java DirectedDFS tinyDG.txt 2
>0 1 2 3 4 5
>
>% java DirectedDFS tinyDG.txt 1 2 6
>0 1 2 3 4 5 6 9 10 11 12
>```

>这份深度优先搜索的实现使得用例能够判断从给定的一个或者一组顶点能到达哪些其他顶点。

####4.2.3.1　标记 - 清除的垃圾收集

多点可达性的一个重要的实际应用是在典型的内存管理系统中，包括许多 Java 的实现。在一幅有向图中，一个顶点表示一个对象，一条边则表示一个对象对另一个对象的引用。这个模型很好地表现了运行中的 Java 程序的内存使用状况。在程序执行的任何时候都有某些对象是可以被直接访问的，而不能通过这些对象访问到的所有对象都应该被回收以便释放内存（请见图 4.2.4）。标记 - 清除的垃圾回收策略会为每个对象保留一个位做垃圾收集之用。它会周期性地运行一个类似于 `DirectedDFS` 的有向图可达性算法来标记所有可以被访问到的对象，然后**清理**所有对象，回收没有被标记的对象，以腾出内存供新的对象使用。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.039.png)

**图 4.2.4　垃圾回收示意图**

####4.2.3.2　有向图的寻路

`DepthFirstPaths`（4.1.4.1 节算法 4.1）和 `BreadthFirstPaths`（4.1.5 节算法 4.2）也都是有向图处理中的重要算法。和刚才一样，同样的 API 和代码（仅将 `Graph` 替换为 `Digraph`）也能够高效地解决以下问题。

**单点有向路径**。给定一幅有向图和一个起点 `s`，回答“**从 `s` 到给定目的顶点 `v` 是否存在一条有向路径？**如果有，找出这条路径。”等类似问题。

**单点最短有向路径**。给定一幅有向图和一个起点 `s`，回答“**从 `s` 到给定目的顶点 `v` 是否存在一条有向路径？**如果有，找出其中最短的那条（所含边数最少）。”等类似问题。

在本书的网站上以及本节最后的练习中，我们将以上问题的答案分别命名为 `DepthFirstDirectedPaths` 和 `BreadthFirstDirectedPaths`。

###4.2.4　环和有向无环图

在和有向图相关的实际应用中，有向环特别的重要。没有计算机的帮助，在一幅普通的有向图中找出有向环可能会很困难。从原则上来说，一幅有向图可能含有大量的环；在实际应用中，我们一般只会重点关注其中一小部分，或者只想知道它们是否存在（请见图 4.2.5）。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.040.png)

**图 4.2.5　这幅有向图含有有向环吗**

为了在有向图处理中研究有向环的作用更加有趣，我们来看看下面这个有向图模型的原型应用。

####4.2.4.1　调度问题

一种应用广泛的模型是给定一组任务并安排它们的执行顺序，限制条件是这些任务的执行方法和起始时间。限制条件还可能包括任务的时耗以及消耗的其他资源。最重要的一种限制条件叫做**优先级限制**，它指明了哪些任务必须在哪些任务之前完成。不同类型的限制条件会产生不同类型不同难度的调度问题。研究者已经解决了上千种不同的此类问题，而且还在为其中许多寻找更好的算法。以一个正在安排课程的大学生为例，有些课程是其他课程的先导课程，如图 4.2.6 所示。

![{93%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.041.png)

**图 4.2.6　有优先级限制的调度问题**

如果再假设该学生一次只能修一门课，实际上就遇到了下面这个问题。

**优先级限制下的调度问题**。给定一组需要完成的任务，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何安排并完成所有任务？

对于任意一个这样的问题，我们都可以马上画出一张有向图，其中顶点对应任务，有向边对应优先级顺序。为了简化问题，我们以使用整数为顶点编号的标准模型来表示这个示例，如图 4.2.7 所示。在有向图中，优先级限制下的调度问题等价于下面这个基本的问题。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.042.png)

**图 4.2.7　标准有向图模型**

**拓扑排序**。给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素（或者说明无法做到这一点）。

图 4.2.8 为示例的拓扑排序。所有的边都是向下的，所以它清晰地表示了这幅有向图模型所代表的有优先级限制的调度问题的一个解决方法：按照这个顺序，该同学可以在满足先导课程限制的条件下修完所有课程。这个应用是很典型的——表 4.2.4 列举了其他一些有代表性的应用。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.043.png)

**图 4.2.8　拓扑排序**

**表 4.2.4　拓扑排序的典型应用**

|应用|顶点|边|
|-|-|-|
|任务调度|任务|优先级限制|
|课程安排|课程|先导课程限制|
|继承|Java 类|`extends`关系|
|电子表格|单元格（cell）|公式|
|符号链接|文件名|链接|

####4.2.4.2　有向图中的环

如果任务 x 必须在任务 y 之前完成，而任务 y 必须在任务 z 之前完成，但任务 z 又必须在任务 x 之前完成，那肯定是有人搞错了，因为这三个限制条件是不可能被同时满足的。一般来说，如果一个有优先级限制的问题中存在有向环，那么这个问题肯定是无解的。要检查这种错误，需要解决下面这个问题。

**有向环检测**。给定的有向图中包含有向环吗？如果有，按照路径的方向从某个顶点并返回自己来找到环上的所有顶点。

一幅有向图中含有的环的数量可能是图的大小的指数级别（请见练习 4.2.11），因此我们只需要找出一个环即可，而不是所有环。在任务调度和其他许多实际问题中不允许出现有向环，因此不含有环的有向图就变得很特殊。

>**定义**。**有向无环图**（DAG）就是一幅不含有向环的有向图。

因此，解决有向环检测的问题可以回答下面这个问题：**一幅有向图是有向无环图吗**？基于深度优先搜索来解决这个问题并不困难，因为由系统维护的递归调用的栈表示的正是“当前”正在遍历的有向路径（就好像用 Tremaux 方法探索迷宫时的那条绳子一样）。一旦我们找到了一条有向边 `v` → `w` 且 `w` 已经存在于栈中，就找到了一个环，因为栈表示的是一条由 `w` 到 `v` 的有向路径，而 `v` → `w` 正好补全了这个环。同时，如果没有找到**这样的边**，那就意味着这幅有向图是无环的，见图 4.2.9。请见后面框注“寻找有向环”，该框注中的 `DirectedCycle` 基于这个思想实现了表 4.2.5 中的 API。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.044.png)

**图 4.2.9　在一幅有向图中寻找环**

**表 4.2.5　有向环的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>DirectedCycle</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirectedCycle(Digraph G)</code></td><td>寻找有向环的构造函数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;hasCycle()</code></td><td><code>G</code> 是否含有有向环</td></tr>
<tr><td><code>Iterable&lt;Integer>&nbsp;&nbsp;cycle()</code></td><td>有向环中的所有顶点（如果存在的话）</td></tr>
</table>

>**寻找有向环**

>![{68%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.045.png)

>　

>![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.046.png)

>{-:-}有向环检测的轨迹

>该类为标准的递归 `dfs()` 方法添加了一个布尔类型的数组 `onStack[]` 来保存递归调用期间栈上的所有顶点。当它找到一条边 `v` → `w` 且 `w` 在栈中时，它就找到了一个有向环。环上的所有顶点可以通过 `edgeTo[]` 中的链接得到。

在执行 `dfs(G,v)` 时，查找的是一条由起点到 `v` 的有向路径。要保存这条路径，`DirectedCycle` 维护了一个由顶点索引的数组 `onStack[]`，以标记递归调用的栈上的所有顶点（在调用 `dfs(G,v)` 时将 `onStack[v]` 设为 `true`，在调用结束时将其设为 `false`）。`DirectedCycle` 同时也使用了一个 `edgeTo[]` 数组，在找到有向环时返回环中的所有顶点，方法和 `DepthFirstPaths`（请见算法 4.1）以及 `BreadthFirstPaths`（请见算法 4.2）相同。

####4.2.4.3　顶点的深度优先次序与拓扑排序

优先级限制下的调度问题等价于计算有向无环图中的所有顶点的拓扑顺序，因此有表 4.2.6 所示的 API。

**表 4.2.6　拓扑排序的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>Topological</b></code>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Topological(Digraph G)</code></td><td>拓扑排序的构造函数
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isDAG()</code></td><td><code>G</code> 是有向无环图吗
<tr><td><code>Iterable&lt;Integer>&nbsp;&nbsp;order()</code></td><td>拓扑有序的所有顶点
</table>

>**命题 E**。当且仅当一幅有向图是无环图时它才能进行拓扑排序。

>**证明**。如果一幅有向图含有一个环，它就不可能是拓扑有序的。与此相反，我们将要学习的算法能够计算任意有向无环图的拓扑顺序。

值得注意的是，实际上我们已经见过一种拓扑排序的算法：只要添加一行代码，标准深度优先搜索程序就能完成这项任务！要做到这一点，我们先来看看后面框注“有向图中基于深度优先搜索的顶点排序”的 `DepthFirstOrder` 类。它的基本思想是深度优先搜索正好只会访问每个顶点一次。如果将 `dfs()` 的参数顶点保存在一个数据结构中，遍历这个数据结构实际上就能访问图中的所有顶点，遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。在典型的应用中，人们感兴趣的是顶点的以下 3 种排列顺序。

* 前序：在递归调用之前将顶点加入队列。
* 后序：在递归调用之后将顶点加入队列。
* 逆后序：在递归调用之后将顶点压入栈。

图 4.2.10 所示的是用 `DepthFirstOrder` 处理示例有向无环图所产生的轨迹。它的实现简单，支持在图的高级处理算法中十分有用的 `pre()`、`post()` 和 `reversePost()` 方法。例如，`Topological` 类中的 `order()` 方法就调用了 `reversePost()` 方法。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.047.png)

**图 4.2.10　计算有向图中顶点的深度优先次序（前序、后序和逆后序）**

>**有向图中基于深度优先搜索的顶点排序**

>![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.048.png)

>该类允许用例用各种顺序遍历深度优先搜索经过的所有顶点。这在高级的有向图处理算法中非常有用，因为搜索的递归性使得我们能够证明这段计算的许多性质（例如命题 F）。

　

>**算法 4.5　拓扑排序**

>```
>public class Topological
>{
>    private Iterable<Integer> order;       // 顶点的拓扑顺序
>
>    public Topological(Digraph G)
>    {
>       DirectedCycle cyclefinder = new DirectedCycle(G);
>       if (!cyclefinder.hasCycle())
>
>       {
>          DepthFirstOrder dfs = new DepthFirstOrder(G);
>
>          order = dfs.reversePost();
>       }
>    }
>
>    public Iterable<Integer> order()
>    {  return order;  }
>    public boolean isDAG()
>    {  return order != null;  }
>
>    public static void main(String[] args)
>
>    {
>       String filename = args[0];
>       String separator = args[1];
>       SymbolDigraph sg = new SymbolDigraph(filename, separator);
>
>       Topological top = new Topological(sg.G());
>
>       for (int v : top.order())
>          StdOut.println(sg.name(v));
>    }
>
>}
>```

>这段代码使用了 `DepthFirstOrder` 类和 `DirectedCycle` 类来返回一幅有向无环图的拓扑排序。其中的测试代码解决了一幅 `SymbolDigraph` 中有优先级限制的调度问题。在给定的有向图包含环时，`order()` 方法会返回 `null`，否则会返回一个能够给出拓扑有序的所有顶点的迭代器。这里省略了关于 `SymbolDigraph` 的代码，因为它和 `SymbolGraph`（请见第 356 页）的代码几乎完全相同，只需把所有的 `Graph` 替换为 `Digraph` 即可。

　

>**命题 F**。一幅有向无环图的拓扑顺序即为所有顶点的逆后序排列。

>**证明**。对于任意边 `v` → `w`，在调用 `dfs(v)` 时，下面三种情况必有其一成立（请见图 4.2.11）。

>* `dfs(w)` 已经被调用过且已经返回了（`w` 已经被标记）。
>* `dfs(w)` 还没有被调用（`w` 还未被标记），因此 `v` → `w` 会直接或间接调用并返回 `dfs(w)`，且 `dfs(w)` 会在 `dfs(v)` 返回前返回。
>* `dfs(w)` 已经被调用但还未返回。证明的关键在于，在有向无环图中这种情况是不可能出现的，这是由于递归调用链意味着存在从 `w` 到 `v` 的路径，但存在 `v` → `w` 则表示存在一个环。

>在两种可能的情况中，`dfs(w)` 都会在 `dfs(v)` 之前完成，因此在后序排列中 `w` 排在 `v` **之前**而在逆后序中 `w` 排在 `v` **之后**。因此任意一条边 `v` → `w` 都如我们所愿地从排名较前顶点指向排名较后的顶点。

```
% more jobs.txt
Algorithms/Theoretical CS/Databases/Scientific Computing
Introduction to CS/Advanced Programming/Algorithms
Advanced Programming/Scientific Computing
Scientific Computing/Computational Biology
Theoretical CS/Computational Biology/Artificial Intelligence
Linear Algebra/Theoretical CS
Calculus/Linear Algebra
Artificial Intelligence/Neural Networks/Robotics/Machine Learning
Machine Learning/Neural Networks

% java Topological jobs.txt "/"
Calculus
Linear Algebra
Introduction to CS
Advanced Programming
Algorithms
Theoretical CS
Artificial Intelligence
Robotics
Machine Learning
Neural Networks
Databases
Scientific Computing
Computational Biology
```

`Topological` 类（请见算法 4.5）的实现使用了深度优先搜索来对有向无环图进行拓扑排序。图 4.2.11 为排序的轨迹。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.049.png)

**图 4.2.11　有向无环图的逆后序是拓扑排序**

>**命题 G**。使用深度优先搜索对有向无环图进行拓扑排序所需的时间和 ![V+E](https://private.codecogs.com/gif.latex?V+E) 成正比。

>**证明**。由代码可知，第一遍深度优先搜索保证了不存在有向环，第二遍深度优先搜索产生了顶点的逆后序排列。两次搜索都访问了所有的顶点和所有的边，因此它所需的时间和 ![V+E](https://private.codecogs.com/gif.latex?V+E) 成正比。

尽管算法很简单，但是它被忽略了很多年，比它更流行的是一种使用队列储存顶点的更加直观的算法。（请见练习 4.2.30）

在实际应用中，拓扑排序和有向环的检测总会一起出现，因为有向环的检测是排序的前提。例如，在一个任务调度应用中，无论计划如何安排，其背后的有向图中包含的环意味着存在一个必须被纠正的严重错误。因此，解决任务调度类应用通常需要以下 3 步：

* 指明任务和优先级条件；
* 不断检测并去除有向图中的所有环，以确保存在可行方案的；
* 使用拓扑排序解决调度问题。

类似地，调度方案的任何变动之后都需要再次检查是否存在环（使用 `DirectedCycle` 类），然后再计算新的调度安排（使用 `Topological` 类）。

###4.2.5　有向图中的强连通性

在前文中，我们仔细区别了有向图中的可达性和无向图中的连通性。在一幅无向图中，如果有一条路径连接顶点 `v` 和 `w`，则它们就是连通的——既可以由这条路径从 `w` 到达 `v`，也可以从 `v` 到达 `w`。相反，在一幅有向图中，如果从顶点 `v` 有一条有向路径到达 `w`，则顶点 `w` 是从顶点 `v` 可达的，但从 `w` 到达 `v` 的路径可能存在也可能不存在。在对有向图的研究中，我们也会考虑与无向图中的连通性类似的一个问题。

>**定义**。如果两个顶点 `v` 和 `w` 是互相可达的，则称它们为**强连通**的。也就是说，既存在一条从 `v` 到 `w` 的有向路径，也存在一条从 `w` 到 `v` 的有向路径。如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是**强连通**的。

图 4.2.12 给出了几个强连通图的例子。从这些例子中你可以看到，环在强连通性的理解上起着重要的作用。事实上，回忆一下一条普通的有向环可能含有重复的顶点就很容易知道，**两个顶点是强连通的当且仅当它们都在一个普通的有向环中**（**证明**：画出从 `v` 到 `w` 和从 `w` 到 `v` 的路径即可）。

![{30%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.050.png)

**图 4.2.12　强连通的有向图**

####4.2.5.1　强连通分量

和无向图中的连通性一样，有向图中的强连通性也是一种顶点之间等价关系，因为它有着以下性质。

* **自反性**：任意顶点 `v` 和自己都是强连通的。
* **对称性**：如果 `v` 和 `w` 是强连通的，那么 `w` 和 `v` 也是强连通的。
* **传递性**：如果 `v` 和 `w` 是强连通的且 `w` 和 `x` 也是强连通的，那么 `v` 和 `x` 也是强连通的。

作为一种等价关系，强连通性将所有顶点分为了一些等价类，每个等价类都是由相互均为强连通的顶点的最大子集组成的。我们将这些子集称为**强连通分量**，请见图 4.2.13。样图 tinyDG.txt 含有 5 个强连通分量。一个含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点的有向图含有 ![1\sim V](https://private.codecogs.com/gif.latex?1\sim%20V) 个强连通分量——一个强连通图只含有一个强连通分量，而一个有向无环图中则含有 ![V](https://private.codecogs.com/gif.latex?V) 个强连通分量。需要注意的是强连通分量的定义是基于顶点的，而非边。有些边连接的两个顶点都在同一个强连通分量中，而有些边连接的两个顶点则在不同的强连通分量中。后者不会出现在任何有向环之中。与识别连通分量在无向图中的重要性一样，在有向图的处理中识别强连通分量也是非常重要的。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.051.png)

**图 4.2.13　一幅有向图和它的强连通分量**

####4.2.5.2　应用举例

在理解有向图的结构时，强连通性是一种非常重要的抽象，它突出了相互关联的几组顶点（强连通分量）。例如，强连通分量能够帮助教科书的作者决定哪些话题应该被归为一类，或帮助程序员组织程序的模块（请见表 4.2.7）。图 4.2.14 是一个生态学的例子。这幅有向图描绘的是各种生物之间的食物链模型，其中顶点表示物种，而从一个顶点指向另一个顶点的一条边则表示指向顶点的物种对指出顶点的物种的捕食关系。这些有向图（其中物种和捕食关系都是经过仔细选择和研究的）的科学研究有效地帮助了生态学家解决生态系统中的一些基本问题。这种有向图中的强连通分量能够帮助生态学家理解食物链中能量的流动。图 4.2.17 所示的是一张表示网络内容的有向图，其中顶点表示网页，而边表示从一个页面指向另一个页面的超链接。在这样一幅有向图中，强连通分量能够帮助网络工程师将网络中数量庞大的网页分为多个大小可以接受的部分分别进行处理。练习和本书的网站会涉及这些应用和其他例子的更多性质。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.052.png)

**图 4.2.14 一幅表示食物链的有向图的一小部分**

>**表 4.2.7　强连通分量的典型应用**

|应用|顶点|边|
|-|-|-|
|网络|网页|超链接|
|教科书|话题|引用|
|软件|模块|调用|
|食物链|物种|捕食关系|

因此，在有向图中我们也需要表 4.2.8 所列的这份和 `CC`（请见表 4.1.6）类似的 API。

**表 4.2.8　强连通分量的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>SCC</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCC(Digraph G)</code></td><td>预处理构造函数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;stronglyConnected(int v, int w)</code></td><td><code>v</code> 和 <code>w</code> 是强连通的吗</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;count()</code></td><td>图中的强连通分量的总数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;id(int v)</code></td><td><code>v</code> 所在的强连通分量的标识符（ 在 <code>0</code> 至 <code>count()-1</code> 之间）</td></tr>
</table>

设计一种平方级别的算法来计算强连通分量（请见练习 4.2.23）并不困难，但（和以前一样）对于处理在实际应用中经常遇到的像刚才示例所示的大型有向图来说，平方级别的时间和空间需求是不可接受的。

####4.2.5.3　Kosaraju 算法

我们在 `CC`（请见算法 4.3）中看到过，计算无向图中的连通分量只是深度优先搜索的一个简单应用。那么在有向图中应该如何高效地计算强连通分量呢？令人惊讶的是，算法 4.6 中的 `KosarajuCC` 的实现只为 `CC` 添加了几行代码就做到了这一点，它将会完成以下任务（请见图 4.2.15）。

* 在给定的一幅有向图 ![G](https://private.codecogs.com/gif.latex?G) 中，使用 `DepthFirstOrder` 来计算它的反向图 ![G^{{\rm R}}](https://private.codecogs.com/gif.latex?G^{{\rm%20R}}) 的逆后序排列。
* 在 ![G](https://private.codecogs.com/gif.latex?G) 中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的顺序来访问所有未被标记的顶点。
* 在构造函数中，所有在同一个递归 `dfs()` 调用中被访问到的顶点都在同一个**强连通分量**中，将它们按照和 `CC` 相同的方式识别出来。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.053.png)

**图 4.2.15　Kosaraju 算法的正确性证明**

>**算法 4.6　计算强连通分量的 Kosaraju 算法**

>![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.054.png)

>　

>```
>% java KosarajuSCC tinyDG.txt
>5 components
>1
>5 4 3 2 0
>12 11 10 9
>6
>8 7
>```

>突出显示的代码是这份实现和 `CC`（请见算法 4.3）仅有的不同之处（还需要将 4.1.6.1 节中用到的 `main()` 函数中的 `Graph` 替换为 `Digraph`，`CC` 替换为 `KosarajuSCC`）。为了找到所有强连通分量，它会在反向图中进行深度优先搜索来将顶点排序（搜索顺序的逆后序），在给定有向图中用这个顺序再进行一次深度优先搜索。

Kosaraju 算法是一个典型示例，这个方法容易实现但难以理解。尽管它有些神秘，但如果你能一步一步地理解下面这个命题的证明并参考图 4.2.15，那你一定可以理解这个算法的正确性。

>**命题 H**。使用深度优先搜索查找给定有向图 ![G](https://private.codecogs.com/gif.latex?G) 的反向图 ![G^{{\rm R}}](https://private.codecogs.com/gif.latex?G^{{\rm%20R}})，根据由此得到的所有顶点的逆后序再次用深度优先搜索处理有向图 ![G](https://private.codecogs.com/gif.latex?G)（Kosaraju 算法），其构造函数中的每一次递归调用所标记的顶点都在同一个强连通分量之中。

>**证明**。首先要用反证法证明“**每个和 `s` 强连通的顶点 `v` 都会在构造函数调用的 `dfs(G,s)` 中被访问到**”。假设有一个和 `s` 强连通的顶点 `v` 不会在构造函数调用的 `dfs(G,s)` 中被访问到。因为存在从 `s` 到 `v` 的路径，所以 `v` 肯定在之前就已经被标记过了。但是，因为也存在从 `v` 到 `s` 的路径，在 `dfs(G,v)` 调用中 `s` 肯定会被标记，因此构造函数应该是不会调用 `dfs(G,s)` 的。矛盾。

>其次，要证明“**构造函数调用的 `dfs(G,s)` 所到达的任意顶点 `v` 都必然是和 `s` 强连通的**”。设 `v` 为 `dfs(G,s)` 到达的某个顶点。那么，![G](https://private.codecogs.com/gif.latex?G) 中必然存在一条从 `s` 到 `v` 的路径，因此只需要证明 ![G](https://private.codecogs.com/gif.latex?G) 中还存在一条从 `v` 到 `s` 的路径即可。这也等价于 ![G^{{\rm R}}](https://private.codecogs.com/gif.latex?G^{{\rm%20R}}) 中存在一条从 `s` 到 `v` 的路径，因此只需要证明在 ![G^{{\rm R}}](https://private.codecogs.com/gif.latex?G^{{\rm%20R}}) 中存在一条从 `s` 到 `v` 的路径即可。

>证明的核心在于，按照逆后序进行的深度优先搜索意味着，在 ![G^{{\rm R}}](https://private.codecogs.com/gif.latex?G^{{\rm%20R}}) 中进行的深度优先搜索中，`dfs(G,v)` 必然在 `dfs(G,s)` 之前就已经结束了，这样 `dfs(G,v)` 的调用就只会出现两种情况：

>* 调用在 `dfs(G,s)` 的调用之前（并且也在 `dfs(G,s)` 的调用之前结束）；
>* 调用在 `dfs(G,s)` 的调用之后（并且也在 `dfs(G,s)` 的结束之前结束）。

>第一种情况是不可能出现的，因为在 ![G^{{\rm R}}](https://private.codecogs.com/gif.latex?G^{{\rm%20R}}) 中存在一条从 `v` 到 `s` 的路径；而第二种情况则说明 ![G^{{\rm R}}](https://private.codecogs.com/gif.latex?G^{{\rm%20R}}) 中存在一条从 `s` 到 `v` 的路径。证毕。

图 4.2.16 所示为 Kosaraju 算法处理 tinyDG.txt 时的轨迹。在每次 `dfs()` 调用轨迹的右侧都是有向图的一种画法，顶点按照搜索结束的顺序排列。因此，从下往上来看左侧这幅有向图的反向图得到的就是所有顶点的逆后序，也就是在原始的有向图中进行深度优先搜索时所有未被标记的顶点被检查的顺序。你可以从图中看到，在第二遍深度优先搜索中，首先调用的是 `dfs(1)`（标记顶点 `1`），然后调用的是 `dfs(0)`（标记顶点 `0`、`5`、`4`、`3` 和 `2`），然后检查了顶点 `2`、`4`、`5` 和 `3`，再调用 `dfs(11)`（标记顶点 `11`、`12`、`9` 和 `10`），在检查了 `9`、`12` 和 `10` 之后调用 `dfs(6)`（标记顶点 `6`），最后调用 `dfs(7)` 标记了顶点 `7` 和 `8`。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.055.png)

**图 4.2.16　在有向图中寻找强连通分量的 Kosaraju 算法**

图 4.2.17 中所示的是一个更大的示例，也是 Web 的有向图模型的一个非常小的部分。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.056.png)

**图 4.2.17　这幅有向图中含有多少个强连通分量**

我们在第 1 章已经介绍过 Kosaraju 算法并在 4.1 节中再次使用该算法解决了无向图的连通性问题。Kosaraju 算法也解决了有向图中的类似问题。

**强连通性**。给定一幅有向图，回答“**给定的两个顶点是强连通的吗？这幅有向图中含有多少个强连通分量？**”等类似问题。

我们能否用和无向图相同的效率解决有向图的连通性问题？这个问题已经被研究了很长时间了（R.E.Tarjan 在 20 世纪 70 年代末解决了这个问题）。这样一个简单的解决方法实在令人惊讶。

>**命题 I**。Kosaraju 算法的预处理所需的时间和空间与 ![V+E](https://private.codecogs.com/gif.latex?V+E) 成正比且支持常数时间的有向图强连通性的查询。

>**证明**。该算法会处理有向图的反向图并进行两次深度优先搜索。这3步所需的时间都与 ![V+E](https://private.codecogs.com/gif.latex?V+E) 成正比。反向复制一幅有向图所需的空间与 ![V+E](https://private.codecogs.com/gif.latex?V+E) 成正比。

####4.2.5.4　再谈可达性

根据 `CC` 类我们可以知道，在无向图中如果两个顶点 `v` 和 `w` 是连通的，那么就既存在一条从 `v` 到 `w` 的路径也存在一条从 `w` 到 `v` 的路径。根据 `KosarajuSCC` 类可知，在有向图中如果两个顶点 `v` 和 `w` 是强连通的，那么也既存在一条从 `v` 到 `w` 的路径也存在（另）一条从 `w` 到 `v` 的路径。但对于一对非强连通的顶点呢？也许存在一条从 `v` 到 `w` 的路径，也许存在一条从 `w` 到 `v` 的路径，也许两条都不存在，但不可能两条都存在。

**顶点对的可达性**。给定一幅有向图，回答“**是否存在一条从一个给定的顶点 `v` 到另一个给定的顶点 `w` 的路径？**”等类似问题。

对于无向图，这个问题等价于连通性问题；对于有向图，它和强连通性的问题有很大区别。`CC` 实现需要线性级别的预处理时间才能支持常数时间的查询操作。我们能够在有向图的相应实现中达到这样的性能吗？这个看似简单的问题困扰了专家数十年。为了更好地理解这个问题，我们来看看图 4.2.18。它展示了下面这个基本的概念。

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.057.png)

**图 4.2.18　传递闭包**

>**定义**。有向图 ![G](https://private.codecogs.com/gif.latex?G) 的传递闭包是由相同的一组顶点组成的另一幅有向图，在传递闭包中存在一条从 `v` 指向 `w` 的边当且仅当在 ![G](https://private.codecogs.com/gif.latex?G) 中 `w` 是从 `v` 可达的。

根据约定，每个顶点对于自己都是可达的，因此传递闭包会含有 ![V](https://private.codecogs.com/gif.latex?V) 个自环。示例有向图只有 22 条有向边，但它的传递闭包含有可能的 169 条有向边中的 102 条。一般来说，一幅有向图的传递闭包中所含的边都比原图中多得多，一幅稀疏图的传递闭包却是一幅稠密图也是很常见的。例如，含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![V](https://private.codecogs.com/gif.latex?V) 条边的有向环的传递闭包是一幅含有 ![V^2](https://private.codecogs.com/gif.latex?V^2) 条边的有向完全图。因为传递闭包一般都很稠密，我们通常都将它们表示为一个布尔值矩阵，其中 `v` 行 `w` 列的值为 `true` 当且仅当 `w` 是从 `v` 可达的。与其明确计算一幅有向图的传递闭包，不如使用深度优先搜索来实现表 4.2.9 中的 API。

**表 4.2.9　顶点对可达性的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>TransitiveClosure</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransitiveClosure(Digraph G)</code></td><td>预处理的构造函数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;reachable(int v, int w)</code></td><td><code>w</code> 是从 <code>v</code> 可达的吗</td></tr>
</table>

下页框注中的代码使用 `DirectedDFS`（请见算法 4.4）简单明了地实现了它。无论对于稀疏还是稠密的图，它都是理想解决方案，但它不适用于在实际应用中可能遇到的大型有向图，因为**构造函数所需的空间和 ![V^2](https://private.codecogs.com/gif.latex?V^2) 成正比，所需的时间和 ![V(V+E)](https://private.codecogs.com/gif.latex?V(V+E%29) 成正比**：共有 ![V](https://private.codecogs.com/gif.latex?V) 个 `DirectedDFS` 对象，每个所需的空间都与 ![V](https://private.codecogs.com/gif.latex?V) 成正比（它们都含有大小为 ![V](https://private.codecogs.com/gif.latex?V) 的 `marked[]` 数组并会检查 ![E](https://private.codecogs.com/gif.latex?E) 条边来计算标记）。本质上，`TransitiveClosure` 通过计算 ![G](https://private.codecogs.com/gif.latex?G) 的传递闭包来支持常数时间的查询——传递闭包矩阵中的第 ![v](https://private.codecogs.com/gif.latex?v) 行就是 `TransitiveClosure` 类中的 `DirectedDFS[]` 数组的第 `v` 个元素的 `marked[]` 数组。我们能够大幅度减少预处理所需的时间和空间同时又保证常数时间的查询吗？用远小于平方级别的空间支持常数级别的查询的一般解决方案仍然是一个有待解决的研究问题，并且有重要的实际意义：例如，除非这个问题得到解决，对于像代表互联网这样的巨型有向图，否则无法有效解决其中的顶点对可达性问题。

```
public class TransitiveClosure
{
   private DirectedDFS[] all;
   TransitiveClosure(Digraph G)
   {
      all = new DirectedDFS[G.V()];
      for (int v = 0; v < G.V(); v++)
         all[v] = new DirectedDFS(G, v);
   }

   boolean reachable(int v, int w)
   {  return all[v].marked(w);  }
}
```

{-:-}顶点对的可达性

###4.2.6　总结

在本节中，我们介绍了有向边和有向图并强调了有向图处理算法和无向图处理中相应算法的关系，涵盖了以下几个方面：

* 有向图的术语；
* 有向图的表示和算法在本质上和无向图是相同的，但部分有向图问题更加复杂；
* 有向环、有向无环图、拓扑排序和优先级限制下的调度问题；
* 有向图的可达性、路径和强连通性。

表 4.2.10 总结了我们已经学过的各种有向图算法的实现（只有一个算法不基于深度优先搜索）。这些问题的描述都很简单，但它们的解决方法有的仅仅简单改造了无向图中的相应问题的处理算法，有的却非常巧妙。这些算法是 4.4 节更加复杂的算法的基础，在 4.4 节我们将学习加权有向图。

**表 4.2.10　本节中得到解决的有向图处理问题**

|问题|解决方法|参阅|
|-|-|-|
|单点和多点的可达性|`DirectedDFS`|算法 4.4|
|单点有向路径|`DepthFirstDirectedPaths`|4.2.3.2|
|单点最短有向路径|`BreadthFirstDirectedPaths`|4.2.3.2|
|有向环检测|`DirectedCycle`|4.2.4.2 框注“寻找有向环”|
|深度优先的顶点排序|`DepthFirstOrder`|4.2.4.2 框注“有向图中基于深度优先搜索的顶点排序”|
|优先级限制下的调度问题|`Topological`|算法 4.5|
|拓扑排序|`Topological`|算法 4.5|
|强连通性|`KosarajuSCC`|算法 4.6|
|顶点对的可达性|`TransitiveClosure`|4.2.5.4 节|

###答疑

**问**　自环是一个环吗？

**答**　是的，但没有自环的顶点对于自己也是可达的。

###练习

**4.2.1**　一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点且没有平行边的有向图中最多可能含有多少条边？一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点且没有孤立顶点的有向图中最少需要多少条边？

**4.2.2**　按照正文中示意图的样式（请见图 4.1.9）画出 `Digraph` 的构造函数在处理图 4.2.19 的 tinyDGex2.txt 时构造的邻接表。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.058.png)

**图　4.2.19**

**4.2.3**　为 `Digraph` 添加一个构造函数，它接受一幅有向图 `G` 然后创建并初始化这幅图的一个副本。`G` 的用例的对它作出的任何改动都不应该影响到它的副本。

**4.2.4**　为 `Digraph` 添加一个方法 `hasEdge()`，它接受两个整型参数 `v` 和 `w`。如果图含有边 `v` → `w`，方法返回 `true`，否则返回 `false`。

**4.2.5**　修改 `Digraph`，不允许存在平行边和自环。

**4.2.6**　为 `Digraph` 编写一个测试用例。

**4.2.7**　顶点的**入度**为指向该顶点的边的总数。顶点的**出度**为由该顶点指出的边的总数。从出度为 0 的顶点是不可能达到任何顶点的，这种顶点叫做**终点**；入度为 0 的顶点是不可能从任何顶点到达的，所以叫做**起点**。一幅允许出现自环**且**每个顶点的出度均为 1 的有向图叫做**映射**（从 0 到 ![V-1](https://private.codecogs.com/gif.latex?V-1) 之间的整数到它们自身的函数）。编写一段程序 Degrees.java，实现下面的 API，如表 4.2.11 所示。

**表　4.2.11**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>Degrees</b></code>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Degrees(Digraph G)</code></td><td>构造函数
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;indegree(int v)</code></td><td><code>v</code> 的入度
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;outdegree(int v)</code></td><td><code>v</code> 的出度
<tr><td><code>Iterable&lt;Integer>&nbsp;&nbsp;sources()</code></td><td>所有起点的集合
<tr><td><code>Iterable&lt;Integer>&nbsp;&nbsp;sinks()</code></td><td>所有终点的集合
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isMap()</code></td><td><code>G</code> 是一幅映射吗
</table>

**4.2.8**　画出所有含有 `2`、`3`、`4` 和 `5` 个顶点的非同构有向无环图。（参考练习 4.1.28）

**4.2.9**　编写一个方法，检查一幅有向无环图的顶点的给定排列是否就是该图顶点的拓扑排序。

**4.2.10**　给定一幅有向无环图，是否存在一种无法用基于深度优先搜索算法得到的顶点的拓扑排序？顶点的相邻关系不限。证明你的结论。

**4.2.11**　描述一组稀疏有向图，其含有的有向环的个数随着顶点增加而呈指数级增长。

**4.2.12**　一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边且为一条简单路径的有向图的传递闭包中含有多少条边？

**4.2.13**　给出这幅含有 10 个顶点和以下边的有向图的传递闭包：

```
3 → 7 1 → 4 7 → 8 0 → 5 5 → 2 3 → 8 2 → 9 0 → 6 4 → 9 2 → 6 6 → 4
```

**4.2.14**　证明 ![G](https://private.codecogs.com/gif.latex?G) 和 ![G^{{\rm R}}](https://private.codecogs.com/gif.latex?G^{{\rm%20R}}) 中的强连通分量是相同的。

**4.2.15**　一幅有向无环图的强连通分量是哪些？

**4.2.16**　用 Kosaraju 算法处理一幅有向无环图的结果是什么？

**4.2.17**　真假判断：一幅有向图的反向图的顶点的逆后序排列和该有向图的顶点的后序排列相同。

**4.2.18**　使用 1.4 节中的内存使用模型评估含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的 `Digraph` 的内存使用情况。

###提高题

**4.2.19**　**拓扑排序与广度优先搜索**。解释为何如下算法无法得到一组拓扑排序：运行广度优先搜索并按照所有顶点和起点的距离标记它们。

**4.2.20**　**有向欧拉环**。欧拉环是一条每条边恰好出现一次的有向环。编写一个程序 `Euler` 来找出有向图中的欧拉环或者说明它不存在。**提示**：当且仅当有向图 ![G](https://private.codecogs.com/gif.latex?G) 是连通的且每个顶点的出度和入度相同时 ![G](https://private.codecogs.com/gif.latex?G) 含有一条有向欧拉环。

**4.2.21**　**有向无环图中的 LCA**。给定一幅有向无环图和两个顶点 `v` 和 `w`，找出 `v` 和 `w` 的 LCA（Lowest Common Ancestor，最近共同祖先）。LCA 的计算在实现编程语言的多重继承、分析家谱数据（找出家族中近亲繁衍的程度）和其他一些应用中很有用。**提示**：将有向无环图中的顶点 `v` 的高度定义为从根结点到 `v` 的最长路径。在所有 `v` 和 `w` 的共同祖先中，高度最大者就是 `v` 和 `w` 的最近共同祖先。

**4.2.22**　**最短先导路径**。给定一幅有向无环图和两个顶点 `v` 和 `w`，找出 `v` 和 `w` 之间的**最短先导路径**。设 `v` 和 `w` 的一个共同的祖先顶点为 `x`，先导路径为 `v` 到 `x` 的最短路径和 `w` 到 `x` 的最短路径。`v` 和 `w` 之间的最短先导路径是所有先导路径中的最短者。**热身**：构造一幅有向无环图，使得最短先导路径到达的祖先顶点 `x` 不是 `v` 和 `w` 的最近共同祖先。**提示**：进行两次广度优先搜索，一次从 `v` 开始，一次从 `w` 开始。

**4.2.23**　**强连通分量**。设计一种线性时间的算法来计算给定顶点 `v` 所在的强连通分量。在这个算法的基础上设计一种平方时间的算法来计算有向图的所有强连通分量。

**4.2.24**　**有向无环图中的汉密尔顿路径**。设计一种线性时间的算法来判定给定的有向无环图中是否存在一条能够正好只访问每个顶点一次的有向路径。

　　　**答案**：计算给定图的拓扑排序并顺序检查拓扑排序中每一对相邻的顶点之间是否存在一条边。

**4.2.25**　**唯一的拓扑排序**。设计一个算法来判定一幅有向图的拓扑排序是否是唯一的。**提示**：当且仅当拓扑排序中每一对相邻的顶点之间都存在一条有向边（即有向图含有一条汉密尔顿路径）时它的拓扑排序才是唯一的。如果一幅有向图的拓扑排序不唯一，另一种拓扑排序可以由交换拓扑排序中的某一对相邻的顶点得到。

**4.2.26**　**2- 可满足性**。给定一个由 ![M](https://private.codecogs.com/gif.latex?M) 个子句和 ![N](https://private.codecogs.com/gif.latex?N) 个变量的组成的以合取范式形式给出的布尔逻辑命题，每个子句都正好含有两个变量，找到一组使布尔表达式为真的变量赋值（如果存在）。**提示**：构造一幅含有 ![2N](https://private.codecogs.com/gif.latex?2N) 个顶点的**蕴涵有向图**（implication graph）（每个变量和它的反都各有一个顶点）。对于每个子句 `x+y`，添加一条从 `y'` 到 `x` 的边和一条从 `x'` 到 `y` 的边。要满足子句 `x+y`，必有 `(i)` 如果 `y` 是假那么 `x` 为真，或者 `(ii)` 如果 `x` 是假那么 `y` 为真。**说明**：当且仅当没有任何顶点 `x` 和它的反 `x'` 存在于同一个强连通分量中时这个表达式才能被满足。另外，**核心有向无环图**（每个强连通分量都是一个顶点）的拓扑排序也能够产生一组可以满足该表达式的变量赋值。

**4.2.27**　**有向图的枚举**。证明所有不同的含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点且不含平行边的有向图的总数为 ![2^{V^2}](https://private.codecogs.com/gif.latex?2^{V^2}) 个。（含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的不同有向图有多少个？）假设宇宙中每个电子在一纳秒内能够检查一幅有向图，宇宙中的电子总数不超过 ![10^{80} ](https://private.codecogs.com/gif.latex?10^{80}) 个，宇宙的寿命小于 ![10^{20} ](https://private.codecogs.com/gif.latex?10^{20}) 年。对于所有含有 20 个顶点的不同有向图，计算机最多能够检查它们的百分之几？

**4.2.28**　**有向无环图的枚举**。给出一个公式，计算含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的所有有向无环图的数量。

**4.2.29**　**算术表达式**。编写一个类来计算由有向无环图表示的算术表达式。使用一个由顶点索引的数组来保存每个顶点所对应的值。假设叶子结点中的值是常数。描述一组算术表达式，使得它所对应的**表达式树**（expression tree）的大小是相应的有向无环图的大小的指数级别。（因此程序处理有向无环图所需的时间将和处理表达式树所需的时间的对数成正比。）

**4.2.30**　**基于队列的拓扑排序**。实现一种拓扑排序，使用由顶点索引的数组来保存每个顶点的入度。遍历一遍所有边并使用练习 4.2.7 给出的 `Degrees` 类来初始化数组以及一条含有所有起点的队列。然后，重复以下操作直到起点队列为空：

* 从队列中删去一个起点并将其标记；
* 遍历由被删除顶点指出的所有边，将所有被指向的顶点的入度减一；
* 如果顶点的入度变为 0，将它插入起点队列。

**4.2.31**　**有向欧几里得图**。修改你为 4.1.36 给出的解答，为平面图设计一份 API 名为 `EuclideanDigraph`，这样你就能够处理用图形表示的图了。

###实验题

**4.2.32**　**随机有向图**。编写一个程序 `ErdosRenyiDigraph`，从命令行接受整数 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E)，随机生成 E 对 0 到 ![V-1](https://private.codecogs.com/gif.latex?V-1) 之间的整数来构造一幅有向图。**注意**：生成器可能会产生自环和平行边。

**4.2.33**　**随机简单有向图**。编写一个程序 `RandomSimpleDigraph`，从命令行接受整数 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E)，用均等的几率生成含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的所有可能的**简单**有向图。

**4.2.34**　**随机稀疏有向图**。将你为练习 4.1.40 给出的解答修改为 `RandomSparseDigraph`，根据精心选择的一组 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E) 的值生成随机的稀疏有向图，使得我们可以用它进行有意义的经验性测试。

**4.2.35**　**随机欧几里得图**。将你为练习 4.1.41 给出的解答修改为 `EuclideanDigraph` 的用例 `RandomEuclideanDigraph`，随机指定每条边的方向。

**4.2.36**　**随机网格图**。将你为练习 4.1.42 给出的解答修改为 `EuclideanDigraph` 的用例 `RandomGridDigraph`，随机指定每条边的方向。

**4.2.37**　**真实世界中的有向图**。从互联网上找出一幅巨型有向图——可以是某个在线商业系统的交易图，或是由网页和链接得到的有向图。编写一段程序 `RandomRealDigraph`，从这些顶点构成的子图中随机选取 ![V](https://private.codecogs.com/gif.latex?V) 个顶点，然后再从这些顶点构成的子图中随机选取 ![E](https://private.codecogs.com/gif.latex?E) 条有向边来构造一幅图。

**4.2.38**　**真实世界中的有向无环图**。从互联网上找出一幅巨型有向无环图——可以是大型软件系统中的类依赖关系，或是大型文件系统中的目录结构。编写一段程序 `RandomRealDAG`，从这幅有向无环图中随机选取 ![V](https://private.codecogs.com/gif.latex?V) 个顶点，然后再从这些顶点构成的子图中随机选取 ![E](https://private.codecogs.com/gif.latex?E) 条有向边来构造一幅图。

>　　测试所有的算法并研究所有图模型的所有参数是不现实的。请为下面的每一道题都编写一段程序来处理从输入得到的任意图。这段程序可以调用上面的任意生成器并对相应的图模型进行实验。你可以根据上次实验的结果自己作出判断来选择不同实验。陈述结果以及由此得出的任何结论。

**4.2.39**　**可达性**。对于各种有向图的模型，运行实验并根据经验判断从一个随机选定的顶点可以到达的顶点数量的平均值。

**4.2.40**　**深度优先搜索中的路径长度**。对于各种有向图的模型，运行实验并根据经验判断 `DepthFirstDirectedPaths` 在两个随机选定的顶点之间找到一条路径的概率并计算找到的路径的平均长度。

**4.2.41**　**广度优先搜索中的路径长度**。对于各种有向图的模型，运行实验并根据经验判断 `BreadthFirstDirectedPaths` 在两个随机选定的顶点之间找到一条路径的概率并计算找到的路径的平均长度。

**4.2.42**　**强连通分量**。运行实验随机生成大量有向图并画出柱状图，根据经验判断各种类型的随机有向图中强连通分量的数量的分布情况。

##4.3　最小生成树

**加权图**是一种为每条边关联一个**权值**或是**成本**的图模型。这种图能够自然地表示许多应用。在一幅航空图中，边表示航线，权值则可以表示距离或是费用。在一幅电路图中，边表示导线，权值则可能表示导线的长度即成本，或是信号通过这条线路所需的时间。在这些情形中，最令人感兴趣的自然是将成本最小化。在本节中，我们将学习加权**无向图**模型并用算法回答下面这个问题。

**最小生成树**。给定一幅加权无向图，找到它的一棵最小生成树。

>**定义**。图的**生成树**是它的一棵含有其所有顶点的无环连通子图。一幅加权图的**最小生成树**（MST）是它的一棵权值（树中所有边的权值之和）最小的生成树。（请见图 4.3.1）。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.059.png)

**图 4.3.1　一幅加权无向图和它的最小生成树**

在本节中，我们会学习计算最小生成树的两种经典算法：**Prim 算法**和 **Kruskal 算法**。这些算法理解容易，实现简单。它们是本书中最古老和最知名的算法之一，但它们也根据现代数据结构得到了改进。因为最小生成树的重要应用领域太多，对解决这个问题的算法的研究至少从 20 世纪 20 年代在设计电力分配网络时就开始了。现在，最小生成树算法在设计各种类型的网络（通信、电子、水利、计算机、公路、铁路、航空等）以及自然界中的生物、化学和物理网络等各个领域的研究中都起到了重要的作用，请见表 4.3.1。

**表 4.3.1　最小生成树的典型应用**

|应用领域|顶点|边|
|-|-|-|
|电路|元器件|导线|
|航空|机场|航线|
|电力分配|电站|输电线|
|图像分析|面部容貌|相似关系|

**一些约定**

在计算最小生成树的过程中可能会出现各种特殊情况。虽然它们大多数都很容易处理，但为了行文的流畅，我们约定如下。

* **只考虑连通图**。我们对生成树的定义意味着最小生成树只可能存在于连通图中，请见图 4.3.2a。从另一个角度来说，请回想 4.1 节所述的树的基本性质，我们要找的就是一个由 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边组成的集合，它们既连通了图中的所有顶点而权值之和又最小。如果一幅图是非连通的，我们只能使用这个算法来计算它的所有连通分量的最小生成树，合并在一起称其为**最小生成森林**（请见练习 4.3.22）。
* **边的权重不一定表示距离**。有时你对几何学的直觉能够帮助你理解算法，因此在示例中，顶点都表示是平面上的点，而权重都表示是两点之间的距离，比如图 4.3.1。但需要注意的是，权重也可能表示时间、费用或是其他完全不同的变量，而且也完全不一定会和距离成正比，请见图 4.3.2b。
* **边的权重可能是 0 或者负数**。如果边的权重都是正的，将最小生成树定义为连接所有顶点且总权重最小的子图就足够了，这样的一幅子图必然是一棵生成树。定义中的生成树条件说明图也可以含有权重为 0 或是负数的边，请见图 4.3.2c。
* **所有边的权重都各不相同**。如果不同边的权重可以相同，最小生成树就不一定唯一了（请见练习 4.3.2）。存在多棵最小生成树的可能性会使部分算法的证明变得更加复杂，因此我们在表示中排除了这种可能性。事实上这个假设并没有限制算法的适用范围，因为不做修改它们也能处理存在等值权重的情况，请见图 4.3.2d。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.060.png)

**图 4.3.2　计算最小生成树时可能遇到的各种特殊情况**

总之，在学习最小生成树相关算法的过程中我们假设任务的目标是在一幅加权（但权值各不相同的）连通无向图中找到它的最小生成树。

###4.3.1　原理

首先，我们回顾一下 4.1 节中给出的树的两个最重要的性质，另见图 4.3.3：

* 用一条边连接树中的任意两个顶点都会产生一个新的环；
* 从树中删去一条边将会得到两棵独立的树。

![{33%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.061.png)

**图 4.3.3　树的基本性质**

这两条性质是证明最小生成树的另一条基本性质的基础，而由这条基本性质就能够得到本节中的最小生成树算法。

####4.3.1.1　切分定理

我们称之为**切分定理**的这条性质将会把加权图中的所有顶点分为两个集合、检查横跨两个集合的所有边并识别哪条边应属于图的最小生成树。

>**定义**。图的一种**切分**是将图的所有顶点分为两个非空且不重叠的两个集合。横切边是一条连接两个属于不同集合的顶点的边。

通常，我们通过指定一个顶点集并隐式地认为它的补集为另一个顶点集来指定一个切分。这样，一条横切边就是连接该集合的一个顶点和不在该集合中的另一个顶点的一条边。如图 4.3.4 所示，我们将切分中一个集合的顶点都画为了灰色，另一个集合的顶点则为白色。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.062.png)

**图 4.3.4　切分定理**

>**命题 J（切分定理）**。在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。

>**证明**。令 ![e](https://private.codecogs.com/gif.latex?e) 为权重最小的横切边，![T](https://private.codecogs.com/gif.latex?T) 为图的最小生成树。我们采用反证法：假设 ![T](https://private.codecogs.com/gif.latex?T) 不包含 ![e](https://private.codecogs.com/gif.latex?e)。那么如果将 ![e](https://private.codecogs.com/gif.latex?e) 加入 ![T](https://private.codecogs.com/gif.latex?T)，得到的图必然含有一条经过 ![e](https://private.codecogs.com/gif.latex?e) 的环，且这个环至少含有另一条横切边——设为 ![f](https://private.codecogs.com/gif.latex?f)，![f](https://private.codecogs.com/gif.latex?f) 的权重必然大于 ![e](https://private.codecogs.com/gif.latex?e)（因为 ![e](https://private.codecogs.com/gif.latex?e) 的权重是最小的且图中所有边的权重均不同）。那么我们删掉 ![f](https://private.codecogs.com/gif.latex?f) 而保留 ![e](https://private.codecogs.com/gif.latex?e) 就可以得到一棵权重更小的生成树。这和我们的假设 ![T](https://private.codecogs.com/gif.latex?T) 矛盾。

在假设所有的边的权重均不相同的前提下，每幅连通图都只有一棵唯一的最小生成树（请见练习 4.3.3），切分定理也表明了对于每一种切分，权重最小的横切边必然属于最小生成树。

图 4.3.4 是切分定理的示意图。注意，权重最小的横切边并不一定是所有横切边中唯一属于图的最小生成树的边。实际上，许多切分都会产生若干条属于最小生成树的横切边，如图 4.3.5 所示。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.063.png)

**图 4.3.5　产生了两条属于最小生成树的横切边的一种切分**

####4.3.1.2　贪心算法

切分定理是解决最小生成树问题的所有算法的基础。更确切的说，这些算法都是一种**贪心算法**的特殊情况：使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。这些算法相互之间的不同之处在于保存切分和判定权重最小的横切边的方式，但它们都是以下性质的特殊情况。

>**命题 K（最小生成树的贪心算法）**。下面这种方法会将含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将它权重最小的横切边标记为黑色。反复，直到标记了 ![V\-1](https://private.codecogs.com/gif.latex?V\-1) 条黑色边为止。

>**证明**。为了简单，我们假设所有边的权重均不相同，尽管没有这个假设该命题同样成立（请见练习 4.3.5）。根据切分定理，所有被标记为黑色的边均属于最小生成树。如果黑色边的数量小于 ![V\-1](https://private.codecogs.com/gif.latex?V\-1)，必然还存在不会产生黑色横切边的切分（因为我们假设图是连通的）。只要找到了 ![V\-1](https://private.codecogs.com/gif.latex?V\-1) 条黑色的边，这些边所组成的就是一棵最小生成树。

图 4.3.6 所示的是这个贪心算法运行的典型轨迹。每一幅图表现的都是一次切分，其中算法识别了一条权重最小的横切边（红色加粗）并将它加入最小生成树之中。

![{40%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.064.png)

**图 4.3.6　贪心最小生成树算法**

###4.3.2　加权无向图的数据类型

加权无向图应该如何表示？也许最简单的方法就是扩展 4.1 节中对无向图的表示方法：在邻接矩阵的表示中，可以用边的权重代替布尔值来作为矩阵的元素；在邻接表的表示中，可以在链表的结点中增加一个权重域。（和以前一样，我们把重点放在稀疏图上，将邻接矩阵的表示方法留作练习。）这种经典的方法很有吸引力，但我们会使用另外一种并不太复杂的表示方式。它需要一个更加通用的 API 来处理 `Edge` 对象，能够使程序适用于更加常见的场景，请见表 4.3.2。

**表 4.3.2　加权边的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class <b>Edge</b> implements Comparable&lt;Edge></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edge(int v, int w, double weight)</code></td><td>用于初始化的构造函数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double weight()</code></td><td>边的权重</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int either()</code></td><td>边两端的顶点之一</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int other(int v)</code></td><td>另一个顶点</td></tr>
<tr><td><code style="color: #9FA0A0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int compareTo(Edge that)</code></td><td>将这条边与 <code>that</code> 比较</td></tr>
<tr><td><code style="color: #9FA0A0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String toString()</code></td><td>对象的字符串表示</td></tr>
</table>

访问边的端点的 `either()` 和 `other()` 方法乍一看会有些奇怪——在看到调用它们的代码时就会清楚了为什么会有这样的需要了。`Edge` 的实现请见框注“带权重的边的数据类型”，它是 `EdgeWeightedGraph` 的 API 的基础。加权无向图的实现很自然地使用了 `Edge` 对象，请见表 4.3.3。

**表 4.3.3　加权无向图的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;public class <b>EdgeWeightedGraph</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeWeightedGraph(int V)</code></td><td>创建一幅含有 <code>V</code> 个顶点的空图</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeWeightedGraph(In in)</code></td><td>从输入流中读取图</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int V()</code></td><td>图的顶点数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int E()</code></td><td>图的边数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void addEdge(Edge e)</code></td><td>向图中添加一条边 <code>e</code></td></tr>
<tr><td><code>Iterable&lt;Edge> adj(int v)</code></td><td>和 <code>v</code> 相关联的所有边</td></tr>
<tr><td><code>Iterable&lt;Edge> edges()</code></td><td>图的所有边</td></tr>
<tr><td><code style="color: #9FA0A0;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String toString()</code></td><td>对象的字符串表示</td></tr>
</table>

这份 API 和 `Graph` 的 API（请见表 4.1.1）非常相似。两者的两个重要的不同之处在于本节 API 的基础是 `Edge` 且添加了一个 `edges()` 方法（请见框注“返回加权无向图中的所有边”）来遍历图的所有边（忽略自环）。后面框注“加权无向图的数据类型”中 `EdgeWeightedGraph` 的实现的其他部分与 4.1 节的无向图的实现基本相同，只是在邻接表中用 `Edge` 对象替代了 `Graph` 中的整数来作为链表的结点。

```
public Iterable<Edge> edges()
{
   Bag<Edge> b = new Bag<Edge>();
   for (int v = 0; v < V; v++)
      for (Edge e : adj[v])
         if (e.other(v) > v) b.add(e);
   return b;
}
```

{-:-}返回加权无向图中的所有边

图 4.3.7 显示的是在处理样例文件 tinyEWG.txt 时用 `EdgeWeightedGraph` 对象表示的加权无向图。它按照 1.3 节中的标准实现显示了链表中每个 `Bag` 对象的内容。为了整洁，用一对 `int` 值和一个 `double` 值表示每个 `Edge` 对象。实际的数据结构是一个链表，其中每个元素都是一个指向含有这些值的对象的指针。需要特别注意的是，虽然每个 `Edge` 对象都有两个**引用**（每个顶点的链表中都有一个），但图中的每条边所对应的 `Edge` 对象只有一个。在示意图中，边在链表中的出现顺序和处理它们的顺序是相反的，这是由于标准链表实现和栈的相似性所导致的。和 `Graph` 一样，使用 `Bag` 对象可以保证用例的代码和链表中对象的顺序是无关的。

![{93%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.065.png)

**图 4.3.7　加权无向图的表示**

>**带权重的边的数据类型**

>![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.066.png)

>该数据结构提供了 `either()` 和 `other()` 两个方法。在已知一个顶点 `v` 时，用例可以使用 `other(v)` 来得到边的另一个顶点。当两个顶点都是未知的时候，用例可以使用惯用代码 `v=e.either(), w=e. other(v);` 来访问一个 `Edge` 对象 `e` 的两个顶点。

　

>**加权无向图的数据类型**

>![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.067.png)

>该实现使用了一个由顶点索引的邻接表。与 `Graph`（请见 4.1.2.2 节框注“Graph 数据类型”）一样，每条边都会出现两次：如果一条边连接了顶点 `v` 和 `w`，那么它既会出现在 `v` 的链表中也会出现在 `w` 的链表中。`edges()` 方法将所有边放在一个 `Bag` 对象中（请见 4.3.2 节框注“返回加权无向图中的所有边”）。`toString()` 方法的实现留作练习。

####4.3.2.1　用权重来比较边

API 说明 `Edge` 类必须实现 `Comparable` 接口并包含一个 `compareTo()` 方法。一幅加权无向图中的边的自然次序就是按权重排序，相应的 `compareTo()` 方法的实现也就很简单了。

####4.3.2.2　平行边

和无环图的实现一样，这里也允许存在平行边。我们也可以用更复杂的方式实现 `EdgeWeightedGraph` 类来消除平行边，比如只保留平行的边中的权重最小者。

####4.3.2.3　自环

允许存在自环。尽管自环可能的确存在于输入或是数据结构之中，但是 `EdgeWeightedGraph` 中 `edges()` 的实现并没有统计它们。这对最小生成树算法没有影响，因为最小生成树肯定不会含有自环。如果在应用中自环很重要，那你或许需要根据应用场景修改代码。

你会看到，有了 `Edge` 对象之后用例的代码就可以变得更加干净整洁。这也有个小小的代价：每个邻接表的结点都是一个指向 `Edge` 对象的**引用**，它们含有一些冗余的信息（`v` 的邻接链表中的每个结点都会用一个变量保存 `v`）。使用对象也会带来一些开销。虽然每条边的 `Edge` 对象都只有一个，但邻接表中还是会含有两个指向同一 `Edge` 对象的引用。另一种广泛使用的方案是与 `Graph` 一样，用两个结点对象来表示一条边，每个结点对象都会保存顶点的信息和边的权重。这种方法也是有代价的——需要两个结点，每条边的权重都会被保存两遍。

###4.3.3　最小生成树的 API 和测试用例

按照惯例，在 API 中会定义一个接受加权无向图为参数的构造函数并且支持能够为用例返回图的最小生成树和其权重的方法。那么我们应该如何表示最小生成树呢？由于图 ![G](https://private.codecogs.com/gif.latex?G) 的最小生成树是 ![G](https://private.codecogs.com/gif.latex?G) 的一幅子图并且同时也是一棵树，因此我们有很多选择，最主要的几种表示方法为：

* 一组边的列表；
* 一幅加权无向图；
* 一个以顶点为索引且含有父结点链接的数组。

在为各种应用选择这些表示方法时，我们希望尽量给予最小生成树的实现以最大的灵活性，因此我们采用了表 4.3.4 所示的 API。

**表 4.3.4　最小生成树的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;public class <b>MST</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MST(EdgeWeightedGraph G)</code></td><td>构造函数</td></tr>
<tr><td><code>Iterable&lt;Edge> edges()</code></td><td>最小生成树的所有边</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double weight()</code></td><td>最小生成树的权重</td></tr>
</table>

####4.3.3.1　测试用例

和以前一样，我们会创建样图并开发一个测试用例来测试最小生成树的实现。右侧框注就是一个示例。它从输入流中读取图的所有边并构造一幅加权无向图，然后计算该图的最小生成树并打印树的所有边和权重之和。

```
public static void main(String[] args)
{
   In in = new In(args[0]);
   EdgeWeightedGraph G;
   G = new EdgeWeightedGraph(in);

   MST mst = new MST(G);
   for (Edge e : mst.edges())
      StdOut.println(e);
   StdOut.println(mst.weight());
}
```

{-:-}最小生成树的测试用例

####4.3.3.2　测试数据

你可以在本书的网站上找到 tinyEWG.txt 文件，它定义了我们用来展示最小生成树算法的轨迹样图（请见图 4.3.1）。在网站上你还能找到 mediumEWG.txt，它定义了一幅含有 250 个顶点的加权无向图，如图 4.3.8 所示。它也是一幅**欧几里得图**的示例，它的顶点都是平面上的点，边为连接它们的线段且权重为两点之间的欧几里得距离。这样的图有助于我们理解最小生成树算法的行为，同时也是我们提到过的许多典型实际问题的模型，例如公路地图和电路图。在本书的网站上你还能找到一幅较大的样图 largeEWG.txt，它是一幅含有一百万个顶点的欧几里得图。我们的目标就是在合理的时间范围内通过计算得到这种规模的图的最小生成树。

```
% more tinyEWG.txt
8 16
4 5 .35
4 7 .37
5 7 .28
0 7 .16
1 5 .32
0 4 .38
2 3 .17
1 7 .19
0 2 .26
1 2 .36
1 3 .29
2 7 .34
6 2 .40
3 6 .52
6 0 .58
6 4 .93

% java MST tinyEWG.txt
0-7 0.16
1-7 0.19
0-2 0.26
2-3 0.17
5-7 0.28
4-5 0.35
6-2 0.40
1.81
```

　

```
% more mediumEWG.txt
250 1273
244 246 0.11712
239 240 0.10616
238 245 0.06142
235 238 0.07048
233 240 0.07634
232 248 0.10223
231 248 0.10699
229 249 0.10098
228 241 0.01473
226 231 0.07638
... [还有1263条边]

% java MST mediumEWG.txt
  0 225 0.02383
 49 225 0.03314
 44  49 0.02107
 44 204 0.01774
 49  97 0.03121
202 204 0.04207
176 202 0.04299
176 191 0.02089
 68 176 0.04396
 58  68 0.04795
... [还有239条边]
10.46351
```

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.068.png)

**图 4.3.8　一幅含有 250 个顶点的无向加权欧几里得图（共含有 1273 条边）和它的最小生成树**

###4.3.4　Prim 算法

我们要学习的第一种计算最小生成树的方法叫做 **Prim 算法**，它的每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边（黑色表示）加入树中（即由树中的顶点所定义的切分中的一条横切边），如图 4.3.9 所示。

![{40%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.069.png)

**图 4.3.9　最小生成树的 Prim 算法**

>**命题 L**。Prim算法能够得到任意加权连通图的最小生成树。

>**证明**。由命题 K 可知，这棵不断生长的树定义了一个切分且不存在黑色的横切边。该算法会选取权重最小的横切边并根据贪心算法不断将它们标记为黑色。

以上我们对 Prim 算法的简单描述没有回答一个关键的问题：如何才能（有效地）找到最小权重的横切边呢？人们提出了很多方法——在用一种特别简单的方法解决这个问题之后我们会讨论其中的一部分方法。

####4.3.4.1　数据结构

实现 Prim 算法需要用到一些简单常见的数据结构。具体来说，我们会用以下方法表示树中的顶点、边和横切边。

* **顶点**。使用一个由顶点索引的布尔数组 `marked[]`，如果顶点 `v` 在树中，那么 `marked[v]` 的值为 `true`。
* **边**。选择以下两种数据结构之一：一条队列 `mst` 来保存最小生成树中的边，或者一个由顶点索引的 `Edge` 对象的数组 `edgeTo[]`，其中 `edgeTo[v]` 为将 `v` 连接到树中的 `Edge` 对象。
* 横切边：使用一条优先队列 `MinPQ<Edge>` 来根据权重比较所有边（请见 4.3.2 节框注“带权重的边的数据类型”）。

有了这些数据结构我们就可以回答“哪条边的权重最小？”这个基本的问题了。

####4.3.4.2　维护横切边的集合

每当我们向树中添加了一条边之后，也向树中添加了一个顶点。要维护一个包含所有横切边的集合，就要将连接这个顶点和其他所有不在树中的顶点的边加入优先队列（用 `marked[]` 来识别这样的边）。但还有一点：连接新加入树中的顶点与其他已经在树中顶点的所有边都**失效**了。（这样的边都已经不是横切边了，因为它的两个顶点都在树中。）Prim 算法的**即时**实现可以将这样的边从优先队列中删掉，但我们先来学习这个算法的一种**延时**实现，将这些边先留在优先队列中，等到要删除它们的时候再检查边的有效性。

图 4.3.10 是处理样图 tinyEWG.txt 的轨迹。每一张图片都是算法访问过一个顶点之后（被添加到树中，邻接链表中的边也已经被处理完成）图和优先队列的状态。优先队列的内容被按照顺序显示在一侧，新加入的边的旁边标有星号。算法构造最小生成树的过程如下所述。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.070.png)

**图 4.3.10　Prim 算法的轨迹（延时实现）**

* 将顶点 `0` 添加到最小生成树之中，将它的邻接链表中的所有边添加到优先队列之中。
* 将顶点 `7` 和边 `0-7` 添加到最小生成树之中，将顶点的邻接链表中的所有边添加到优先队列之中。
* 将顶点 `1` 和边 `1-7` 添加到最小生成树之中，将顶点的邻接链表中的所有边添加到优先队列之中。
* 将顶点 `2` 和边 `0-2` 添加到最小生成树之中，将边 `2-3` 和 `6-2` 添加到优先队列之中。边 `2-7` 和 `1-2` 失效。
* 将顶点 `3` 和边 `2-3` 添加到最小生成树之中，将边 `3-6` 添加到优先队列之中。边 `1-3` 失效。
* 将顶点 `5` 和边 `5-7` 添加到最小生成树之中，将边 `4-5` 添加到优先队列之中。边 `1-5` 失效。
* 从优先队列中删除失效的边 `1-3`、`1-5` 和 `2-7`。
* 将顶点 `4` 和边 `4-5` 添加到最小生成树之中，将边 `6-4` 添加到优先队列之中。边 `4-7` 和 `0-4` 失效。
* 从优先队列中删除失效的边 `1-2`、`4-7` 和 `0-4`。
* 将顶点 `6` 和边 `6-2` 添加到最小生成树之中，和顶点 6 相关联的其他边均失效。

在添加了 ![V](https://private.codecogs.com/gif.latex?V) 个顶点（以及 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边）之后，最小生成树就完成了。优先队列中的余下的边都是无效的，不需要再去检查它们。

####4.3.4.3　实现

有了这些预备知识，Prim 算法的实现就很简单了，请见后面框注“最小生成树的 Prim 算法的延时实现”中的 `LazyPrimMST` 类。和前两节实现深度优先搜索和广度优先搜索一样，实现会在构造函数中计算图的最小生成树，这样用例方法就可以用查询类方法获得最小生成树的各种属性。我们使用了一个私有方法 `visit()` 来为树添加一个顶点、将它标记为“已访问”并将与它关联的所有未失效的边加入优先队列，以保证队列含有所有连接树顶点和非树顶点的边（也可能含有一些已经失效的边）。代码的内循环是算法的具体实现：我们从优先队列中取出一条边并将它添加到树中（如果它还没有失效的话），再把这条边的另一个顶点也添加到树中，然后用新顶点作为参数调用 `visit()` 方法来更新横切边的集合。`weight()` 方法可以遍历树的所有边并得到它们的权重之和（延时实现）或是用一个运行时的变量统计总权重（即时实现），这一点留作练习 4.3.31。

####4.3.4.4　运行时间

Prim 算法有多快？我们已经知道优先队列的性质，所以要回答这个问题并不困难。

>**命题 M**。Prim 算法的延时实现计算一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的连通加权无向图的最小生成树所需的空间与 ![E](https://private.codecogs.com/gif.latex?E) 成正比，所需的时间与 ![E \log E](https://private.codecogs.com/gif.latex?E%20\log%20E) 成正比（最坏情况）。

>**证明**。算法的瓶颈在于优先队列的 `insert()` 和 `delMin()` 方法中比较边的权重的次数。优先队列中最多可能有 ![E](https://private.codecogs.com/gif.latex?E) 条边，这就是空间需求的上限。在最坏情况下，一次插入的成本为 ![\sim\lg E](https://private.codecogs.com/gif.latex?\sim\lg%20E)，删除最小元素的成本为 ![\sim2\lg E](https://private.codecogs.com/gif.latex?\sim2\lg%20E)（请见第 2 章的命题 Q）。因为最多只能插入 ![E](https://private.codecogs.com/gif.latex?E) 条边，删除 ![E](https://private.codecogs.com/gif.latex?E) 次最小元素，时间上限显而易见。

在实际中，估计的运行时间上限是比较保守的，因为一般情况下优先队列中的边都远小于 ![E](https://private.codecogs.com/gif.latex?E)。这么困难的任务，解决方法却如此的简单、高效而实用，实在令人佩服。下面，我们会简要讨论一些改进算法的方法。和以前一样，在性能优先的应用场景中仔细评估这些改进的工作应该留给专家。

>**最小生成树的 Prim 算法的延时实现**

>```
>public class LazyPrimMST
>{
>    private boolean[] marked;          // 最小生成树的顶点
>    private Queue<Edge> mst;           // 最小生成树的边
>    private MinPQ<Edge> pq;            // 横切边（包括失效的边）
>
>    public LazyPrimMST(EdgeWeightedGraph G)
>    {
>       pq = new MinPQ<Edge>();
>       marked = new boolean[G.V()];
>       mst = new Queue<Edge>();
>
>       visit(G, 0);   // 假设G是连通的（请见练习4.3.22）
>       while (!pq.isEmpty())
>
>       {
>          Edge e = pq.delMin();                  // 从pq中得到权重最小的边
>
>          int v = e.either(), w = e.other(v);
>          if (marked[v] && marked[w]) continue;  // 跳过失效的边
>          mst.enqueue(e);                        // 将边添加到树中
>          if (!marked[v]) visit(G, v);           // 将顶点（v或w）添加到树中
>          if (!marked[w]) visit(G, w);
>       }
>    }
>
>    private void visit(EdgeWeightedGraph G, int v)
>    {  // 标记顶点v并将所有连接v和未被标记顶点的边加入pq
>       marked[v] = true;
>       for (Edge e : G.adj(v))
>          if (!marked[e.other(v)]) pq.insert(e);
>    }
>
>    public Iterable<Edge> edges()
>    {  return mst;  }
>
>    public double weight()   // 请见练习4.3.31
>
>}
>```

>Prim 算法的这种实现使用了一条优先队列来保存所有的横切边、一个由顶点索引的数组来标记树的顶点以及一条队列来保存最小生成树的边。这种延时实现会在优先队列中保留失效的边。　

###4.3.5　Prim 算法的即时实现

要改进 `LazyPrimMST`，可以尝试从优先队列中删除失效的边，这样优先队列就只含有树顶点和非树顶点之间的横切边，但其实还可以删除更多的边。关键在于，我们感兴趣的只是连接树顶点和非树顶点中权重**最小**的边。当我们将顶点 `v` 添加到树中时，对于每个非树顶点 `w` 产生的变化只可能使得 `w` 到最小生成树的距离更近了，如图 4.3.11 所示。简而言之，我们不需要在优先队列中保存**所有**从 `w` 到树顶点的边——而只需要保存其中权重最小的那条，在将 `v` 添加到树中后检查是否需要更新这条权重最小的边（因为 `v-w` 的权重可能更小）。我们只需遍历 `v` 的邻接链表就可以完成这个任务。换句话说，我们只会在优先队列中保存每个非树顶点 `w` 的**一条**边：将它与树中的顶点连接起来的权重最小的那条边。将 `w` 和树的顶点连接起来的其他权重较大的边迟早都会失效，所以没必要在优先队列中保存它们。

![{40%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.071.png)

**图 4.3.11　Prim 算法的即时实现**

`PrimMST` 类（请见算法 4.7）使用了 2.4 节中介绍的索引优先队列实现的 Prim 算法。它将 `LazyPrimMST` 中的 `marked[]` 和 `mst[]` 替换为两个顶点索引的数组 `edgeTo[]` 和 `distTo[]`，它们具有如下性质。

* 如果顶点 `v` 不在树中但至少含有一条边和树相连，那么 `edgeTo[v]` 是将 `v` 和树连接的最短边，`distTo[v]` 为这条边的权重。
* 所有这类顶点 `v` 都保存在一条索引优先队列中，索引 `v` 关联的值是 `edgeTo[v]` 的边的权重。

这些性质的关键在于**优先队列中的最小键即是权重最小的横切边的权重，而和它相关联的顶点 `v` 就是下一个将被添加到树中的顶点**。`marked[]` 数组已经没有必要了，因为判断条件 `!marked[w]` 等价于 `distTo[w]` 是无穷的（且 `edgeTo[w]` 为 `null`）。要维护这些数据结构，`PrimMST` 会从优先队列中取出一个顶点 `v` 并检查它的邻接链表中的每条边 `v-w`。如果 `w` 已经被标记过，那么这条边就已经失效了；如果 `w` 不在优先队列中或者 `v-w` 的权重小于目前已知的最小值 `edgeTo[w]`，代码会更新数组，将 `v-w` 作为将 `w` 和树连接的最佳选择。

图 4.3.12 所示的是 `PrimMST` 在处理样图 tinyEWG.txt 过程中的轨迹。将每个顶点加入最小生成树之后，`edgeTo[]` 和 `distTo[]` 的内容显示在右侧，不同的颜色显示了最小生成树中的顶点（索引为黑色）、非最小生成树的顶点（索引为灰色）、最小生成树的边（黑色）和优先队列中的索引值对（红色）。在示意图中，将每个非最小生成树顶点连接到树的最短边为红色。该算法向最小生成树中添加的边的顺序和延时版本相同，不同之处在于优先队列的操作。它构造最小生成树的过程如下所述。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.072.png)

**图 4.3.12　Prim 算法的轨迹图（即时版本）**

* 将顶点 `0` 添加到最小生成树之中，将它的邻接链表中的所有边添加到优先队列之中，因为这些边都是目前（唯一）已知的连接非树顶点和树顶点的最短边。
* 将顶点 `7` 和边 `0-7` 添加到最小生成树之中，将边 `1-7` 和 `5-7` 添加到优先队列之中。将连接顶点 4 与树的最小边由 0-4 替换为 4-7，`2-7` 不会影响到优先队列，因为它们的权重不大于 0-2 的权重。
* 将顶点 `1` 和边 `1-7` 添加到最小生成树之中，将边 `1-3` 添加到优先队列之中。
* 将顶点 `2` 和边 `0-2` 添加到最小生成树之中，将连接顶点 `6` 与树的最小边由 `0-6` 替换为 `6-2`，将连接顶点 `3` 与树的最小边由 `1-3` 替换为 `2-3`。
* 将顶点 `3` 和边 `2-3` 添加到最小生成树之中。
* 将顶点 `5` 和边 `5-7` 添加到最小生成树之中，将连接顶点 `4` 与树的最小边由 `4-7` 替换为 `4-5`。
* 将顶点 `4` 和边 `4-5` 添加到最小生成树之中。
* 将顶点 `6` 和边 `6-2` 添加到最小生成树之中。

添加了 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边之后，最小生成树完成且优先队列为空。

>**算法 4.7　最小生成树的 Prim 算法（即时版本）**

>```
>public class PrimMST
>{
>    private Edge[] edgeTo;          // 距离树最近的边
>    private double[] distTo;        // distTo[w]=edgeTo[w].weight()
>    private boolean[] marked;       // 如果v在树中则为true
>    private IndexMinPQ<Double> pq;  // 有效的横切边
>
>    public PrimMST(EdgeWeightedGraph G)
>    {
>       edgeTo = new Edge[G.V()];
>       distTo = new double[G.V()];
>       marked = new boolean[G.V()];
>       for (int v = 0; v < G.V(); v++)
>          distTo[v] = Double.POSITIVE_INFINITY;
>       pq = new IndexMinPQ<Double>(G.V());
>
>       distTo[0] = 0.0;
>       pq.insert(0, 0.0);              // 用顶点0和权重0初始化pq
>       while (!pq.isEmpty())
>          visit(G, pq.delMin());       // 将最近的顶点添加到树中
>    }
>
>    private void visit(EdgeWeightedGraph G, int v)
>    {  // 将顶点v添加到树中，更新数据
>       marked[v] = true;
>       for (Edge e : G.adj(v))
>
>       {
>          int w = e.other(v);
>
>          if (marked[w]) continue;     // v-w失效
>          if (e.weight() < distTo[w])
>
>          {  // 连接w和树的最佳边Edge变为e
>             edgeTo[w] = e;
>
>             distTo[w] = e.weight();
>             if (pq.contains(w)) pq.change(w, distTo[w]);
>             else                pq.insert(w, distTo[w]);
>          }
>       }
>    }
>
>    public Iterable<Edge> edges()    // 请见练习4.3.21
>    public double weight()           // 请见练习4.3.31
>}
>```

>这份 Prim 算法的实现将所有有效的横切边保存在了一条索引优先队列中。

该算法的证明与命题 M 的证明本质上相同，Prim 算法的即时版本可以找到一幅连通的加权无向图的最小生成树，所需时间和 ![E \log V](https://private.codecogs.com/gif.latex?E%20\log%20V) 成正比，空间和 ![V](https://private.codecogs.com/gif.latex?V) 成正比（请见命题 N）。对于实际应用中经常出现的巨型稀疏图，两者在时间上限上没有什么区别（因为对于稀疏图来说是 ![\lg E\sim\lg V](https://private.codecogs.com/gif.latex?\lg%20E\sim\lg%20V)），但空间上限变为了原来的一个常数因子（但很显著）。在性能优先的应用场景中，更加深入的分析和实验最好还是留给专家吧，因为相关的因素有很多，例如 `MinPQ` 和 `IndexMinPQ` 的实现、图的表示方法、应用场景所使用的图模型等。按照惯例，我们需要仔细研究这些改进，因为只有当这种常数因子的性能改进非常必要时，它所带来的代码复杂性才是值得的。在复杂的现代系统中有时这样做甚至会得不偿失。

>**命题 N**。Prim 算法的即时实现计算一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的连通加权无向图的最小生成树所需的空间和 ![V](https://private.codecogs.com/gif.latex?V) 成正比，所需的时间和 ![E \log V](https://private.codecogs.com/gif.latex?E%20\log%20V) 成正比（最坏情况）。

>**证明**。因为优先队列中的顶点数最多为 ![V](https://private.codecogs.com/gif.latex?V)，且使用了三条由顶点索引的数组，所以所需空间的上限和V成正比。算法会进行 ![V](https://private.codecogs.com/gif.latex?V) 次**插入**操作，![V](https://private.codecogs.com/gif.latex?V) 次**删除最小元素**的操作和（在最坏情况下）![E](https://private.codecogs.com/gif.latex?E) 次**改变优先级**的操作。已知在基于堆实现的索引优先队列中所有这些操作的增长数量级为 ![\log V](https://private.codecogs.com/gif.latex?\log%20V) [ 请见第 2 章命题 Q（续）]，所以将所有这些加起来可知算法所需时间和 ![E \log V](https://private.codecogs.com/gif.latex?E%20\log%20V) 成正比。

图 4.3.13 展示了 Prim 算法是如何处理含有 250 个顶点的欧几里得图 mediumEWG.txt 的。这是一个很有意思的动态过程（请见练习 4.3.27）。大多数情况下，树的生长都是通过连接一个和新加入的顶点相邻的顶点。当新加入的顶点周围没有非树顶点时，树的生长又会从另一部分开始。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.073.png)

**图 4.3.13　Prim 算法（250 个顶点）**

###4.3.6　Kruskal 算法

我们要仔细学习的第二种最小生成树算法的主要思想是按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中（图中的黑色边），加入的边不会与已经加入的边构成环，直到树中含有 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边为止。这些黑色的边逐渐由一片森林合并为一棵树，也就是图的最小生成树。这种计算方法被称为 **Kruskal 算法**。

>**命题 O**。Kruskal 算法能够计算任意加权连通图的最小生成树。

>**证明**。由命题 K 可知，如果下一条将被加入最小生成树中的边不会和已有的黑色边构成环，那么它就跨越了由所有和树顶点相邻的顶点组成的集合以及它们的补集所构成的一个切分。因为加入的这条边不会形成环、它是目前已知的唯一一条横切边且是按照权重顺序选择的边，所以它必然是权重最小的横切边。因此，该算法能够连续选择权重最小的横切边，和贪心算法一致。

Prim 算法是一条边一条边地来构造最小生成树，每一步都为一棵树添加一条边。Kruskal 算法构造最小生成树的时候也是一条边一条边地构造，但不同的是它寻找的边会连接一片森林中的两棵树。我们从一片由 ![V](https://private.codecogs.com/gif.latex?V) 棵单顶点的树构成的森林开始并不断将两棵树合并（用可以找到的最短边）直到只剩下一棵树，它就是最小生成树。

图 4.3.14 显示的是 Kruskal 算法处理 tinyEWG.txt 时的每一个步骤。首先，权重最小的条边都被加入到了最小生成树中，之后算法判断出 `1-3`、`1-5` 和 `2-7` 已经失效并将 `4-5` 加入最小生成树。最后 `1-2`、`4-7` 和 `0-4` 失效，`6-2` 被加入最小生成树。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.074.png)

**图 4.3.14　Kruskal 算法的轨迹**

有了本书中我们已经学习过的许多工具，Kruskal 算法的实现并不困难：我们将会使用一条优先队列（请见 2.4 节）来将边按照权重排序，用一个 union-find 数据结构（请见 1.5 节）来识别会形成环的边，以及一条队列（请见 1.3 节）来保存最小生成树的所有边。算法 4.8 实现了以上设想。注意，使用**队列**来保存最小生成树的所有边意味着用例在遍历时将会按照权重的升序得到这些边。`weight()` 方法需要遍历所有边来取得权重之和（或是使用一个变量动态统计权重之和），它的实现留作练习（请见练习 4.3.31）。

分析 Kruskal 算法所需的运行时间很简单，因为我们已经知道它的操作所需的时间。

>**命题 N（续）**。Kruskal 算法的计算一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的连通加权无向图的最小生成树所需的空间和 ![E](https://private.codecogs.com/gif.latex?E) 成正比，所需的时间和 ![E \log E](https://private.codecogs.com/gif.latex?E%20\log%20E) 成正比（最坏情况）。

>**证明**。算法的实现在构造函数中使用所有边初始化优先队列，成本最多为 ![2E](https://private.codecogs.com/gif.latex?2E) 次比较（请见 2.4 节）。优先队列构造完成后，其余的部分和 Prim 算法完全相同。优先队列中最多可能含有 ![E](https://private.codecogs.com/gif.latex?E) 条边，即所需空间的上限。每次操作的成本最多为 ![2\lg E](https://private.codecogs.com/gif.latex?2\lg%20E) 次比较，这就是时间上限的由来。Kruskal 算法最多还会进行 ![E](https://private.codecogs.com/gif.latex?E) 次 connected() 和 ![V](https://private.codecogs.com/gif.latex?V) 次 union() 操作，但这些成本相比 ![E \log E](https://private.codecogs.com/gif.latex?E%20\log%20E) 的总时间的增长数量级可以忽略不计（请见 1.5 节）。

与 Prim 算法一样，这个估计是比较保守的，因为算法在找到 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边之后就会终止。实际的成本应该与 ![E+E_0 \log E](https://private.codecogs.com/gif.latex?E+E_0%20\log%20E) 成正比，其中 ![E_{0} ](https://private.codecogs.com/gif.latex?E_{0}) 是权重小于最小生成树中权重最大的边的所有边的总数。尽管拥有这个优势，Kruskal 算法一般还是比 Prim 算法要慢，因为在处理每条边时除了两种算法都要完成的优先队列操作之外，它还需要进行一次 `connect()` 操作（请见练习 4.3.39）。

图 4.3.15 所示为 Kruskal 算法在处理较大的样图 mediumEWG.txt 时的动态情况。很显然，边是按照权重顺序被添加到森林中的。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.075.png)

**图 4.3.15　Kruskal 算法（250 个顶点）**

>**算法 4.8　最小生成树的 Kruskal 算法**

>```
>public class KruskalMST
>{
>    private Queue<Edge> mst;
>
>    public KruskalMST(EdgeWeightedGraph G)
>    {
>       mst = new Queue<Edge>();
>       MinPQ<Edge> pq = new MinPQ<Edge>();
>       for(Edge e:G.edges())pq.insert(e);
>       UF uf = new UF(G.V());
>
>       while (!pq.isEmpty() && mst.size() < G.V()-1)
>       {
>          Edge e = pq.delMin();               // 从pq得到权重最小的边和它的顶点
>          int v = e.either(), w = e.other(v);
>          if (uf.connected(v, w)) continue;   // 忽略失效的边
>          uf.union(v, w);                     // 合并分量
>          mst.enqueue(e);                     // 将边添加到最小生成树中
>       }
>    }
>
>    public Iterable<Edge> edges()
>    {  return mst;  }
>
>    public double weight()          // 请见练习4.3.31
>
>}
>```

>这份 Kruskal 算法的实现使用了一条队列来保存最小生成树中的所有边、一条优先队列来保存还未被检查的边和一个 union-find 的数据结构来判断无效的边。最小生成树的所有边会按照权重的升序返回给用例。`weight()` 方法的实现留作练习。

>```
>% java KruskalMST tinyEWG.txt
>0-7 0.16
>2-3 0.17
>1-7 0.19
>0-2 0.26
>5-7 0.28
>4-5 0.35
>6-2 0.40
>1.81
>```

###4.3.7　展望

最小生成树问题是本书中的被研究的最多的几个问题之一。解决这个问题的基本方法在现代数据结构和算法性能分析手段的发明之前就已经问世了。在当时，计算一幅含有上千条边的图的最小生成树还是一项令人望而生畏的任务。我们学习的最小生成树算法和这些老式方法的不同之处主要在于运用了现代的数据结构来完成一些基本的操作，这（再加上现代的计算能力）使得我们可以计算含有上百万甚至数十亿条边的图的最小生成树。

####4.3.7.1　历史资料

计算稠密图的最小生成树算法（请见练习 4.3.29）最早是由 R.Prim 在 1961 年发明的，随后 E.W.Dijkstra 也独自发明了它。尽管 Dijkstra 的描述更为通用，但这个算法通常被称为 **Prim 算法**。其实算法的基本思想是 V.Jarnik 在 1939 年发明的，所以一些人也将这种方法称为 **Jarnik 算法**并认为 Prim 的（或是 Dijkstra）的贡献在于为稠密图找到了高效的实现算法。在 20 世纪 70 年代优先队列发明之后，它直接被应用在了寻找稀疏图中的最小生成树上。计算稀疏图中的最小生成树所需的时间和 ![E \log E](https://private.codecogs.com/gif.latex?E%20\log%20E) 成正比很快广为人知且并没有将此归功于任何一位研究者。在 1984 年，M.L.Fredman 和 R.E.Tarjan 发明了数据结构斐波纳契堆，将 Prim 算法所需的运行时间在理论上改进到了 ![E+V \log V](https://private.codecogs.com/gif.latex?E+V%20\log%20V)。J.Kruskal 在 1956 年就发表了他的算法，但同样，相关的抽象数据结构在很多年中都没有被仔细研究。有趣的是，Kruskal 的论文中提到了 Prim 算法的一个变种，而 O.Boruvka 在 1926 年（！）的论文中就已经提到了这两种不同的方法。Boruvka 的论文要解决的是一个电力分配的问题并介绍了另外一种用现代数据结构可以轻易实现的方法（请见练习 4.3.43 和练习 4.3.44）。M.Sollin 在 1961 年重新发现了这个方法。该方法随后引起了其他人的注意并成为实现较好的渐进性能的最小生成树算法和并行最小生成树算法的基础。各种最小生成树算法的特点请见表 4.3.5。

**表 4.3.5　各种最小生成树算法的性能特点**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="2">算法</th><th colspan="2"><i>V</i> 个顶点 <i>E</i> 条边，最坏情况下的增长数量级</th></tr>
<tr><th>空间</th><th>时间</th></tr>
<tr><td>延时的 Prim 算法</td><td><i><code>E</code></i></td><td><img src="https://private.codecogs.com/gif.latex?E%20\log%20E" /></td></tr>
<tr><td>即时的 Prim 算法</td><td><i><code>V</code></i></td><td><img src="https://private.codecogs.com/gif.latex?E%20\log%20V" /></td></tr>
<tr><td>Kruskal</td><td><i><code>E</code></i></td><td><img src="https://private.codecogs.com/gif.latex?E%20\log%20E" /></td></tr>
<tr><td>Fredman-Tarjan</td><td><i><code>V</code></i></td><td><img src="https://private.codecogs.com/gif.latex?E+V%20\log%20V" /></td></tr>
<tr><td>Chazelle</td><td><i><code>V</code></i></td><td>非常接近但还没有达到 <img src="https://private.codecogs.com/gif.latex?E" /></td></tr>
<tr><td>理想情况</td><td><i><code>V</code></i></td><td><img src="https://private.codecogs.com/gif.latex?E{?}" /></td></tr>
</table>

####4.3.7.2　线性的最小生成树算法？

一方面，目前还没有理论能够证明，不存在能在线性时间内得到任意图的最小生成树的算法。另一方面，发明能够在线性时间内计算稀疏图的最小生成树的算法仍然没有进展。自从 20 世纪 70 年代将 union-find 数据结构应用于 Kruskal 算法以及将优先队列应用于 Prim 算法之后，更好的实现这些抽象数据结构就成了许多研究者的主要目标。许多研究者都将寻找高效的优先队列的实现作为找到稀疏图的高效的最小生成树算法的关键，而其他一些人则研究了 Boruvka 算法的一些变种并将它们作为近似于线性级别的稀疏图的最小生成树算法的基础。这些研究仍然有希望最终为我们带来一个实用的线性最小生成树算法，它们甚至已经显示了一个线性时间的随机化算法的存在性。研究者距离线性时间的目标已经很近了：B.Chazelle 在 1997 年发表了一个算法，它在实际应用中和线性时间的算法的差距已经小到了无法区别的程度（尽管可以证明它并不是线性的），但它非常复杂以至于无法实用。尽管此类研究得到的算法大都十分复杂，其中一些的简化版也许可以进入实际应用。同时，在大多数应用场景中，我们都可以使用已经学过的基本方法在线性时间内得到图的最小生成树，只是对于一些稀疏图所需的时间要乘以 ![\log V](https://private.codecogs.com/gif.latex?\log%20V)。

总的来说，我们可以认为在实际应用中最小生成树问题已经被“解决”了。对于大多数的图来说，找到它的最小生成树的成本只比遍历图的所有边稍高一点。除了极为稀疏的图，这一点都能成立，但即使是在这种情况下，使用最好的算法所能得到的性能提升也不过是一个很小的常数因子，可能最多 10 倍。人们已经在许多图的模型中证明了这些结论，而很多实践者则已经使用 Prim 算法和 Kruskal 算法计算大型图中的最小生成树数十年之久了。

###答疑

**问**　Prim 和 Kruskal 算法能够处理有向图吗？

**答**　不行，不可能。那是一个更加困难的有向图处理问题，叫做**最小树形图**问题。

###练习

**4.3.1**　证明可以将图中的所有边的权重都加上一个正常数或是都乘以一个正常数，图的最小生成树不会受到影响。

**4.3.2**　画出图 4.3.16 中的所有最小生成树（所有边的权重均相等）。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.076.png)

**图　4.3.16**

**4.3.3**　证明当图中所有边的权重均不相同时图的最小生成树是唯一的。

**4.3.4**　证明或给出反例：仅当加权无向图中所有边的权重均不相同时图的最小生成树是**唯一**的。

**4.3.5**　证明即使存在权重相同的边贪心算法仍然有效。

**4.3.6**　从 tinyEWG.txt 中（请见图 4.3.1）删去顶点 7 并给出加权图的最小生成树。

**4.3.7**　如何得到一幅加权图的**最大**生成树？

**4.3.8**　证明**环的性质**：任取一幅加权图中的一个环（边的权重各不相同），环中权重最大的边必然不属于图的最小生成树。

**4.3.9**　根据 `Graph` 中的构造函数（请见 4.1.2.2 框注“`Graph` 数据类型”）为 `EdgeWeightedGraph` 实现一个相应构造函数，从输入流中读取一幅图。

**4.3.10**　为稠密图实现 `EdgeWeightedGraph`，使用邻接矩阵（存储权重的二维数组），不允许存在平行边。

**4.3.11**　使用 1.4 节中的内存使用模型评估用 `EdgeWeightedGraph` 表示一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的图所需的内存。

**4.3.12**　假设加权图中的所有边的权重都不相同，其中权重最小的边一定属于图的最小生成树吗？权重最大的边可能属于图的最小生成树吗？任意环中的权重最小边都属于图的最小生成树吗？证明你的每个回答或者给出相应的反例。

**4.3.13**　给出一个反例证明以下策略不一定能够找到图的最小生成树：首先以任意顶点作为图的最小生成树，然后向树中添加 ![V-1](https://private.codecogs.com/gif.latex?V-1) 条边，每次总是添加依附于最近加入最小生成树的顶点的所有边中的权重最小者。

**4.3.14**　给定一幅加权图 ![G](https://private.codecogs.com/gif.latex?G) 以及它的最小生成树。从 ![G](https://private.codecogs.com/gif.latex?G) 中删去一条边且 ![G](https://private.codecogs.com/gif.latex?G) 仍然是连通的，如何在与 ![E](https://private.codecogs.com/gif.latex?E) 成正比的时间内找到新图的最小生成树。

**4.3.15**　给定一幅加权图 ![G](https://private.codecogs.com/gif.latex?G) 以及它的最小生成树。向 ![G](https://private.codecogs.com/gif.latex?G) 中添加一条边 ![e](https://private.codecogs.com/gif.latex?e)，如何在与 ![V](https://private.codecogs.com/gif.latex?V) 成正比的时间内找到新图的最小生成树。

**4.3.16**　给定一幅加权图 ![G](https://private.codecogs.com/gif.latex?G) 以及它的最小生成树。向 ![G](https://private.codecogs.com/gif.latex?G) 中添加一条边 ![e](https://private.codecogs.com/gif.latex?e)，编写一段程序找到 ![e](https://private.codecogs.com/gif.latex?e) 的权重在什么范围之内才会被加入最小生成树。

**4.3.17**　为 `EdgeWeightedGraph` 类实现 `toString()` 方法。

**4.3.18**　给出使用延时 Prim 算法、即时 Prim 算法和 Kruskal 算法在计算练习 4.3.6 中的图的最小生成树过程中的轨迹。

**4.3.19**　假设你使用的优先队列的实现会维护一条有序链表。在最坏情况下，用 Prim 算法和 Kruskal 算法处理一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的加权图的时间增长数量级是多少？这种方法适用于什么情况？证明你的结论。

**4.3.20**　真假判断：在 Kruskal 算法的执行过程中，最小生成树中的每个顶点到它的子树中的某个顶点的距离比到非子树中的任意顶点都近。证明你的结论。

**4.3.21**　为 `PrimMST` 类（请见算法 4.7）实现 `edges()` 方法。

　　　**解答**：

```
public Iterable<Edge> edges()
{
   Bag<Edge> mst = new Bag<Edge>();
   for (int v = 1; v < edgeTo.length; v++)
      mst.add(edgeTo[v]);
   return mst;
}
```

###提高题

**4.3.22**　**最小生成森林**。开发新版本的 Prim 算法和 Kruskal 算法来计算一幅加权图的最小生成**森林**，图不一定是连通的。使用 4.1 节中连通分量的 API 并找到每个连通分量的最小生成树。

**4.3.23**　**Vyssotsky 算法**。开发一种不断使用环的性质（请见练习 4.3.8）来计算最小生成树的算法：每次将一条边添加到假设的最小生成树中，如果形成了一个环则删去环中权重最大的边。**注意**：这个算法不如我们学过的几种方法引人注意，因为很难找到一种数据结构能够有效支持“删除环中权重最大的边”的操作。

**4.3.24**　**逆向删除算法**。实现以下计算最小生成树的算法：开始时图含有原图的所有边，然后按照权重大小的降序排列遍历所有的边。对于每条边，如果删除它图仍然是连通的，那就删掉它。证明这种方法可以得到图的最小生成树。实现中加权边的比较次数增长的数量级是多少？

**4.3.25**　**最坏情况生成器**。开发一个加权图生成器，图中含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边，使得延时的 Prim 算法所需的运行时间是非线性的。对于即时的 Prim 算法回答相同的问题。

**4.3.26**　**关键边**。**关键边**指的是图的最小生成树中的某一条边，如果删除它，新图的最小生成树的总权重将会大于原最小生成树的总权重。找到在 ![E \log E](https://private.codecogs.com/gif.latex?E%20\log%20E) 时间内找出图的关键边的算法。**注意**：这个问题中边的权重并不一定各不相同（否则最小生成树中的所有边都是关键边）。

**4.3.27**　**动画**。编写一段程序将最小生成树算法用动画表现出来。用程序处理 mediumEWG.txt 来产生类似于图 4.3.12 和图 4.3.14 的示意图。

**4.3.28**　**空间最优的数据结构**。实现另一个版本的延时 Prim 算法，在 `EdgeWeightedGraph` 和 `MinPQ` 中使用低级数据结构代替 `Bag` 和 `Edge` 来节省空间。根据 1.4 节中的内存使用模型用一个 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E) 的函数评估节省的内存总量（参考练习 4.3.11）。

**4.3.29**　**稠密图**。实现另一个版本的 Prim 算法，即时（但不使用优先队列）且能够在 ![V^2](https://private.codecogs.com/gif.latex?V^2) 次加权边比较之内得到最小生成树。

**4.3.30**　**欧几里得加权图**。修改你为练习 4.1.36 给出的解答，为平面图创建一份 API——`EuclideanEdgeWeightedGraph`，这样你就能够处理用图形表示的图了。

**4.3.31**　**最小生成树的权重**。为 `LazyPrimMST`、`PrimMST` 和 `KruskalMST` 实现 `weight()` 方法，使用**延时**策略，只在被调用时才遍历最小生成树的所有边来计算总权重。然后用**即时**策略再次实现这个方法，在计算最小生成树的过程中维护一个动态的总权重。

**4.3.32**　**指定的集合**。给定一幅连通的加权图 ![G](https://private.codecogs.com/gif.latex?G) 和一个边的集合 ![S](https://private.codecogs.com/gif.latex?S)（不含环），给出一种算法得到含有 ![S](https://private.codecogs.com/gif.latex?S) 中的所有边的最小加权生成树。

**4.3.33**　**验证**。编写一个使用最小生成树算法以及 `EdgeWeightedGraph` 类的方法 `check()`，使用以下根据命题 J 得到的**最优切分条件**来验证给定的一组边就是一棵最小生成树：如果给定的一组边是一棵生成树，且删除树中的任意边得到的切分中权重最小的横切边正是被删除的那条边，则这组边就是图的最小生成树。你的方法的运行时间的增长数量级是多少？

###实验题

**4.3.34**　**随机稀疏加权图**。基于你为练习 4.1.40 给出的解答编写一个随机稀疏加权图生成器。在赋予边的权重时，定义一个随机加权图的抽象数据结构并给出两种实现：一种按均匀分布生成权重，另一种按高斯分布生成权重。编写用例程序，用两种权重分布和一组精心挑选过的 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E) 的值生成随机的稀疏加权图，使得我们可以用它对权重的各种分布进行有意义的经验性测试。

**4.3.35**　**随机欧几里得加权图**。修改你为练习 4.1.41 给出的解答，将每条边的权重设为顶点之间的距离。

**4.3.36**　**随机网格加权图**。修改你为练习 4.1.42 给出的解答，将每条边的权重设为 0 到 1 之间的随机值。

**4.3.37**　**真实世界中的加权图**。从网上找出一幅巨型加权无向图——可以是标注了距离的地图，或是标明了资费的电话黄页，或是航线的价目表。编写一段程序 `RandomRealEdgeWeightedGraph`，从这幅巨型加权无向图中随机选取 ![V](https://private.codecogs.com/gif.latex?V) 个顶点，然后再从这些顶点构成的子图中随机选取 ![E](https://private.codecogs.com/gif.latex?E) 条边来构造一幅图。

>　　测试所有的算法并研究所有图的模型的所有参数是不现实的。请为下面的每一道题都编写一段程序来处理从输入得到的任意图。这段程序可以调用上面的任意生成器并对相应的图模型进行实验。你可以根据上次实验的结果自己作出判断来选择不同实验。陈述结果以及由此得出的任何结论。

**4.3.38**　**延时的代价**。对于各种图的模型，运行实验并根据经验比较 Prim 算法的延时版本和即时版本的性能差异。

**4.3.39**　**对比 Prim 算法与 Kruskal 算法**。运行实验并根据经验比较 Prim 算法的延时版本和即时版本与 Kruskal 算法的性能差异。

**4.3.40**　**减少开销**。运行实验并根据经验判断练习 4.3.28 中在 `EdgeWeightedGraph` 类中使用原始数据类型代替 `Edge` 所带来的效果。

**4.3.41**　**最小生成树中的最长边**。运行实验并根据经验分析最小生成树中最长边的长度以及图中不长于该边的边的总数。

**4.3.42**　**切分**。根据快速排序的切分思想（而非使用优先队列）实现一种新方法，检查 Kruskal 算法中的当前边是否属于最小生成树。

**4.3.43**　**Boruvka 算法**。实现 Boruvka 算法：和 Kruskal 算法类似，只是分阶段地向一组森林中逐渐添加边来构造一棵最小生成树。在每个阶段中，找出所有连接两棵不同的树的权重最小的边，并将它们全部加入最小生成树。为了避免出现环，假设所有边的权重均不相同。**提示**：维护一个由顶点索引的数组来辨别连接每棵树和它最近的邻居的边。记得用上 union-find 数据结构。

**4.3.44**　**改进的 Boruvka 算法**。给出 Boruvka 算法的另一种实现，用双向环形链表表示最小生成树的子树，使得子树可以被合并或改名，每个阶段所需的时间与 ![E](https://private.codecogs.com/gif.latex?E) 成正比（这样就不需要 union-find 数据结构了）。

**4.3.45**　**外部最小生成树**。如果一幅图非常大，内存最多只能存储 ![V](https://private.codecogs.com/gif.latex?V) 条边，如何计算它的最小生成树？

**4.3.46**　**Johnson 算法**。使用一个 ![d](https://private.codecogs.com/gif.latex?d) 向堆实现优先队列（请见练习 2.4.41）。对于各种图的模型，找到 ![d](https://private.codecogs.com/gif.latex?d) 的最优值。

##4.4　最短路径

也许最直观的图处理问题就是你常常需要使用某种地图软件或者导航系统来获取从一个地方到达另一个地方的路径。我们立即可以得到与之对应的图模型：顶点对应交叉路口，边对应公路，边的权重对应经过该路段的成本，可以是时间或者距离。如果有单行线，那就意味着还需要考虑加权有向图。在这个模型中，问题很容易就可以被归纳为：

>找到从一个顶点到达另一个顶点的成本最小的路径。

除了这类问题的直接应用，最短路径模型还适用于一系列其他问题（请见表 4.4.1），其中有一些看起来似乎和图的处理毫无关系。举个例子，我们会在本节的最后考虑金融学领域的**套汇**问题。

**表 4.4.1　最短路径的典型应用**

|应用|顶点|边|
|-|-|-|
|地图|交叉路口|公路|
|网络|路由器|网络连接|
|任务调度|任务|优先级限制|
|套汇|货币|汇率|

我们采用了一个一般性的模型，即**加权有向图**（它是 4.2 节和 4.3 节的模型的结合）。在 4.2 节中我们希望知道从一个顶点**是否**可以到达另一个顶点。在本节中，我们会把权重考虑进来，就像在 4.3 节中研究的加权无向图那样。在加权有向图中，每条有向路径都有一个与之关联的**路径权重**，它是路径中的所有边的权重之和。这种重要的度量方式使得我们能够将这个问题归纳为“找到从一个顶点到达另一个顶点的权重最小的有向路径”，也就是本节的主题。图 4.4.1 就是一个示例。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.077.png)

**图 4.4.1　一幅加权有向图和其中的一条最短路径**

>**定义**。在一幅加权有向图中，从顶点 `s` 到顶点 `t` 的**最短路径**是所有从 `s` 到 `t` 的路径中的权重最小者。

本节中，我们将会学习解决下面这个问题的经典算法。

**单点最短路径**。给定一幅加权有向图和一个起点 `s`，回答“**从 `s` 到给定的目的顶点 `v` 是否存在一条有向路径？**如果有，找出**最短**（总权重最小）的那条路径。”等类似问题。

我们计划在本节中讨论下列问题：

* 加权有向图的 API 和实现以及单点最短路径的 API；
* 解决边的权重非负的最短路径问题的经典 Dijkstra 算法；
* 在无环加权有向图中解决该问题的一种快速算法，边的权重甚至可以是负值；
* 适用于一般情况的经典 Bellman-Ford 算法，其中图可以含有环，边的权重也可以是负值。我们还需要算法来找出负权重的环，以及不含有这种环的加权有向图中的最短路径。

在学习了这些算法之后，我们还会考虑它们的应用。

###4.4.1　最短路径的性质

最短路径问题的基本定义是很简单的，但这种简洁也隐藏了一些在学习相关的算法和数据结构之前需要解决的问题。

* **路径是有向的**。最短路径需要考虑到各条边的方向。
* **权重不一定等价于距离**。几何上的直觉可以帮助你理解算法，因此示例中的顶点都在平面上且权重为顶点之间的欧几里得距离，例如图 4.4.1 所示的那幅有向图。但权重也可以表示时间、花费或是某种完全无关的东西，也不一定会和距离的远近成正比。我们使用了双关性的术语来强调这一点，指的是**权重**或是**成本最短**的路径。
* **并不是所有顶点都是可达的**。如果 `t` 并不是从 `s` 可达的，那么就不存在任何路径，也就不存在 `s` 到 `t` 的最短路径。为了简化问题，我们的样图都是强连通的（每个顶点从另外任意一个顶点都是可达的）。
* **负权重会使问题更复杂**。我们暂时假设边的权重都是正的（或零）。负权重所带来的意外效应是本节最后部分的重点。
* **最短路径一般都是简单的**。我们的算法会忽略构成环的零权重边，因此找到的最短路径都不会含有环。
* **最短路径不一定是唯一的**。从一个顶点到达另一个顶点的权重最小的路径可能有多条，我们只要找到其中一条即可。
* **可能存在平行边和自环**：平行边中的权重最小者才会被选中，最短路径也不可能包含自环（除非自环的权重为零，但我们会忽略它）。在正文中，为了避免歧义我们隐式地假设平行边不存在，用 `v` → `w` 来表示从 `v` 到 `w` 的边，本节的代码处理它们并没有困难。

**最短路径树**

我们的重点是**单点最短路径问题**，其中给出了起点 `s`，计算的结果是一棵**最短路径树** (SPT)，它包含了顶点 `s` 到所有可达的顶点的最短路径。如图 4.4.2 所示。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.078.png)

**图 4.4.2　最短路径树**

>**定义**。给定一幅加权有向图和一个顶点 `s`，以 `s` 为起点的一棵**最短路径树**是图的一幅子图，它包含 `s` 和从 `s` 可达的所有顶点。这棵有向树的根结点为 s，树的每条路径都是有向图中的一条最短路径。

这样一棵树是一定存在的：一般来说，从 `s` 到一个顶点有可能存在两条长度相等的路径。如果出现这种情况，可以删除其中一条路径的最后一条边。如此这般，直到从起点到每个顶点都只有一条路径相连（即一棵树，请见图 4.4.3）。通过构造这棵最短路径树，可以为用例提供从 `s` 到图中任何顶点的最短路径，表示方法为一组指向父结点的链接，和 4.1 节中表示路径的方法完全一样。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.079.png)

**图 4.4.3　一棵含有 250 个顶点的最短路径树**

###4.4.2　加权有向图的数据结构

有向边的数据结构比无向边更加简单，因为有向边只有一个方向。与 `Edge` 类中的 `either()` 和 `other()` 方法不同，这里定义了 `from()` 和 `to()` 方法，请见表 4.4.2。

**表 4.4.2　加权有向边的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>DirectedEdge</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirectedEdge(int v, int w, double weight)</code></td><td></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;weight()</code></td><td>边的权重</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;from()</code></td><td>指出这条边的顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;to()</code></td><td>这条边指向的顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>
</table>

从 4.1 节到 4.3 节，从 `Graph` 类过渡到了 `EdgeWeightedGraph` 类。与以前一样，我们在这里添加了 `edges()` 方法并使用 `DirectedEdge` 类代替了整型变量，请见表 4.4.3。

**表 4.4.3　加权有向图的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>EdgeWeightedDigraph</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeWeightedDigraph(int V)</code></td><td>含有 <code>V</code> 个顶点的空有向图</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EdgeWeightedDigraph(In in)</code></td><td>从输入流中读取图的构造函数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;V()</code></td><td>顶点总数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;E()</code></td><td>边的总数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;addEdge(DirectedEdge e)</code></td><td>将 <code>e</code> 添加到该有向图中</td></tr>
<tr><td><code>Iterable&lt;DirectedEdge>&nbsp;&nbsp;adj(int v)</code></td><td>从 <code>v</code> 指出的边</td></tr>
<tr><td><code>Iterable&lt;DirectedEdge>&nbsp;&nbsp;edges()</code></td><td>该有向图中的所有边</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>
</table>

这两份 API 的实现请见后面的框注“加权有向边的数据类型”和“加权有向图的数据类型”。它们很自然地扩展了 4.2 节和 4.3 节中相应的类的实现。`Digraph` 类中的邻接表使用的是整数，在 `EdgeWeightedDigraph` 的邻接表中使用的是 `DirectedEdge` 对象。与从 4.1 节到 4.2 节中 `Graph` 类到 `Digraph` 类的转换一样，从 4.3 节的 `EdgeWeightedGraph` 类到本节中的 `EdgeWeightedDigraph` 类的转换代码也变得简单了，因为在数据结构中每条边只会出现一次。

>**加权有向边的数据类型**

>```
>public class DirectedEdge
>{
>    private final int v;                       // 边的起点
>    private final int w;                       // 边的终点
>    private final double weight;               // 边的权重
>
>    public DirectedEdge(int v, int w, double weight)
>    {
>       this.v = v;
>       this.w = w;
>       this.weight = weight;
>    }
>
>    public double weight()
>    {  return weight;  }
>
>    public int from()
>
>    {  return v;  }
>
>    public int to()
>    {  return w;  }
>
>    public String toString()
>    {  return String.format("%d->%d %.2f", v, w, weight);  }
>}
>```

>`DirectedEdge` 类的实现比 4.3 节中无向边的数据类型 `Edge` 类（请见 4.3.2 节框注“带权重的边的数据类型”）更简单，因为边的两个端点是有区别的。用例可以使用惯用代码 `int v=e.from(), w=e.to();` 来访问 `DirectedEdge` 的两个端点。

　

>**加权有向图的数据类型**

>![{66%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.080.png)

>`EdgeWeightedDigraph` 类的实现混合了 `EdgeWeightedGraph` 类和 `Digraph` 类。它维护了一个由顶点索引的 `Bag` 对象的数组，`Bag` 对象的内容为 `DirectedEdge` 对象。与 `Digraph` 类一样，每条边在邻接表中只会出现一次：如果一条边从 `v` 指向 `w`，那么它只会出现在 `v` 的邻接链表中。这个类可以处理自环和平行边。`toString()` 方法的实现留作练习 4.4.2。

图 4.4.4 所示的是用 `EdgeWeightedDigraph` 表示左侧的加权有向图时所构造的数据结构，在构造的过程中边被按照顺序一条一条地加入图中。与以前一样，我们使用了 Bag 类来表示邻接表并在图中按照标准方式将它们表示为链表。与 4.2 节中普通的有向图一样，每条边在数据结构中都只出现了一次。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.081.png)

**图 4.4.4　加权有向图的表示**

####4.4.2.1　最短路径的 API

对于最短路径的 API，我们的设计思路与 4.1 节中的 `DepthFirstPaths` 和 `BreadthFirstPaths` 的 API 是一样的。算法将会实现表 4.4.4 所示的 API 来为用例提供图中的最短路径和其长度。

**表 4.4.4　最短路径的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class <b>SP</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SP(EdgeWeightedDigraph G, int s)</code></td><td>构造函数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double distTo(int v)</code></td><td>从顶点 <code>s</code> 到 <code>v</code> 的距离，如果不存在则路径为无穷大</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean hasPathTo(int v)</code></td><td>是否存在从顶点 <code>s</code> 到 <code>v</code> 的路径</td></tr>
<tr><td><code>Iterable&lt;DirectedEdge> pathTo(int v)</code></td><td>从顶点 <code>s</code> 到 <code>v</code> 的路径，如果不存在则为 <code>null</code></td></tr>
</table>

构造函数会创建最短路径树并计算最短路径的长度，其他查询方法则会使用这些数据结构为用例提供路径的长度以及路径的 `Iterable` 对象。

####4.4.2.2　测试用例

右侧框注是一个简单测试用例。它接受一个输入流和一个起点作为命令行参数，从输入流中读取加权有向图，根据起点来计算有向图的最短路径树并打印从起点到其他所有顶点的最短路径。我们约定，所有的最短路径实现都使用该测试用例进行测试。图 4.4.4 中的 tinyEWD.txt 文件定义了一幅较小的示例有向图中所有的边和权重，会用来显示最短路径算法的详细轨迹。它的文件格式与最小生成树算法中使用的样图相同：首先是顶点总数 ![V](https://private.codecogs.com/gif.latex?V) 和边的总数 ![E](https://private.codecogs.com/gif.latex?E)，随后是 ![E](https://private.codecogs.com/gif.latex?E) 行数据，每一行为两个顶点的索引和一个权重。在本书的网站上，你可以找到一些定义了更大的加权有向图的文件，包括 mediumEWG.txt。它定义了一幅含有 250 个顶点的加权有向图，如图 4.4.3 所示。在这幅图的图像中，每一行数据都表示方向相反的两条边，因此这个文件所含有的边数是在学习最小生成树时所使用的 mediumEWG.txt 的 2 倍。在最短路径树的图像中，每一行都表示一条从顶点指出的有向边。

```
  public static void main(String[] args)
  {
     EdgeWeightedDigraph G;
     G = new EdgeWeightedDigraph(new In(args[0]));
     int s = Integer.parseInt(args[1]);
     SP sp = new SP(G, s);

     for (int t = 0; t < G.V(); t++)
     {
        StdOut.print(s + " to " + t);
        StdOut.printf(" (%4.2f): ", sp.distTo(t));
        if (sp.hasPathTo(t))
           for (DirectedEdge e : sp.pathTo(t))
              StdOut.print(e + "   ");
        StdOut.println();
     }
  }

% java SP tinyEWD.txt 0
0 to 0 (0.00):
0 to 1 (1.05): 0->4 0.38  4->5 0.35  5->1 0.32
0 to 2 (0.26): 0->2 0.26
0 to 3 (0.99): 0->2 0.26  2->7 0.34  7->3 0.39
0 to 4 (0.38): 0->4 0.38
0 to 5 (0.73): 0->4 0.38  4->5 0.35
0 to 6 (1.51): 0->2 0.26  2->7 0.34  7->3 0.39  3->6  0.52
0 to 7 (0.60): 0->2 0.26  2->7 0.34
```

{-:-}最短路径的测试用例

####4.4.2.3　最短路径的数据结构

表示最短路径所需的数据结构很简单，如图 4.4.5 所示。

![{75%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.082.png)

**图 4.4.5　最短路径的数据结构**

* **最短路径树中的边**。和深度优先搜索、广度优先搜索和 Prim 算法一样，使用一个由顶点索引的 `DirectedEdge` 对象的父链接数组 `edgeTo[]`，其中 `edgeTo[v]` 的值为树中连接 `v` 和它的父结点的边（也是从 `s` 到 `v` 的最短路径上的最后一条边）。
* **到达起点的距离**。我们需要一个由顶点索引的数组 `distTo[]`，其中 `distTo[v]` 为从 `s` 到 `v` 的已知最短路径的长度。

我们约定，`edgeTo[s]` 的值为 `null`，`distTo[s]` 的值为 `0`。同时还约定，从起点到不可达的顶点的距离均为 `Double.POSITIVE_INFINITY`。和以前一样，我们会实现使用这些数据结构的数据类型并支持用例调用方法来查询最短路径和它们的长度。

####4.4.2.4　边的松弛

我们的最短路径 API 的实现都基于一个被称为**松弛**（relaxation）的简单操作。一开始我们只知道图的边和它们的权重，`distTo[]` 中只有起点所对应的元素的值为 `0`，其余元素的值均被初始化为 `Double.POSITIVE_INFINITY`。随着算法的执行，它将起点到其他顶点的最短路径信息存入了 `edgeTo[]` 和 `distTo[]` 数组中。在遇到新的边时，通过更新这些信息就可以得到新的最短路径。特别是，我们在其中会用到**边的松弛**技术，定义如下：**放松**边 `v` → `w` 意味着检查从 `s` 到 `w` 的最短路径是否是先从 `s` 到 `v`，然后再由 `v` 到 `w`。如果是，则根据这个情况更新数据结构的内容。上边框注中的代码实现了这个操作。由 `v` 到达 `w` 的最短路径是 `distTo[v]` 与 `e.weight()` 之和——如果这个值不小于 `distTo[w]`，称这条边**失效**了并将它忽略；如果这个值更小，就更新数据。

```
private void relax(DirectedEdge e)
{
   int v = e.from(), w = e.to();
   if (distTo[w] > distTo[v] + e.weight())
   {
       distTo[w] = distTo[v] + e.weight();
       edgeTo[w] = e;
   }
}
```

{-:-}

图 4.4.6 显示的是边的放松操作之后可能出现的两种情况。一种情况是边失效（左边的例子），不更新任何数据；另一种情况是 `v` → `w` 就是到达 `w` 的最短路径（右边的例子），这将会更新 `edgeTo[w]` 和 `distTo[w]`（这可能会使另一些边失效，但也可能产生一些新的有效边）。**松弛**这个术语来自于用一根橡皮筋沿着连接两个顶点的路径紧紧展开的比喻：放松一条边就类似于将橡皮筋转移到一条更短的路径上，从而缓解了橡皮筋的压力。如果 `relax()` 改变了和边 `e` 相关的顶点的 `distTo[e.to()]` 和 `edgeTo[e.to()]` 的值，就称 `e` 的**放松是成功的**。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.083.png)

**图 4.4.6　边的松弛的两种情况**

####4.4.2.5　顶点的松弛

实际上，实现会放松从一个给定顶点指出的所有边，如下页框注中（被重载的）`relax()` 的实现所示。注意，从任意 `distTo[v]` 为有限值的顶点 `v` 指向任意 `distT[]` 为无穷的顶点的边都是有效的。如果 `v` 被放松，那么这些有效边都会被添加到 `edgeTo[]` 中。某条从起点指出的边将会是第一条被加入 `edgeTo[]` 中的边。算法会谨慎选择顶点，使得每次顶点松弛操作都能得出到达某个顶点的更短的路径，最后逐渐找出到达每个顶点的最短路径。如图 4.4.7 所示。

```
private void relax(EdgeWeightedDigraph G, int v)
{
   for (DirectedEdge e : G.adj(v))
   {
      int w = e.to();
      if (distTo[w] > distTo[v] + e.weight())
      {
         distTo[w] = distTo[v] + e.weight();
         edgeTo[w] = e;
     }
   }
}
```

{-:-}顶点的松弛

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.084.png)

**图 4.4.7　顶点的松弛**

####4.4.2.6　为用例准备的查询方法

与 4.1 节（以及练习 4.1.13）中实现路径查找的 API 相似，`edgeTo[]` 和 `distTo[]` 数组直接支持 `pathTo()`、`hasPathTo()` 和 `distTo()` 查询方法，如下方框注所示。默认所有最短路径的实现都包含这段代码。前面已经提到过，只有在 `v` 是从 `s` 可达的情况下，`distTo[v]` 才是有意义的，还已经约定，对于从 `s` 不可达的顶点，`distTo()` 方法都应该返回无穷大。在实现这个约定时，将 `distTo[]` 中的所有元素都初始化为 `Double.POSITIVE_INFINITY`，`distTo[s]` 则为 `0`。最短路径算法会将从起点可达的顶点 `v` 的 `distTo[v]` 设为一个有限值，这样就不必再用 `marked[]` 数组来在图的搜索中标记可达的顶点，而是通过检测 `distTo[v]` 是否为 `Double.POSITIVE_INFINITY` 来实现 `hasPathTo(v)`。对于 `pathTo()` 方法，我们约定如果 `v` 不是从起点可达的则返回 `null`，如果 `v` 等于起点则返回一条不含任何边的路径。对于可达的顶点，我们会遍历最短路径树并返回栈上的所有边，这和 `DepthFirstPaths` 以及 `BreadthFirstPaths` 的做法完全一样。图 4.4.8 显示了在示例中路径 `0` → `2` → `7` → `3` → `6` 是如何被找到的。

```
public double distTo(int v)
{   return distTo[v];   }

public boolean hasPathTo(int v)
{   return distTo[v] < Double.POSITIVE_INFINITY;  }

public Iterable<DirectedEdge> pathTo(int v)
{
   if (!hasPathTo(v)) return null;
   Stack<DirectedEdge> path = new Stack<DirectedEdge>();
   for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()])
      path.push(e);
   return path;
}
```

{-:-}最短路径 API 中的查询方法

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.085.png)

**图 4.4.8　`pathTo()` 方法的计算轨迹**

###4.4.3　最短路径算法的理论基础

边的放松操作是一项非常容易实现的重要操作，它是实现最短路径算法的基础。同时，它也是理解这个算法的理论基础并使我们能够完整地证明算法的正确性。

####4.4.3.1　最优性条件

以下命题证明了判断路径是否为最短路径的**全局**条件与在放松一条边时所检测的**局部**条件是等价的。

>**命题 P（最短路径的最优性条件）**。令 ![G](https://private.codecogs.com/gif.latex?G) 为一幅加权有向图，顶点 `s` 是 ![G](https://private.codecogs.com/gif.latex?G) 中的起点，`distTo[]` 是一个由顶点索引的数组，保存的是 ![G](https://private.codecogs.com/gif.latex?G) 中路径的长度。对于从 `s` 可达的所有顶点 `v`，`distTo[v]` 的值是从 `s` 到 `v` 的**某条**路径的长度，对于从 `s` 不可达的所有顶点 `v`，该值为无穷大。当且仅当对于从 `v` 到 `w` 的任意一条边 `e`，这些值都满足 `distTo[w]<=distTo[v]+e.weight()` 时（换句话说，不存在有效边时），它们是**最短**路径的长度。

>**证明**。假设 `distTo[w]` 是从 `s` 到 `w` 的最短路径。如果对于某条从 `v` 到 `w` 的边 `e` 有 `distTo[w]>distTo[v]+e.weight()`，那么从 `s` 到 `w`（经过 `v`）且经过 `e` 的路径的长度必然小于 `distTo[w]`，矛盾。因此最优性条件是必要的。

>要证明最优性条件是充分的，假设 `w` 是从 `s` 可达的且 <code>s=v<sub>0</sub></code> → <code>v<sub>1</sub></code> → <code>v<sub>2</sub></code>... → <code>v<i><sub>k</sub></i></code>=`w` 是从 `s` 到 `w` 的最短路径，其权重为 <code>OPT<sub>sw</sub></code>。对于 `1` 到 _`k`_ 之间的 _`i`_，令 <code>e<sub><i>i</i></sub></code> 表示 <code>v<sub><i>i</i>-1</sub></code> 到 <code>v<sub><i>i</i></sub></code> 的边。根据最优性条件，可以得到以下不等式：

>![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.086.png)

>综合这些不等式并去掉 `distTo[s]=0.0`，得到：

>{-:-}<code>distTo[w] <= e<sub>1</sub>.weight() + ... + e<sub><i>k</i></sub>.weight() = OPT<sub>SW</sub></code>.

>现在，`distTo[w]` 为从 `s` 到 `w` 的**某条**边的长度，因此它不可能比**最短**路径更短。所以我们有以下不等式：

>{-:-}<code>OPT<sub>SW</sub> <= distTo[w] <= OPT<sub>SW</sub></code>

>且等号必然成立。

####4.4.3.2　验证

命题 P 的一个重要的实际应用是最短路径的验证。无论一种算法会如何计算 `distTo[]`，都只需要遍历图中的所有边一遍并检查最优性条件是否满足就能够知道该数组中的值是否是最短路径的长度。最短路径的算法可能会很复杂，因此能够快速验证计算的结果就变得很重要。为此，我们在本书的网站上的实现中包含了一个 `check()` 方法。该方法还会检查 `edgeTo[]` 指明的路径并验证它与 `distTo[]` 是否一致。

####4.4.3.3　通用算法

由最优性条件马上可以得到一个能够涵盖已经学习过的所有最短路径算法的通用算法。现在，我们暂时只研究非负权重的情况。

>**命题 Q（通用最短路径算法）**。将 `distTo[s]` 初始化为 0，其他 `distTo[]` 元素初始化为无穷大，继续如下操作：

>{-:-}**放松 `G` 中的任意边，直到不存在有效边为止。**

>对于任意从 `s` 可达的顶点 `w`，在进行这些操作之后，`distTo[w]` 的值即为从 `s` 到 `w` 的最短路径的长度（且 `edgeTo[w]` 的值即为该路径上的最后一条边）。

>**证明**。放松边 `v` → `w` 必然会将 `distTo[w]` 的值设为从 `s` 到 `w` 的某条路径的长度（且将 `edgeTo[w]` 设为该路径上的最后一条边）。对于从 `s` 可达的任意顶点 `w`，只要 `distTo[w]` 仍然是无穷大，到达 `w` 的最短路径上的某条边肯定仍然是有效的，因此算法的操作会不断继续，直到由 `s` 可达的每个顶点的 `distTo[]` 值均变为到达该顶点的某条路径的长度。对于已经找到最短路径的任意顶点 `v`，在算法的计算过程中 `distTo[v]` 的值都是从 `s` 到 `v` 的某条（简单）路径的长度且必然是单调递减的。因此，它递减的次数必然是有限的（每切换一条 `s` 到 `v` 简单路径就递减一次）。当不存在有效边的时候，命题 P 就成立了。

将最优性条件和通用算法放在一起学习的关键原因是，**通用算法并没有指定边的放松顺序**。因此，要证明这些算法都能通过计算得到最短路径，只需证明它们都会放松所有的边直到所有边都失效即可。

###4.4.4　Dijkstra 算法

在 4.3 节中，我们讨论了寻找加权无向图中的最小生成树的 Prim 算法：构造最小生成树的每一步都向这棵树中添加一条新的边。**Dijkstra 算法**采用了类似的方法来计算最短路径树。首先将 `distTo[s]` 初始化为 0，`distTo[]` 中的其他元素初始化为正无穷。然后将 `distTo[]` **最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的 `distTo[]` 值均为无穷大**。

>**命题 R**。Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。

>**证明**。如果 `v` 是从起点可达的，那么所有 `v` → `w` 的边都只会被放松一次。当 `v` 被放松时，必有 `distTo[w]<=distTo[v]+e.weight()`。该不等式在算法结束前都会成立，因此 `distTo[w]` 只会变小（放松操作只会减小 `distTo[]` 的值）而 `distTo[v]` 则不会改变（因为边的权重非负且在每一步中算法都会选择 `distTo[]` 最小的顶点，之后的放松操作不可能使任何 `distTo[]` 的值小于 `distTo[v]`）。因此，在所有从 `s` 可达的顶点均被添加到树中之后，最短路径的最优性条件成立，即命题 P 成立。

####4.4.4.1　数据结构

要实现 Dijkstra 算法，除了 `distTo[]` 和 `edgeTo[]` 数组之外还需要一条索引优先队列 `pq`，以保存需要被放松的顶点并确认下一个被放松的顶点。我们知道 `IndexMinPQ` 可以将索引和键（优先级）关联起来并且可以删除并返回优先级最低的索引。在这里，只要将顶点 `v` 和 `distTo[v]` 关联起来就立即可以得到 Dijkstra 算法的实现。另外，稍加推导也可以知道，`edgeTo[]` 中的元素所对应的可达顶点构成了一棵最短路径树。

####4.4.4.2　换一个角度看问题

根据算法的证明，我们可以从另一个角度来理解它，如图 4.4.9 所示，已知树结点所对应的 `distTo[]` 值均为最短路径的长度。对于优先队列中的任意顶点 `w`，`distTo[w]` 是从 `s` 到 `w` 的最短路径的长度，该路径上的中间顶点在树中且路径结束于横切边 `edgeTo[w]`。优先级**最小**的顶点的 `distTo[]` 值就是最短路径的权重，它不会小于已经被放松过的任意顶点的最短路径的权重，也不会大于还未被放松过的任意顶点的最短路径的权重。这个顶点就是下一个要被放松的顶点。所有从 `s` 可达的顶点都会按照最短路径的权重顺序被放松。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.089.png)

**图 4.4.9　Dijkstra 的最短路径算法**

图 4.4.10 是算法处理样图 tinyEWD.txt 时的轨迹。在这个例子中，算法构造最短路径树的过程如下所述。

* 将顶点 `0` 添加到树中，将顶点 `2` 和 `4` 加入优先队列。
* 从优先队列中删除顶点 `2`，将 `0` → `2` 添加到树中，将顶点 `7` 加入优先队列。
* 从优先队列中删除顶点 `4`，将 `0` → `4` 添加到树中，将顶点 `5` 加入优先队列，边 `4` → `7` 失效。
* 从优先队列中删除顶点 `7`，将 `2` → `7` 添加到树中，将顶点 `3` 加入优先队列，边 `7` → `5` 失效。
* 从优先队列中删除顶点 `5`，将 `4` → `5` 添加到树中，将顶点 `1` 加入优先队列，边 `5` → `7` 失效。
* 从优先队列中删除顶点 `3`，将 `7` → `3` 添加到树中，将顶点 `6` 加入优先队列。
* 从优先队列中删除顶点 `1`，将 `5` → `1` 添加到树中，边 `1` → `3` 失效。
* 从优先队列中删除顶点 `6`，将 `3` → `6` 添加到树中。

算法按照顶点到起点的最短路径的长度的增序将它们添加到最短路径树中，如图 4.4.10 右侧的红色箭头所示。

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.090.png)

**图 4.4.10　Dijkstra 算法的轨迹**

Dijkstra 算法的实现 `DijkstraSP`（算法 4.9）只是用代码复述了算法的描述，还在 `relax()` 方法中添加了一行语句来处理以下两种情况：要么边的 `to()` 得到的顶点还不在优先队列中，此时需要使用 `insert()` 方法将它加入到优先队列中；要么它已经在优先队列中且优先级需要被降低，此时可以用 `change()` 方法实现。

>**命题 R（续）**。在一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的加权有向图中，使用 Dijkstra 算法计算根结点为给定起点的最短路径树所需的空间与 ![V](https://private.codecogs.com/gif.latex?V) 成正比，时间与 ![V \log V](https://private.codecogs.com/gif.latex?V%20\log%20V) 成正比（最坏情况下）。

>**证明**。同 Prim 算法的证明（请见命题 N）

如前所述，思考 Dijkstra 算法的另一种方式就是将它和 4.3 节的 Prim 算法（算法 4.7）相比较。两种算法都会用添加边的方式构造一棵树：Prim 算法每次添加的都是离**树**最近的非树顶点，Dijkstra 算法每次添加的都是离**起点**最近的非树顶点。它们都不需要 `marked[]` 数组，因为条件 `!marked[w]` 等价于条件 `distTo[w]` 为无穷大。换句话说，将算法 4.9 中的有向图换成无向图并忽略 `relax()` 方法中 `distTo[v]` 部分的代码，就会得到算法 4.7，也就是 Prim 算法的即时版本（！）。同样，根据 LazyPrimMST（4.3.4 节框注“最小生成树的 Prim 算法的延时实现”）实现 Dijkstra 算法的延时版本也并不困难。

####4.4.4.3　变种

我们只需对 Dijkstra 算法的实现稍作适当的修改就能够解决这个问题的其他版本，例如，加权无向图中的单点最短路径。给定一幅加权**无向图**和一个起点 `s`，回答“**是否存在一条从 `s` 到给定的顶点 `v` 的路径？**如果有，**找出最短（总权重最小）的那条路径。**”等类似问题。

如果将无向图看作有向图，这个问题的答案就很简单了。也就是说，对于给定的加权无向图，创建一幅由相同顶点构成的加权有向图，且对于无向图中的每条边，相应地创建两条（方向不同）有向边。有向图中的路径和无向图中的路径存在着一一对应的关系，路径的权重也是相同的——最短路径的问题是等价的。

>**算法 4.9　最短路径的 Dijkstra 算法**

>![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.091.png)

>Dijkstra 算法的实现每次都会为最短路径树添加一条边，该边由一个树中的顶点指向一个非树顶点 `w` 且它是到 `s` 最近的顶点。

**给定两点的最短路径**。给定一幅加权有向图以及一个起点 `s` 和一个终点 `t`，找到从 `s` 到 `t` 的最短路径。

要解决这个问题，你可以使用 Dijkstra 算法并在从优先队列中取到 `t` 之后终止搜索。

**任意顶点对之间的最短路径**。给定一幅加权有向图，回答“**给定一个起点 `s` 和一个终点 `t`，是否存在一条从 `s` 到 `t` 的路径**？如果有，找出**最短**（总权重最小）的那条路径。”等类似问题。

右边框注中短小精悍的代码解决了任意顶点对之间的最短路径问题，所需的时间与 ![EV\log V](https://private.codecogs.com/gif.latex?EV\log%20V) 成正比，空间与![V^2](https://private.codecogs.com/gif.latex?V^2)成正比。它构造了 `DijkstraSP` 对象的数组，每个元素都将相应的顶点作为起点。在用例进行查询时，代码会访问起点所对应的单点最短路径对象并将目的顶点作为参数进行查询。

```
public class DijkstraAllPairsSP
{
   private DijkstraSP[] all;

   DijkstraAllPairsSP(EdgeWeightedDigraph G)
   {
      all = new DijkstraSP[G.V()]
      for (int v = 0; v < G.V(); v++)
         all[v] = new DijkstraSP(G, v);
   }

   Iterable<DirectedEdge> path(int s, int t)
   {  return all[s].pathTo(t);  }

   double dist(int s, int t)
   {  return all[s].distTo(t);  }

}
```

{-:-}任意顶点对之间的最短路径

**欧几里得图中的最短路径**。在顶点为平面上的点且边的权重与顶点欧几里得间距成正比的图中，解决单点、给定两点和任意顶点对之间的最短路径问题。

在这种情况下，有一个小小的改动可以大幅提高 Dijkstra 算法的运行速度（请见练习 4.4.27）。

图 4.4.11 显示的是 Dijkstra 算法在处理测试文件 mediumEWD.txt（请见 4.4.2.2 节）所定义的欧几里得图时用若干不同的起点产生最短路径树的过程。和之前一样，这幅图中的线段都表示双向的有向边。这些图片展示了一段引人入胜的动态过程。

![{75%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.092.png)

**图 4.4.11　Dijkstra 算法（250 个顶点，不同的起点）**

下面，我们将会考虑加权无环图中的最短路径算法并且将在线性时间内解决该问题（比 Dijkstra 算法要快）。然后是负权重的加权有向图中的最短路径问题，Dijkstra 算法不适用于这种情况。

###4.4.5　无环加权有向图中的最短路径算法

许多应用中的加权有向图都是不含有有向环的。我们现在来学习一种比 Dijkstra 算法更快、更简单的在无环加权有向图中找出最短路径的算法，如图 4.4.12 所示。它的特点是：

* 能够在线性时间内解决单点最短路径问题；
* 能够处理负权重的边；
* 能够解决相关的问题，例如找出**最长**的路径。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.093.png)

**图 4.4.12　一幅无环加权有向图和它的一棵最短路径树**

这些算法都是在 4.2 节中学过的无环有向图的拓扑排序算法的简单扩展。

特别的是，只要将顶点的放松和拓扑排序结合起来，马上就能够得到一种解决无环加权有向图中的最短路径问题的算法。首先，将 `distTo[s]` 初始化为 0，其他 `distTo[]` 元素初始化为无穷大，然后一个一个地按照**拓扑顺序**放松所有顶点。我们可以用与 Dijkstra 算法的证明（命题 R）类似的方法证明这个方法的正确性。

>**命题 S**。按照拓扑顺序放松顶点，就能在和 ![E+V](https://private.codecogs.com/gif.latex?E+V) 成正比的时间内解决无环加权有向图的单点最短路径问题。

>**证明**。每条边 `v` → `w` 都只会被放松一次。当 `v` 被放松时，得到：`distTo[w]<= distTo[v]+e.weight()`。在算法结束前该不等式都成立，因为 `distTo[v]` 是不会变化的（因为是按照拓扑顺序放松顶点，在 `v` 被放松之后算法不会再处理任何指向 `v` 的边）而 `distTo[w]` 只会变小（任何放松操作都只会减小 `distTo[]` 中的元素的值）。因此，在所有从 `s` 可达的顶点都被加入到树中后，最短路径的最优性条件成立，命题 Q 也就成立了。时间上限很容易得到：命题 G 告诉我们拓扑排序所需的时间与 ![E+V](https://private.codecogs.com/gif.latex?E+V) 成正比，而在第二次遍历中每条边都只会被放松一次，因此算法总耗时与 ![E+V](https://private.codecogs.com/gif.latex?E+V) 成正比。

图 4.4.13 是算法处理无环加权有向样图 tinyEWDAG.txt 的轨迹。在这个例子中，算法由顶点 `5` 开始按照以下步骤构建了一棵最短路径树：

* 用深度优先搜索得到图的顶点的拓扑排序 `5 1 3 6 4 7 0 2`；
* 将顶点 `5` 和从它指出的所有边添加到树中；
* 将顶点 `1` 和边 `1` → `3` 添加到树中；
* 将顶点 `3` 和边 `3` → `6` 添加到树中，边 `3` → `7` 已经失效；
* 将顶点 `6` 和边 `6` → `2`、`6` → `0` 添加到树中，边 `6` → `4` 已经失效；
* 将顶点 `4` 和边 `4` → `0` 添加到树中，边 `4` → `7` 和 `6` → `0` 已经失效；
* 将顶点 `7` 和边 `7` → `2` 添加到树中，边 `6` → `2` 已经失效；
* 将顶点 `0` 添加到树中，边 `0` → `2` 已经失效；
* 将顶点 `2` 添加到树中。

图中没有画出将 `2` 添加到树中的一步，拓扑序列中的最后一个顶点没有指出的边。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.094.png)

**图 4.4.13　寻找无环加权有向图中的最短路径的算法轨迹**

算法 4.10 在实现中直接使用了已学习过的许多代码。它假设 `Topological` 类使用本节中介绍的 `EdgeWeightedDigraph` 类和 `DirectedEdge` 类的 API（请见练习 4.4.12）重载了拓扑排序的方法。注意，该实现中不需要布尔数组 `marked[]`：因为是按照拓扑顺序处理无环有向图中的顶点，所以不可能再次遇到已经被放松过的顶点。算法 4.10 的效率几乎已经没有提高的空间了：在拓扑排序后，构造函数会扫描整幅图并将每条边放松一次。在已知加权图是无环的情况下，它是找出最短路径的最好方法。

>**算法 4.10　无环加权有向图的最短路径算法**

>![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.095.png)

>无环加权有向图的最短路径算法使用了拓扑排序（算法 4.5，重载了 `EdgeWeightedDigraph` 类和 `DirectedEdge` 类）来按照拓扑顺序放松所有顶点，这对于计算出图中的最短路径已经足够了。

>```
>% java AcyclicSP tinyEWDAG.txt 5
>5 to 0 (0.73): 5->4 0.35  4->0 0.38
>5 to 1 (0.32): 5->1 0.32
>5 to 2 (0.62): 5->7 0.28  7->2 0.34
>5 to 3 (0.61): 5->1 0.32  1->3 0.29
>5 to 4 (0.35): 5->4 0.35
>5 to 5 (0.00):
>5 to 6 (1.13): 5->1 0.32  1->3 0.29  3->6 0.52
>5 to 7 (0.28): 5->7 0.28
>```

命题 S 很重要，因为它的“无环”能够极大地简化问题的论断。对于最短路径问题，基于拓扑排序的方法比 Dijkstra 算法快的倍数与 Dijkstra 算法中所有优先队列操作的总成本成正比。另外，命题 S 的证明和边的权重是否非负无关，因此无环加权有向图不会受到任何限制。下面用这个特点解决边的负权重问题。我们会考虑使用这个最短路径模型来解决另外两个问题，其中之一乍一看甚至和图的处理似乎没有任何关系。

####4.4.5.1　最长路径

考虑在无环加权有向图中寻找最长路径的问题，边的权重可正可负。

**无环加权有向图中的单点最长路径**。给定一幅无环加权有向图（边的权重可能为负）和一个起点 `s`，回答“**是否存在一条从 `s` 到给定的顶点 `v` 的路径**？如果有，找出**最长**（总权重最大）的那条路径。”等类似问题。

我们刚刚学习过的算法能够快速地解决这个问题。

>**命题 T**。解决无环加权有向图中的最长路径问题所需的时间与 ![E+V](https://private.codecogs.com/gif.latex?E+V) 成正比。

>**证明**。给定一个最长路径问题，复制原始无环加权有向图得到一个副本并将副本中的所有边的权重取相反数。这样，副本中的**最短**路径即为原图中的**最长**路径。要将最短路径问题的答案转换为最长路径问题的答案，只需将方案中的权重变为正值即可。根据命题 S 立即可以得到算法所需的时间。

根据这种转换实现 `AcyclicLP` 类来寻找一幅无环加权有向图中的最长路径就十分简单了。实现该类的一个更简单的方法是修改 `AcyclicSP`，将 `distTo[]` 的初始值变为 `Double.NEGATIVE_INFINITY` 并改变 `relax()` 方法中的不等式的方向。无论使用哪种方法，都能得到无环加权有向图中的最长路径问题的一种高效的解决方案。和它形成鲜明对比的是，在一般的加权有向图（边的权重可能为负）中寻找最长简单路径的已知最好算法在最坏情况下所需的时间是**指数级别**的（请见第 6 章）！出现环的可能性似乎使这个问题的难度以指数级别增长。

图 4.4.14 是算法在无环加权有向样图 tinyEWDAG.txt 中寻找最长路径的轨迹，你可以将它与图 4.4.13 相比较。在这个例子中，算法由顶点 `5` 按照以下步骤构建了一棵最长路径树：

* 用深度优先搜索得到图的顶点的拓扑排序 `5 1 3 6 4 7 0 2`；
* 将顶点 `5` 和从它指出的所有边添加到树中；
* 将顶点 `1` 和边 `1` → `3` 添加到树中 `;`
* 将顶点 `3` 和边 `3` → `6`、`3` → `7` 添加到树中，边 `5` → `7` 已经失效；
* 将顶点 `6` 和边 `6` → `2`、`6` → `4` 和 `6` → `0` 添加到树中，边 `5` → `4` 已经失效；
* 将顶点 `4` 和边 `4` → `0`、`4` → `7` 添加到树中，边 `6` → `0` 和 `3` → `7` 已经失效；
* 将顶点 `7` 和边 `7` → `2` 添加到树中，边 `6` → `2` 已经失效；
* 将顶点 `0` 添加到树中，边 `0` → `2` 已经失效；
* 将顶点 `2` 添加到树中（未画出）。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.096.png)

**图 4.4.14　无环图中的最长路径算法**

最长路径算法处理顶点的顺序和最短路径算法一样，但产生的结果却完全不同。

####4.4.5.2　并行任务调度

作为算法应用的示例，我们再次考虑在 4.2 节中出现过的任务调度类的问题。这次需要解决以下调度问题（楷体部分为与 4.2.4.1 节的问题描述的不同之处）。

**优先级限制下的并行任务调度**。给定一组需要完成的任务和每个任务**所需的时间**，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何在**若干相同的处理器上（数量不限）**安排任务并在**最短的时间内**完成所有任务？

4.2 节的模型默认只有单个处理器：将任务按照拓扑顺序排序，完成任务的总耗时就是所有任务所需要的总时间。现在假设有足够多的处理器并能够同时处理任意多的任务，受到的只有优先级的限制。和以前一样，需要处理的任务可能上百万甚至上亿，因此需要一个高效的算法。令人兴奋的是，正好存在一种线性时间的算法——一种叫做“关键路径“的方法能够证明这个问题与无环加权有向图中的最长路径问题是等价的。这个方法已成功应用于无数的工业软件之中。

假设任意可用的处理器都能在任务所需的时间内完成它，那么我们的重点就是尽早安排每一个任务。例如，表 4.4.5 给出了一个任务调度问题，图 4.4.15 给出的解决方案显示了这个问题所需的最短时间为 173.0。这份调度方案满足了所有限制条件，没有其他调度方案能比它耗时更少，因为任务必须按照 `0` → `9` → `6` → `8` → `2` 的顺序完成。这个顺序就是这个问题的**关键路径**。由优先级限制指定的每一列任务都代表了调度方案的一种可能的时间下限。如果将一系列任务的长度定义为完成所有任务的最早可能时间，那么最长的任务序列就是问题的关键路径，因为在这份任务序列中任何任务的启动延迟都会影响到整个项目的完成时间。

**表 4.4.5　一个任务调度问题**

|任务|时耗|必须在以下任务之前完成|
|-|-|-|
|`0`|`41.0`|`1`　`7`　`9`|
|`1`|`51.0`|`2`|
|`2`|`50.0`||
|`3`|`36.0`||
|`4`|`38.0`||
|`5`|`45.0`||
|`6`|`21.0`|`3`　`8`|
|`7`|`32.0`|`3`　`8`|
|`8`|`32.0`|`2`|
|`9`|`29.0`|`4`　`6`|

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.097.png)

**图 4.4.15　并行任务调度问题的解决方案**

>**定义**。解决并行任务调度问题的关键路径方法的步骤如下：创建一幅无环加权有向图，其中包含一个起点 `s` 和一个终点 `t` 且每个任务都对应着两个顶点（一个**起始**顶点和一个**结束**顶点）。对于每个任务都有一条从它的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每条优先级限制 `v` → `w`，添加一条从 `v` 的结束顶点指向 `w` 的起始顶点的权重为零的边。我们还需要为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。

图 4.4.16 显示的是示例任务所对应的图，图 4.4.17 则显示的是最长路径的答案。如定义所述，在图中每个任务都对应着三条边（从起点到起始顶点、从结束顶点到终点的权重为零的边，以及一条从起始顶点到结束顶点的边），每个优先级限制条件都对应着一条边。后面框注“优先级限制下的并行任务调度问题的关键路径方法”中的 `CPM` 类简洁明了地实现了关键路径方法。它能够将任意任务调度问题转化为无环加权有向图中的一个最长路径问题，用 `AcyclicLP` 解决它并打印出每个任务的开始时间以及调度方案的结束时间。

![{95%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.098.png)

**图 4.4.16　任务调度问题的无环加权有向图表示**

![{95%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.099.png)

**图 4.4.17　任务调度示例问题的最长路径解决方案**

>**优先级限制下的并行任务调度问题的关键路径方法**

>```
>public class CPM
>{
>    public static void main(String[] args)
>    {
>       int N = StdIn.readInt(); StdIn.readLine();
>       EdgeWeightedDigraph G;
>       G = new EdgeWeightedDigraph(2*N+2);
>       int s = 2*N, t = 2*N+1;
>       for (int i = 0; i < N; i++)
>       {
>          String[] a = StdIn.readLine().split("\\s+");
>          double duration = Double.parseDouble(a[0]);
>          G.addEdge(new DirectedEdge(i, i+N, duration));
>          G.addEdge(new DirectedEdge(s, i, 0.0));
>          G.addEdge(new DirectedEdge(i+N, t, 0.0));
>          for (int j = 1; j < a.length; j++)
>          {
>             int successor = Integer.parseInt(a[j]);
>             G.addEdge(new DirectedEdge(i+N, successor, 0.0));
>          }
>       }
>       AcyclicLP lp = new AcyclicLP(G, s);
>
>       StdOut.println("Start times:");
>       for (int i = 0; i < N; i++)
>          StdOut.printf("%4d: %5.1f\n", i, lp.distTo(i));
>       StdOut.printf("Finish time: %5.1f\n", lp.distTo(t));
>   }
>
>}
>```

>　

>```
>% more jobsPC.txt
>10
>41.0  1 7 9
>51.0  2
>50.0
>36.0
>38.0
>45.0
>21.0  3 8
>32.0  3 8
>32.0  2
>29.0  4 6
>```

>　

>```
>% java CPM < jobsPC.txt
>Start times:
>    0:   0.0
>    1:  41.0
>    2: 123.0
>    3:  91.0
>    4:  70.0
>    5:   0.0
>    6:  70.0
>    7:  41.0
>    8:  91.0
>    9:  41.0
>Finish time: 173.0
>```

>这里实现的任务调度问题的关键路径方法将问题归约为寻找无环加权有向图的最长路径问题。它会根据任务调度问题的描述用关键路径的方法构造一幅加权有向图（且必然是无环的），然后使用 `AcyclicLP`（请见命题 T）找到图中的最长路径树，最后打印出各条最长路径的长度，也就正好是每个任务的开始时间。

　

>**命题 U**。解决优先级限制下的并行任务调度问题的关键路径法所需的时间为线性级别。

>**证明**。为什么 `CPM` 类能够解决问题？算法的正确性依赖于两个因素。首先，在相应的有向无环图中，每条路径都是由任务的起始顶点和结束顶点组成的并由权重为零的优先级限制条件的边分隔——从起点 `s` 到任意顶点 `v` 的任意路径的长度都是任务 `v` 的开始/结束时间的下限，因为这已经是在同一台处理器上顺序完成这些任务的最优的排列顺序了。因此，从起点 `s` 到终点 `t` 的最长路径就是所有任务的完成时间的**下限**。第二，由最长路径得到的所有开始和结束时间都是**可行的**——每个任务都只能在优先级限制指定的先导任务完成之后开始，因为它的开始时间就是顶点到它的起始顶点的最长路径的长度。因此，从起点 `s` 到终点 `t` 的**最长**路径长度就是所有任务完成时间的**上限**。由命题T很容易得到算法所需的时间是线性的。

####4.4.5.3　相对最后期限限制下的并行任务调度

一般的最后期限（deadline）都是相对于第一个任务的开始时间而言的。假设在任务调度问题中加入一种新类型的限制，需要某个任务必须在指定的时间点之前开始，即指定和另一个任务的开始时间的相对时间。这种类型的限制条件在争分夺秒的生产线上以及许多其他应用中都很常见，但它也会使得任务调度问题更难解决。例如，如表 4.4.6 所示，假设要在前面的示例中加入一个限制条件，使 2 号任务必须在 4 号任务启动后的 12 个时间单位之内开始。实际上，在这里最后期限限制的是 4 号任务的开始时间：它的开始时间不能早于 2 号任务开始 12 个时间单位。在示例中，调度表中有足够的空档来满足这个最后期限限制：我们可以令 4 号任务开始于 111 时间，即 2 号任务计划开始时间前的 12 个时间单位处。需要注意的是，如果 4 号任务耗时很长，这个修改可能会延长整个调度计划的完成时间。同理，如果再添加一个最后期限的限制条件，令 2 号任务必须在 7 号任务启动后的 70 个时间单位内开始，还可以将 7 号任务的开始时间调整到 53，这样就不用修改 3 号任务和 8 号任务的计划开始时间。但是如果继续限制 4 号任务必须在零号任务启动后的 80 个时间单位内开始，那么就**不存在可行**的调度计划了：限制条件 4 号任务必须在 0 号任务启动后的 80 个时间单位内开始以及 2 号任务必须在 4 号任务启动后的 12 个时间单位之内开始，意味着 2 号任务必须在 0 号任务启动后的 93 个时间单位之内开始，但因为存在任务链 0（41 个时间单位）→ 9（29 个时间单位）→ 6（21 个时间单位）→ 8（32 个时间单位）→ 2，2 号任务最早也只能在 0 号任务启动后的 123 个时间单位之内开始。前面添加的限制如表 4.4.7 所示。最后期限的限制越多，调度的可能性也就越多，简单的问题也会变得越困难。

**表 4.4.6　相对最后期限限制下的任务调度**

![{48%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.100.png)

**表 4.4.7　向任务调度问题中添加的最后期限限制**

|任务|相对最后期限|相对于任务|
|-|-|-|
|`2`|`12.0`|`4`|
|`2`|`70.0`|`7`|
|`4`|`80.0`|`0`|

>**命题 V**。相对最后期限限制下的并行任务调度问题是一个加权有向图中的最短路径问题（可能存在环和负权重边）。

>**证明**。与命题 U 一样根据任务调度的描述构造相同的加权有向图，为每条最后期限限制添加一条边：如果任务 `v` 必须在任务 `w` 启动后的 `d` 个时间单位内开始，则添加一条从 `v` 指向 `w` 的**负**权重为 `d` 的边。将所有边的权重取反即可将该问题转化为一个最短路径问题。如果**存在可行的调度方案**，证明也就完成了。你将会看到，判断一个调度方案是否可行也是计算的一部分。

这个示例说明了负权重的边在实际应用的模型中也能起到重要的作用。它说明，如果能够有效解决负权重边的最短路径问题，那就能够找到相对最后期限限制下的并行任务调度问题的解决方案。我们已经学习过的算法都无法完成这个任务： Dijkstra 算法只适用于正（或零）权重的边，算法 4.10 要求有向图是无环的。下面我们来看看如何解决含有负权重且不一定是无环的有向图中的最短路径问题（请见图 4.4.18）。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.101.png)

**图 4.4.18　相对最后期限限制和优先级限制下的并行任务调度问题的加权有向图表示**

###4.4.6　一般加权有向图中的最短路径问题

刚才讨论过的最后期限限制下的任务调度问题告诉我们负权重的边并不仅仅是一个数学问题。相反，它能够极大地扩展解决最短路径问题的模型的应用范围。接下来，考虑既可能含有环也可能含有负权重的边的加权有向图中的最短路径算法。在开始之前，先来学习一下这种有向图的基本性质以更新我们对最短路径的认识。图 4.4.19 是一个小小的示例，展示的是负权重的边对有向图中的最短路径的影响。也许最明显的改变就是当存在负权重的边时，权重较小的路径含有的边可能会比权重较大的路径更多。在只存在正权重的边时，我们的重点在于寻找近路；但当存在负权重的边时，我们可能会为了经过负权重的边而**绕弯**。这种效应使得我们要将查找“最短”路径的感觉转变为对算法本质的理解。因此需要抛弃直觉并在一个简单、抽象的层面上考虑这个问题。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.102.png)

**图 4.4.19　含有负权重的边的加权有向图**

####4.4.6.1　尝试Ⅰ

第一个想法是先找到权重最小（最小的负值）的边，然后将所有边的权重加上这个负值的绝对值，这样原有向图就转变称为了一幅不含有负权重边的有向图。这种天真的做法不会解决任何问题，因为新图中的最短路径和原图中的最短路径毫无关系。路径中的边越多，这种变换产生的危害越大（请见练习 4.4.14）。

####4.4.6.2　尝试Ⅱ

第二个想法是尝试改造 Dijkstra 算法。这种方法最根本的缺陷在于原算法的基础在于根据距离起点的远近依次检查路径。命题 R 对算法正确性的证明是基于添加一条边会使的路径变得更长的假设。但添加任意负权重的边只会使得路径更短，因此这个假设是不成立的（请见练习 4.4.14）。

####4.4.6.3　负权重的环

当我们在研究含有负权重边的有向图时，如果该图中含有一个权重为负的环，那么最短路径的概念就失去意义了。例如图 4.4.20，除了边 `5` → `4` 的权重为 -0.66 外，它和第一个示例完全相同。这里，环 `4` → `7` → `5` → `4` 的权重为：

{-:-}`0.37+0.28-0.66=-0.01`

我们只要围着这个环兜圈子就能得到权重任意短的路径！注意，有向环的所有边的权重并不一定都必须是负的，只要权重之和是负的即可。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.103.png)

**图 4.4.20　含有负权重环的加权有向图**

>**定义**。加权有向图中的**负权重环**是一个总权重（环上的所有边的权重之和）为负的有向环。

现在，假设从 `s` 到可达的某个顶点 `v` 的路径上的某个顶点在一个负权重环上。在这种情况下，从 `s` 到 `v` 的最短路径是不可能存在的，因为可以用这个负权重环构造权重任意小的路径。换句话说，在负权重环存在的情况下，最短路径问题是没有意义的，如图 4.4.21 所示。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.104.png)

**图 4.4.21　最短路径问题的各种可能性**

>**命题 W**。当且仅当加权有向图中至少存在一条从 `s` 到 `v` 的有向路径**且**所有从 `s` 到 `v` 的有向路径上的任意顶点都不存在于任何负权重环中时，`s` 到 `v` 的最短路径才是存在的。

>**证明**。请见以上讨论以及练习 4.4.29。

注意，要求最短路径上的任意顶点都不存在于负权重环中意味着最短路径是简单的，而且与正权重边的图一样都能够得到此类顶点的最短路径树。

####4.4.6.4　尝试Ⅲ

无论是否存在负权重环，从 `s` 到可达的其他顶点的一条最短的**简单**路径都是存在的。为什么不定义最短路径以方便寻找呢？不幸的是，已知解决这个问题的最好算法在最坏情况下所需的时间是指数级别的（请见第 6 章）。一般来说，我们认为这种问题“太难了”，只会研究它的简单版本。

因此，一个定义明确且可以解决加权有向图最短路径问题的算法要能够：

* 对于从起点不可达的顶点，最短路径为正无穷（+∞）；
* 对于从起点可达但路径上的某个顶点属于一个负权重环的顶点，最短路径为负无穷（-∞）；
* 对于其他所有顶点，计算最短路径的权重（以及最短路径树）。

从本节的开始到现在，我们为最短路径问题加上各种限制，使得我们能够找到解决相应问题的办法。首先，我们不允许负权重边的存在；其次不接受有向环。现在我们放宽所有这些条件并重点解决一般有向图中的以下问题。

**负权重环的检测**。给定的加权有向图中含有负权重环吗？如果有，找到它。

**负权重环不可达时的单点最短路径**。给定一幅加权有向图和一个起点 `s` 且从 `s` 无法到达任何负权重环，回答“**是否存在一条从 `s` 到给定的顶点 `v` 的有向路径**？如果有，找出**最短**（总权重最小）的那条路径。”等类似问题。

**总结**。尽管在含有环的有向图中最短路径是一个没有意义的问题，而且也**无法**有效解决在这种有向图中高效找出最短简单路径的问题，在实际应用中仍然需要**能够**识别其中的负权重环。例如，在最后期限限制下的任务调度问题中，负权重环的出现可能相对较少：限制条件和最后期限都是从现实世界中的实际限制得来的，因此负权重环大多可能来自于问题陈述中的错误。找出负权重环，改正相应的错误，找到没有负权重环问题的调度方案才是解决问题的正确方式。在其他情况下，找到负权重环就是计算的目标。下面这个由 R.Bellman 和 L.Ford 在 20 世纪 50 年代末期发明的算法能够简明、有效地解决这些问题并且同样适用于正权重边的有向图。

>**命题 X（Bellman-Ford 算法）**。在任意含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点的加权有向图中给定起点 `s`，从 `s` 无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：将 `distTo[s]` 初始化为 0，其他 `distTo[]` 元素初始化为无穷大。以任意顺序放松有向图的所有边，重复 ![V](https://private.codecogs.com/gif.latex?V) 轮。

>**证明**。对于从 `s` 可达的任意顶点 `t`，考虑从 `s` 到 `t` 的一条最短路径：<code>v<sub>0</sub></code> → <code>v<sub>1</sub></code>→ ... → <code>v<sub><i>k</i></sub></code>，其中 <code>v<sub>0</sub></code> 等于 `s`，<code>v<sub><i>k</i></sub></code> 等于 `t`。因为负权重环是不可达的，这样的路径是存在的且 <code>v<i>k</i></code> 不会大于 ![V-1](https://private.codecogs.com/gif.latex?V-1)。我们会通过归纳法证明算法在第 <code><i>i</i></code> 轮之后能够得到 `s` 到 <code>v<sub><i>i</i></sub></code> 的最短路径。最简单的情况（<code><i>i</i>=0</code>）很容易。假设对于 <code><i>i</i></code> 命题成立，那么 `s` 到 <code>v<sub><i>i</i></sub></code> 的最短路径即为 <code>v<sub>0</sub></code> → <code>v<sub>1</sub></code>→ ... → <code>v<sub><i>i</i></sub></code>，<code>distTo[v<sub><i>i</i></sub>]</code> 就是这条路径的长度。现在，我们在第 <code><i>i</i></code> 轮中放松所有的顶点，包括 <code>v<sub><i>i</i></sub></code>，因此 <code>distTo[v<sub><i>i</i>+1</sub>]</code> 不会大于 <code>distTo[v<sub><i>i</i></sub>]</code> 与边 <code>v<sub><i>i</i></sub></code> → <code>v<sub><i>i</i>+1</sub></code> 的权重之和。在第 <code><i>i</i></code> 轮放松之后，<code>distTo[v<sub><i>i</i>+1</sub>]</code> 必然等于 <code>distTo[v<sub><i>i</i></sub>]</code> 与边 <code>v<sub><i>i</i></sub></code> → <code>v<sub><i>i</i>+1</sub></code> 的权重之和。它不可能更大，因为在第 <code><i>i</i></code> 轮中放松了所有顶点，包括 <code>v<sub><i>i</i></sub></code>；它也不可能更小，因为它就是路径 <code>v<sub>0</sub></code> → <code>v<sub>1</sub></code>→ ... → <code>v<sub><i>i</i>+1</sub></code> 的长度，也就是最短路径了。因此，在 <code><i>i</i>+1</code> 轮之后算法能够得到从 `s` 到 <code>v<sub><i>i</i>+1</sub></code> 的最短路径。

　

>**命题 W（续）**。Bellman-Ford算法所需的时间和 ![E{V}](https://private.codecogs.com/gif.latex?E{V}) 成正比，空间和 ![V](https://private.codecogs.com/gif.latex?V) 成正比。

>**证明**。在每一轮中算法都会放松 ![E](https://private.codecogs.com/gif.latex?E) 条边，共重复 ![V](https://private.codecogs.com/gif.latex?V) 轮。

这个方法非常通用，因为它没有指定边的放松顺序。下面将注意力集中在一个通用性稍逊的方法上，其中只放松从任意顶点指出的所有边（顺序任意），以下代码说明了这种方法的简洁性：

```
for (int pass = 0; pass < G.V(); pass++)
   for (v = 0; v < G.V(); v++)
      for (DirectedEdge e : G.adj(v))
         relax(e);
```

我们不会仔细研究这个版本，因为它**总是**会放松 ![VE](https://private.codecogs.com/gif.latex?VE) 条边且只需稍作修改即可使算法在一般的应用场景中更加高效。

####4.4.6.5　基于队列的 Bellman-Ford 算法

其实，根据经验我们很容易知道在任意一轮中许多边的放松都不会成功：只有上一轮中的 `distTo[]` 值发生变化的顶点指出的边才能够改变其他 `distTo[]` 元素的值。为了记录这样的顶点，我们使用了一条 FIFO 队列。算法在处理正权重标准样图中进行的操作如图 4.4.22 所示。在示意图 4.4.22 左侧是每一轮中队列中的有效顶点（红色），紧接着是下一轮中的有效顶点（黑色）。首先将起点加入队列，然后按照以下步骤计算最短路径树。

* 放松边 `1` → `3` 并将顶点 `3` 加入队列。
* 放松边 `3` → `6` 并将顶点 `6` 加入队列。
* 放松边 `6` → `4`、`6` → `0` 和 `6` → `2` 并将顶点 `4`、`0` 和 `2` 加入队列。
* 放松边 `4` → `7`、`4` → `5` 并将顶点 `7` 和 `5` 加入队列。放松已经失效的边 `0` → `4` 和 `0` → `2`。然后再放松边 `2` → `7`（并重新为 `4` → `7` 着色）。
* 放松边 `7` → `5`（并重新为 `4` → `5` 着色）但不将顶点 `5` 加入队列（它已经在队列之中了）。放松已经失效的边 `7` → `3`。然后放松已经失效的边 `5` → `1`、`5` → `4` 和 `5` → `7`。此时队列为空。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.105.png)

**图 4.4.22　Bellman-Ford 算法的轨迹**

####4.4.6.6　实现

根据这些描述实现 Bellman-Ford 算法所需的代码非常少，如算法 4.11 所示。它基于以下两种其他的数据结构：

* 一条用来保存即将被放松的顶点的队列 `queue`；
* 一个由顶点索引的 `boolean` 数组 `onQ[]`，用来指示顶点是否已经存在于队列中，以防止将顶点重复插入队列。

首先，将起点 `s` 加入队列中，然后进入一个循环，其中每次都从队列中取出一个顶点并将其放松。要将一个顶点插入队列，需要修改 4.4.2.5 节框注“边的松驰”中 `relax()` 方法的实现，以便将被成功放松的边所指向的顶点加入队列中，如右边框注“Bellman-Ford 算法中的放松操作”所示。这些数据结构能够保证：

* 队列中不出现重复的顶点；
* 在某一轮中，改变了 `edgeTo[]` 和 `distTo[]` 的值的所有顶点都会在下一轮中处理。

![{72%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.106.png)

{-:-}Bellman-Ford 算法中的放松操作

要完整地实现该算法，我们就需要保证在 ![V](https://private.codecogs.com/gif.latex?V) 轮后算法能够终止。实现它的一种方法是显式记录放松的轮数。我们的实现 `BellmanFordSP`（算法 4.11）使用了另一种方法，将会在 4.4.6.8 节详述：它会在有向图的 `edgeTo[]` 中检测是否存在负权重环，如果找到则结束运行。

>**命题 Y**。对于任意含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点的加权有向图和给定的起点 `s`，在最坏情况下基于队列的 Bellman-Ford 算法解决最短路径问题（或者找到从 `s` 可达的负权重环）所需的时间与 ![E{V}](https://private.codecogs.com/gif.latex?E{V}) 成正比，空间和 ![V](https://private.codecogs.com/gif.latex?V) 成正比。

>**证明**。如果不存在从 `s` 可达的负权重环，算法会根据命题 X 在进行 ![V-1](https://private.codecogs.com/gif.latex?V-1) 轮放松操作后结束（因为所有最短路径含有的边数都不大于 ![V-1](https://private.codecogs.com/gif.latex?V-1)）。如果的确存在一个从 `s` 可达的负权重环，那么队列永远不可能为空。根据命题 X，在第 ![V](https://private.codecogs.com/gif.latex?V) 轮放松之后，`edgeTo[]` 数组必然会包含一条含有一个环的路径（从某个顶点 `w` 回到它自己）且该环的权重必然是负的。因为 `w` 会在路径上出现两次且 `s` 到 `w` 的第二次出现处的路径长度小于 `s` 到 `w` 的第一次出现的路径长度。在最坏情况下，该算法的行为和通用算法相似并会将所有的 ![E](https://private.codecogs.com/gif.latex?E) 条边全部放松 ![V](https://private.codecogs.com/gif.latex?V) 轮。

　

>**算法 4.11　基于队列的 Bellman-Ford 算法**

>![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.107.png)

>Bellman-Ford 算法的实现修改了 `relax()` 方法，将被成功放松的边指向的所有顶点加入到一条 FIFO 队列中（队列中不出现重复的顶点）并周期性地检查 `edgeTo[]` 表示的子图中是否存在负权重环（请见正文）。

基于队列的 Bellman-Ford 算法能够准确有效地解决最短路径问题并且在实际中被广泛应用，甚至包括正权重的情况。例如，如图 4.4.23 所示，在含有 250 个顶点的样图中，算法进行了 14 轮操作且对于相同的问题比较路径长度的次数少于 Dijkstra 算法。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.108.png)

**图 4.4.23　Bellman-Ford 算法（250 个顶点）**

####4.4.6.7　负权重的边

图 4.4.24 显示了 Bellman-Ford 算法在处理含有负权重边的有向图的轨迹。首先将起点加入队列 `queue`，然后按照以下步骤计算最短路径树。

* 放松边 `0` → `2` 和 `0` → `4` 并将顶点 `2`、`4` 加入队列。
* 放松边 `2` → `7`并将顶点 `7` 加入队列。放松边 `4` → `5` 并将顶点 `5` 加入队列。然后放松失效的边 `4` → `7`。
* 放松失效的边 `7` → `5`、`5` → `4` 和 `5` → `7`。
* 放松边 `7` → `3` 和 `5` → `1` 并将顶点 `3` 和 `1` 加入队列。放松失效的边 `5` → `4` 和 `5` → `7`。
* 放松边 `3` → `6` 并将顶点 `6` 加入队列。放松失效的边 `1` → `3`。
* 放松失效的边 `6` → `0` 和 `6` → `2`。
* 放松边 `6` → `4` 并将顶点 `4` 加入队列。这条负权重边使得到顶点 `4` 的路径变短，因此它的边需要被再次放松（它们在第二轮中已经被放松过）。从起点到顶点 `5` 和 `1` 的距离已经失效并会在下一轮中修正。
* 放松边 `4` → `5` 并将顶点 `5` 加入队列。放松失效的边 `4` → `7`。
* 放松边 `5` → `1` 并将顶点 `1` 加入队列。放松失效的边 `5` → `4` 和 `5` → `7`。
* 放松失效的边 `1` → `3`。队列为空。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.109.png)

**图 4.4.24　Bellman-Ford 算法的轨迹（图中含有负权重边）**

在这个例子中，最短路径树就是一条从顶点 `0` 到顶点 `1` 的路径。从顶点 `4`、`5` 和 `1` 指出的所有边都被放松了两次。对照这个例子重读命题 X 的证明能够帮助你更好的理解这个算法。

####4.4.6.8　负权重环的检测

实现 `BellmanFordSP` 会检测负权重环来避免陷入无限的循环中。我们也可以将这段检测代码独立出来使得用例可以检查并得到负权重环。因此我们为表 4.4.4 中的 API 添加以下方法请见表 4.4.8。

**表 4.4.8　为处理负权重环扩展最短路径的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean hasNegativeCycle()</code></td><td>是否含有负权重环</td></tr>
<tr><td><code>Iterable&lt;DirectedEdge> negativeCycle()</code></td><td>得到负权重环（如果没有则返回 <code>null</code>）</td></tr>
</table>

实现这些方法并不困难，如 442 页的代码所示。在 `BellmanFordSP` 的构造函数运行之后，命题 Y 说明在将所有边放松 ![V](https://private.codecogs.com/gif.latex?V) 轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。如果是这样，`edgeTo[]` 数组所表示的子图中必然含有这个负权重环。因此，要实现 `negativeCycle()`，会根据 `edgeTo[]` 中的边构造一幅加权有向图并在该图中检测环。我们会使用并修改 4.2 节中的 `DirectedCycle` 类来在加权有向图中寻找环（请见练习 4.4.12）。这种检查的成本分为以下几个部分。

* 添加一个变量 `cycle` 和一个私有函数 `findNegativeCycle()`。如果找到负权重环，该方法会将 `cycle` 的值设为含有环中所有边的一个迭代器（如果没有找到则设为 `null`）。
* 每调用 ![V](https://private.codecogs.com/gif.latex?V) 次 `relax()` 方法后即调用 `findNegativeCycle()` 方法。

这种方法能够保证构造函数中的循环必然会终止。另外，用例可以调用 `hasNegativeCycle()` 来判断是否存在从起点可达的负权重环（并用 `negativeCycle()` 来获取这个环）。要在任意有向图中检测负权重环的存在只需稍作扩展即可（请见练习 4.4.43）。

图 4.4.25 是 Bellman-Ford 算法在一幅含有负权重环的有向图中的运行轨迹。头两轮放松操作与处理 tinyEWDn. txt 时是一样的。在第三轮中，算法在放松了边 `7` → `3` 和 `5` → `1` 并将顶点 `3` 和 `1` 加入队列后开始放松负权重边 `5` → `4`。在这次放松操作中算法发现了一个负权重环 `4` → `5` → `4`。它将 `5` → `4` 加入最短路径树中并在 `edgeTo[]` 中将环和起点隔离开来。从这时开始，算法沿着环继续运行并会减少到达所遇到的所有顶点的距离，直至检测到环的存在，此时队列非空。环被保存在 `edgeTo[]` 中，`findNegativeCycle()` 会在其中找到它。

```
private void findNegativeCycle()
{
   int V = edgeTo.length;
   EdgeWeightedDigraph spt;
   spt = new EdgeWeightedDigraph(V);
   for (int v = 0; v < V; v++)
      if (edgeTo[v] != null)
         spt.addEdge(edgeTo[v]);

   EdgeWeightedCycleFinder cf;
   cf = new EdgeWeightedDirectedCycle(spt);

   cycle = cf.cycle();
}

public boolean hasNegativeCycle()
{  return cycle != null;  }

public Iterable<DirectedEdge> negativeCycle()
{  return cycle;  }
```

{-:-}Bellman-Ford 算法的负权重环检测方法

![{93%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.110.png)

**图 4.4.25　Bellman-Ford 算法的轨迹（含有负权重环的图）**

####4.4.6.9　套汇

假设有一个基于商品贸易的金融交易市场。以下框注显示的是示例文件 rates.txt 的内容，你可以在任意货币兑换比例的表格中找到类似的内容。文件的第一行是货币的种类数 ![V](https://private.codecogs.com/gif.latex?V)，接下来的每一行都对应一种货币，开头是该货币的名称，紧接着是它和其他货币兑换的汇率。简单起见，这个例子中只包含了能够在现代市场中进行交易的数百种货币中的五种：美元（USD）、欧元（EUR）、英镑（GBP）、瑞士法郎（CHF）和加元（CAD）。第 `s` 行的第 `t` 个数字表示一个汇率，即购买一个单位的第 `s` 行的货币需要多少个单位的第 `t` 行的货币。例如，这张表告诉我们，1000 美元能够购买 741 欧元。这张表格等价于一幅**完全的加权有向图**，顶点对应着货币，边则对应着汇率。权重为 `x` 的边 `s` → `t` 表示从货币 `s` 到货币 `t` 的汇率为 `x`。这张图中的路径则表示多次兑换。例如，将权重为 `y` 的边 `t` → `u` 和刚才的边结合起来就得到了一条路径 `s` → `t` → `u`，即一个单位的货币 `s` 可以兑换为 `xy` 个单位的货币 `u`。比如，欧元可以兑换得到 1012.206=741\*1.366 加元。注意，这比直接用美元兑换的汇率更高。你可能会以为 `xy` 总是应该等于边 `s` → `u` 的权重，但这张表格所表示的金融系统非常复杂，并不总是能够保证这种一致性。因此，找到所有从 `s` 到 `u` 的路径中所有边的权重之积最大者就是我们最感兴趣的问题。一种更有趣的情况是，所有边的权重之积**小于**从终点指向起点的边的权重。在这个示例中，假设边 `u` → `s` 的权重为 `z` 且 `xyz>1`。那么环 `s` → `t` → `u` → `s` 就能够用一个单位的货币 `s` 得到多于一个单位 `(xyz)` 的货币 `s`。换句话说，将货币 `s` 兑换为 `t`、`u` 并最后再兑换为 `s` 就可以得到 `100(xyz-1)` 的利润。例如，如果将 1012.206 加元重新兑换为美元，可以得到 1012.206*0.995=1007.14497 美元，也就是得到了 7.14497 美元的利润。这看起来似乎不多，但一个外汇交易商可能会用一百万美元并在每分钟都进行一遍这样的交易，也就是说他每分钟的利润将超过 7000 美元，或者说每小时的利润超过 420 000 美元！这就是套汇交易的一个例子，请见图 4.4.26。如果没有外力的限制，比如手续费或是交易金额上限，交易商可以从其中获取无限的利润。即使是在现实世界中的这些限制下，套汇的利润仍然是非常高的。这个问题和最短路径问题有什么关系呢？要回答这个问题非常简单。

```
% more rates.txt
5
USD  1      0.741  0.657  1.061  1.005
EUR  1.349  1      0.888  1.433  1.366
GBP  1.521  1.126  1      1.614  1.538
CHF  0.942  0.698  0.619  1      0.953
CAD  0.995  0.732  0.650  1.049  1
```

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.111.png)

**图 4.4.26　一次套汇机会**

>**命题 Z**。套汇问题等价于加权有向图中的负权重环的检测问题。

>**证明**。取每条边权重的自然对数并取反，这样在原始问题中所有边的权重之积的计算就转化为了新图中所有边的权重之和的计算。任意权重之积 ![w_1w_2\cdots w_k](https://private.codecogs.com/gif.latex?w_1w_2\cdots%20w_k) 即对应 ![-\ln(w_1)-\ln(w_2)-\cdots-\ln(w_k)](https://private.codecogs.com/gif.latex?-\ln(w_1%29-\ln(w_2%29-\cdots-\ln(w_k%29) 之和。转换后边的权重可能为正也可能为负。一条从 `v` 到 `w` 的路径表示将货币 `v` 兑换为货币 `w`，图中的任意负权重环都是一次套汇的好机会（请见图 4.4.27）。

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/08.d04z.112.png)

**图 4.4.27　一个负权重环就表示了一次套汇的机会**

在这个示例中，货币可以任意兑换，因此有向图是完全的，任意负权重环都是从任意顶点可达的。在一般的商品交易中，有些边可能并不存在，因此需要练习 4.4.43 所述的只有一个参数的构造函数。目前没有已知的寻找**最佳**套汇机会（图中负权重最小的环）的高效算法（图的规模不需要很大就能使所需的计算量超过计算机的承受能力），但找出**任意**套汇机会的最快算法仍然是很重要的——在第二快的算法找到任何套汇机会之前，使用这种算法的商人很可能已经可以系统地排除许多不佳的套汇机会了。

>**货币兑换中的套汇**

>```
>public class Arbitrage
>{
>    public static void main(String[] args)
>    {
>       int V = StdIn.readInt();
>       String[] name = new String[V];
>       EdgeWeightedDigraph G = new EdgeWeightedDigraph(V);
>       for (int v = 0; v < V; v++)
>       {
>          name[v] = StdIn.readString();
>          for (int w = 0; w < V; w++)
>          {
>             double rate = StdIn.readDouble();
>             DirectedEdge e = new DirectedEdge(v, w, -Math.log(rate));
>             G.addEdge(e);
>          }
>       }
>
>       BellmanFordSP spt = new BellmanFordSP(G, 0);
>       if (spt.hasNegativeCycle())
>       {
>          double stake = 1000.0;
>          for (DirectedEdge e : spt.negativeCycle())
>          {
>             StdOut.printf("%10.5f %s", stake, name[e.from()]);
>
>             stake *= Math.exp(-e.weight());
>             StdOut.printf("= %10.5f %s\n", stake, name[e.to()]);
>          }
>       }
>       else StdOut.println("No arbitrage opportunity");
>    }
>}
>```

>这段代码调用了 `BellmanFordSP` 类来寻找汇率表中的套汇机会。它首先使用完全有向图表示汇率表，然后用 Bellman-Ford 算法来寻找图中的负权重环。

>```
>% java Arbitrage < rates.txt
>1000.00000 USD =  741.00000 EUR
>  741.00000 EUR = 1012.20600 CAD
>1012.20600 CAD = 1007.14497 USD
>```

命题 Z 的证明即使在没有套汇机会的情况下仍然有用，因为它将货币兑换问题转化为了一个最短路径问题。因为对数函数是单调的（且会对计算的结果取反），当边的权重之和最小时汇率之积正好最大。尽管边的权重可正可负，从 `v` 到 `w` 的最短路径仍然是将货币 `v` 兑换为货币 `w` 的最好方法。

###4.4.7　展望

表 4.4.9 总结了本节中我们所学习到的各种最短路径算法的重要性质。在这些算法中进行选择的第一个条件是问题所涉及的有向图的基本性质。它含有负权重的边吗？它含有环吗？它含有负权重的环吗？除了这些基本性质之外，加权有向图的特性多种多样，因此在有多个合适的选择时就需要通过实验找出最佳的算法。

**表 4.4.9　最短路径算法的性能特点**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="2">算法</th><th rowspan="2">局限</th><th colspan="2">路径长度的比较次数（增长的数量级）</th><th rowspan="2">所需空间</th><th rowspan="2">优势</th></tr>
<tr><th>一般情况</th><th>最坏情况</th></tr>
<tr><td>Dijkstra 算法（即时版本）</td><td>边的权重必须为正</td><td><img src="https://private.codecogs.com/gif.latex?E%20\log%20V" /></td><td><img src="https://private.codecogs.com/gif.latex?E%20\log%20V" /></td><td><img src="https://private.codecogs.com/gif.latex?V" /></td><td>最坏情况下仍有较好的性能</td></tr>
<tr><td>拓扑排序</td><td>只适用于无环加权有向图</td><td><img src="https://private.codecogs.com/gif.latex?E+V" /></td><td><img src="https://private.codecogs.com/gif.latex?E+V" /></td><td><img src="https://private.codecogs.com/gif.latex?V" /></td><td>是无环图中的最优算法</td></tr>
<tr><td>Bellman-Ford 算法（基于队列）</td><td>不能存在负权重环</td><td><img src="https://private.codecogs.com/gif.latex?E+V" /></td><td><img src="https://private.codecogs.com/gif.latex?VE" /></td><td><img src="https://private.codecogs.com/gif.latex?V" /></td><td>适用领域广泛</td></tr>
</table>

**历史资料**

自 20 世纪 50 年代以来，最短路径算法就已经被深入地研究并被广泛应用了。计算最短路径的 Dijkstra 算法的历史和计算最小生成树的 Prim 算法的历史背景相似（并且也相关）。**Dijkstra 算法**既指的是按照顶点距离起点的远近顺序构造最短路径树的算法，也指的是该算法的实现，（它也是最适合用邻接矩阵表示的算法。），因为 Dijkstra 在 1959 年的一篇论文中发表了上述观点（并且证明了这种方法同样也可以用来计算最小生成树）。稀疏图算法的性能改进来自于之后对优先队列实现的改进，不仅仅针对最短路径问题。这其中最重要的是 Dijkstra 算法性能的改进。（例如，使用**斐波那契堆**后最坏情况下的复杂度可以减少到 ![E+V \log V](https://private.codecogs.com/gif.latex?E+V%20\log%20V)）。实践证明 Bellman-Ford 算法十分有效并且应用领域广泛，特别是处理一般性的加权有向图。Bellman-Ford 算法计算普通应用的运行时间常常是线性的，在最坏情况下它的运行时间是 ![VE](https://private.codecogs.com/gif.latex?VE)。最坏情况下的运行时间为线性级别的稀疏图的最短路径算法是一个仍在研究之中的问题。Bellman-Ford 算法最早由 L.Ford 和 R.Bellman 发表于 20 世纪 50 年代。尽管我们已经看到许多其他的图算法性能得到了大幅改进，但是处理含有负权重边（但不含负权重环）的且在最坏情况下性能更好的有向图算法还没有出现。

###答疑

**问**　为什么要分别为无向图、有向图、加权无向图、加权有向图定义不同的数据类型？

**答**　这么做是为了使用例代码更清晰，同时也是为了更加简洁和高效地实现没有权重的图。在需要处理各种图的应用或系统中，软件工程中的标准做法就是先定义一种抽象数据结构并根据它衍生出其他抽象数据结构，也就是 4.1 节中学习的无向图 `Graph`，4.2 节中学习的有向图 `Digraph`，4.3 节中学习的加权无向图 `EdgeWeightedGraph`，或是在本节中学习的加权有向图 `EdgeWeightedDigraph`。

**问**　如何在（加权）无向图中找到最短路径？

**答**　对于边的权重均为正的图，Dijkstra 算法可以解决这个问题。只需根据给定的 `EdgeWeightedGraph` 构造一幅 `EdgeWeightedDigraph`（无向图中的每条边都对应着有向图中的两条方向不同的边）并执行 Dijkstra 算法即可。如果边的权重可能为负，高效的算法也是存在的，但它们比 Bellman-Ford 算法更复杂。

###练习

**4.4.1**　真假判断：将每条边的权重都加上一个常数不会改变单点最短路径问题的答案。

**4.4.2**　为 `EdgeWeightedDigraph` 类实现 `toString()` 方法。

**4.4.3**　为稠密图实现一种使用邻接矩阵表示法（用二维数组保存边的权重，请参考练习 4.3.10）的 `EdgeWeightedDigraph` 类。忽略平行边。

**4.4.4**　在 tinyEWD.txt 中（请见图 4.4.4）删去顶点 `7`。画出加权有向图中以顶点 `0` 为起点的最短路径树，并使用父链接数组表示这棵树。将图中所有边的方向反转并回答相同的问题。

**4.4.5**　在 tinyEWD.txt 中（请见图 4.4.4）改变边 `0` → `2` 的方向。画出该加权有向图中以顶点 2 为起点的两棵不同的最短路径树。

**4.4.6**　给出用即时版本的 Dijkstra 算法计算练习 4.4.5 所定义的图的最短路径树的轨迹。

**4.4.7**　实现 `DijkstraSP` 的另一个版本，支持一个方法来返回一幅加权有向图中从 `s` 到 `t` 的**另一条**最短路径。（如果从 `s` 到 `t` 的最短路径只有一条则返回 `null`。）

**4.4.8**　一幅有向图的**直径**指的是连接任意两个顶点的所有最短路径中的最大长度。编写一个 `DijkstraSP` 的用例，找出边的权重非负的给定 `EdgeWeightedDigraph` 图的直径。

**4.4.9**　表 4.4.10 来自于一张很早以前出版的公路地图，它显示的是城市之间的最短路径的长度。这张表中有一个错误。改正这个错误并新建一张表来说明最短路径是哪条。

**4.4.10**　将练习 4.4.4 中定义的有向图中的边看作无向边，即每条边对应加权有向图中的两条方向不同但权重相同的边。为对应的加权有向图回答练习 4.4.6 中的问题。

**4.4.11**　使用 1.4 节中的内存使用模型评估用 `EdgeWeightedDigraph` 表示一幅含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的图所需的内存。

**4.4.12**　修改 4.2 节中的 `DirectedCycle` 类和 `Topological` 类，使之使用本节中的 `EdgeWeightedDigraph` 类和`DirectedEdge` 类的API并实现`EdgeWeightedCycleFinder` 类和`EdgeWeightedTopological` 类。

**4.4.13**　从 tinyEWD.txt 中（请见图 4.4.4）删去边 `5` → `7`，用 Dijkstra 算法计算所得的有向图的最短路径树并按照正文中的样式给出算法的轨迹。

**表　4.4.10**

||普罗维登斯|威斯特里|新伦敦|诺威治|
|-|-|-|-|-|
|普罗维登斯|—|53|54|48|
|威斯特里|53|—|18|101|
|新伦敦|54|18|—|12|
|诺威治|48|101|12|—|

**4.4.14**　给出使用 4.4.6.1 节和 4.4.6.2 节的两种尝试处理图 4.4.19 的 tinyEWDn.txt 所得到的路径。

**4.4.15**　如果从顶点 `s` 到 `v` 的路径上存在一个负权重环，调用 Bellman-Ford 算法的 `pathTo(v)` 方法会发生什么？

**4.4.16**　假设用 `EdgeWeightedGraph` 中的每条边 `Edge` 都替换为两条（两个方向各一条）`DirectedEdge` 的方式将 `EdgeWeightedGraph` 类转化为 `EdgeWeightedDigraph` 类（如答疑中关于 Dijkstra 算法的部分所述）然后再使用 Bellman-Ford 算法处理它。说明为什么这种方法大错特错。

**4.4.17**　在 Bellman-Ford 算法中如果一个顶点在同一轮中被两次加入队列会发生什么？

　　　**解答**：算法所需的运行时间将会达到指数级。例如，描述一幅边的权重全部为 -1 的加权有向完全图中 Bellman-Ford 算法的执行情况。

**4.4.18**　编写一个 CPM 的用例来打印出所有的关键路径。

**4.4.19**　找出正文中的例子里权重最低的环（即最佳套汇机会）。

**4.4.20**　从网上或者报纸上找到一张汇率表并用它构造一张套汇表。**注意**：不要使用根据若干数据计算得出的汇率表，它们的精度有限。**附加题**：从汇率市场上赚点外快！

**4.4.21**　用 Bellman-Ford 算法计算练习 4.4.5 中的加权有向图的最短路径树并按照正文中的样式给出算法的轨迹。

###提高题

**4.4.22**　**顶点的权重**。证明，要得到顶点也有非负权重的加权有向图中的最短路径（路径的权重为路径上的顶点权重之和），可以通过构造一幅只有边含有权重的加权有向图解决。

**4.4.23**　**给定两点的最短路径**。设计并实现一份 API，使用 Dijkstra 算法的改进版本解决加权有向图中**给定两点**的最短路径问题。

**4.4.24**　**多起点最短路径**。设计并实现一份 API，使用 Dijkstra 算法解决加权有向图中的**多起点**最短路径问题，其中边的权重均为正：给定一组起点，找到相应的最短路径森林并实现一个方法为用例返回从任意起点到达每个顶点的最短路径。**提示**：添加一个伪顶点和从该顶点指向每个起点的一条权重为零的边，或者在初始化时将所有起点加入优先队列并将它们在 `distTo[]` 中对应的值均设为 0。

**4.4.25**　**两个顶点集合之间的最短路径**。给定一幅边的权重均为正的有向图和两个没有交集的顶点集 ![S](https://private.codecogs.com/gif.latex?S) 和 ![T](https://private.codecogs.com/gif.latex?T)，找到从 ![S](https://private.codecogs.com/gif.latex?S) 中的任意顶点到达 ![T](https://private.codecogs.com/gif.latex?T) 中的任意顶点的最短路径。你的算法在最坏情况下所需的时间应该与 ![E \log V](https://private.codecogs.com/gif.latex?E%20\log%20V) 成正比。

**4.4.26**　**稠密图中的单点最短路径**。实现另一个版本的 Dijkstra 算法，使之能够在与 ![V^2](https://private.codecogs.com/gif.latex?V^2) 成正比的时间内在一幅稠密的加权有向图中计算出给定顶点的最短路径树。请使用邻接矩阵法表示稠密图（请参考练习 4.4.3 和练习 4.3.29）。

**4.4.27**　**欧几里得图中的最短路径**。已知图中的顶点均在平面上，修改 API 以提高 Dijkstra 算法的性能。

**4.4.28**　**有向无环图中的最长路径**。重新实现 `AcyclicLP` 类，根据命题 T 解决加权有向无环图中的最长路径问题。

**4.4.29**　**一般最优性**。完成命题 W 的证明，说明如果存在从 `s` 到 `v` 的有向路径且从 `s` 到 `v` 的任意路径上的所有顶点都不在任意负权重环上，那么必然存在一条从 `s` 到 `v` 的最短路径（**提示**：参考命题 P）。

**4.4.30**　**含有负权重环的图中的任意顶点对之间的最短路径**。参考 4.4.4.3 节框注“任意顶点对之间的最短路径”所实现的不含负权重环的图中任意顶点对之间的最短路径问题并设计一份 API。使用 Bellman-Ford 算法的一个变种来确定权重数组 `pi[]`，使得对于任意边 `v` → `w`，边的权重加上 `pi[v]` 和 `pi[w]` 之差的和非负。然后更新所有边的权重，使得 Dijkstra 算法可以在新图中找出所有的最短路径。

**4.4.31**　**线图中任意顶点对之间的最短路径**。给定一幅加权线图（无向连通图，除了两个端点度数为 1 之外所有顶点的度数为 2），给出一个算法在线性时间内对图进行预处理并在常数时间内返回任意两个顶点之间的最短路径。

**4.4.32**　**启发式的父结点检查**。修改 Bellman-Ford 算法，仅当顶点 `v` 在最短路径树中的父结点 `edgeTo[v]` 目前不在队列中时才访问 `v`。Cherkassky、Goldberg 和 Radzik 在实践中发现这种启发式的做法十分有帮助。证明这种方法能够正确的计算出最短路径且在最坏情况下的运行时间和 ![E{V}](https://private.codecogs.com/gif.latex?E{V}) 成正比。

**4.4.33**　**网格图中的最短路径**。给定一个 ![N\times N](https://private.codecogs.com/gif.latex?N\times%20N) 的正整数矩阵，找到从 `(0,0)` 到 ![(N-1,N-1)](https://private.codecogs.com/gif.latex?(N-1,N-1%29) 的最短路径，路径的长度即为路径中所有正整数之和。在只能向右和向下移动的限制下重新解答这个问题。

**4.4.34**　**单调最短路径**。给定一幅加权有向图，找出从 `s` 到其他每个顶点的单调最短路径。如果一条路径上的所有边的权重是严格**单调**递增或递减的，那么这条路径就是单调的。这样的路径应该是简单的（不包含重复顶点）。**提示**：按照权重的升序放松所有边并找到一条最佳路径；然后按照权重的降序放松所有边再找到另一条最佳路径。

**4.4.35**　**双调最短路径**。给定一幅有向图，找到从 `s` 到其他每个顶点的**双调**最短路径（如果存在）。如果从 `s` 到 `t` 的路径上存在一个中间顶点 `v` 使得从 `s` 到 `v` 中的所有边的权重均严格单调递增且从 `v` 到 `t` 中的所有边的权重均严格单调递减，那么这就是一条双调路径。这样的路径应该是简单的（不包含重复顶点）。

**4.4.36**　**邻居顶点**。编写一个 `SP` 的用例，找出一幅给定加权有向图中和一个给定顶点的距离在 ![d](https://private.codecogs.com/gif.latex?d) 之内的所有顶点。你的算法所需的运行时间应该与由这些顶点和依附于它们的边组成的子图的大小以及 ![V](https://private.codecogs.com/gif.latex?V)（用于初始化数据结构）中的较大者成正比。

**4.4.37**　**关键边**。给出一个算法来找到给定的加权有向图中的一条边，删去这条边使得给定的两个顶点之间的最短距离的增加值最大。

**4.4.38**　**敏感度**。给定一幅加权有向图和一对顶点 `s` 和 `t`，编写一个 `SP` 的用例对该图中的所有边进行敏感度分析：计算一个 ![V\times V](https://private.codecogs.com/gif.latex?V\times%20V) 的布尔矩阵，对于任意的 `v` 和 `w`，当 `v` → `w` 为加权有向图中的一条边且增加 `v` → `w` 的权重不会增加从 `s` 到 `t` 的最短路径的权重时，`v` 行 `w` 列的值为 `true`，否则为 `false`。

**4.4.39**　**延时 Dijkstra 算法的实现**。根据正文实现 Dijkstra 算法的延时版本。

**4.4.40**　**瓶颈最短路径树**。请证明一幅无向图中的一棵最小生成树等价于该图中的一棵瓶颈最短路径树：对于任意一对顶点 `v` 和 `w`，该树都含有一条连接它们的路径且其中的最长边是所有连接两点的路径中最短的。

**4.4.41**　**双向搜索**。基于算法 4.9 的代码为给定两点的最短路径问题实现一个类，但在初始化时将起点和终点都加入优先队列。这么做会使最短路径树从两个顶点同时开始生长，你的主要任务是决定两棵树相遇时应该怎么办。

**4.4.42**　**最坏情况（Dijkstra 算法）**。找出含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的一组图，使得 Dijkstra 算法处理它们所需的运行时间为最坏情况。

**4.4.43**　**负权重环的检测**。假设为算法 4.11 加入了一个构造函数，它和已有的构造函数的区别仅在于不需要第二个参数并将 `distTo[]` 中的所有元素初始化为 0。证明，如果用例调用的是这个构造函数，那么当且仅当图中含有一个负权重环时，`hasNegativeCycle()` 才会返回 `true`。（`negativeCycle()` 会返回那个负权重环。）

　　　**解答**：向原图添加一个新的起点以及从该起点指向所有其他顶点的权重为 0 的边。在一轮放松之后，`distTo[]` 中的所有元素的值均会变为 0，从新起点开始寻找一个负权重环和在原图中寻找负权重环是等价的。

**4.4.44**　**最坏情况（Bellman-Ford 算法）**。找出一组图，使得算法 4.11 的运行时间与 ![VE](https://private.codecogs.com/gif.latex?VE) 成正比。

**4.4.45**　**快速 Bellman-Ford 算法**。对于边的权重为整数且绝对值不大于某个常数的特殊情况，给出一个解决一般的加权有向图中的单点最短路径问题的算法，其所需的运行时间低于线性对数级别。

**4.4.46**　**动画**。编写一段程序将 Dijkstra 算法用动画表现出来。

###实验题

**4.4.47**　**随机加权有向稀疏图**。修改你为练习 4.3.34 给出的解答，随机指定每条边的方向。

**4.4.48**　**随机加权有向欧几里得图**。修改你为练习 4.3.35 给出的解答，随机指定每条边的方向。

**4.4.49**　**随机加权有向网格图**。修改你为练习 4.3.36 给出的解答，随机指定每条边的方向。

**4.4.50**　**负权重边 I**。修改你的随机加权有向图生成器，通过调整比例将边的权重控制在在 ![x](https://private.codecogs.com/gif.latex?x) 和 ![y](https://private.codecogs.com/gif.latex?y) 之间（![x](https://private.codecogs.com/gif.latex?x) 和 ![y](https://private.codecogs.com/gif.latex?y) 都在 -1 和 1 之间）。

**4.4.51**　**负权重边 II**。修改你的随机加权有向图生成器，将固定比例（此值由用例指定）的边的权重取反来生成负权重的边。

**4.4.52**　**负权重边 III**。编写一段程序，调用你的加权有向图生成器，尽可能为大范围的 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E) 值生成多幅加权有向图，保证图中大部分边的权重为负且只有若干个负权重环。

>　　测试所有的算法并研究所有图的模型的所有参数是不现实的。请为下面的每一道题都编写一段程序来处理从输入得到的任意图。这段程序可以调用上面的任意生成器并对相应的图模型进行实验。你可以根据上次实验的结果自己作出判断来选择不同实验。陈述结果以及由此得出的任何结论。

**4.4.53**　**预测**。请估计你的计算机和程序系统使用 Dijkstra 算法在 10 秒钟之内能够计算出图中所有的最短路径的图的最大规模，其中 ![E=10V](https://private.codecogs.com/gif.latex?E=10V)，误差在 10 倍以内。

**4.4.54**　**延时的代价**。对于各种图的模型，运行实验并根据经验比较 Dijkstra 算法的延时版本和即时版本的性能差异。

**4.4.55**　**Johnson 算法**。使用一个 `d` 向堆实现优先队列。对于各种加权有向图的模型，找到 `d` 的最优值。

**4.4.56**　**套汇模型**。实现一个模型来生成随机的套汇问题。目标是尽量生成与练习 4.4.20 中相似表格。

**4.4.57**　**最后期限限制下的并行任务调度模型**。实现一个模型来生成随机的最后期限限制下的并行任务调度问题。目标是尽量生成复杂但可以解决的问题。