#第 6 章　背景

在现代社会中，计算机设备无处不在。在过去的几十年中，我们世界中的电子设备还是一片空白，但现在它们已经成为数十亿人日常必备的工具。今天的手机甚至都比 30 年前只有少数人才有权使用的超级计算机强大若干个数量级。这些设备高效工作的背后都离不开算法，而其中的一些算法本书中也有所讨论。这是为什么呢？因为**适者生存**。可扩展的（线性的和线性对数级别的）算法是这个过程的核心并证明了高效算法的重要性。20 世纪 60 年代和 70 年代的一些研究者用这些算法为我们的今天打下了基础。他们知道，可扩展的算法是未来的关键，而过去几十年的发展也证明了这一点。现在，基础设施已经完备，人们已经开始**利用**它们达到各种目的。正如 B.Chazelle 所说，20 世纪是方程的世纪，但 21 世纪是**算法**的世纪。

本书中讨论的基础算法只是一个开始。当算法能够成为大学中的一门独立学科时，这一天就快要到来了（也许已经来了）。在商业应用、科学计算、工程、运筹学和其他无数有待人们探索的领域中，高效的算法都能使原来不可能解决的问题得到解决。本书的重点是学习**重要**而**实用**的算法。在本章中，我们会沿着这条路继续讨论几个示例，它们能够说明已经学过的一些算法在高级实践情景中的作用。（还包括一些学习算法的方法。）为了说明算法的影响范围，我们首先列出算法的几个重要的应用领域，然后详细讨论几个有代表性的示例并介绍算法的相关理论来说明应用的深度。不过对于这本大厚书来说，在最后涉及的这两个主题都是介绍性的，并不全面，实际生活中还有许多同样广泛的领域、同样重要的应用场景、同样有影响力的具体问题。

**商业应用**

互联网的出现加强了算法在**商业应用软件**中的核心地位。人们经常使用的所有应用都得益于我们已经学过的许多经典算法：

* 基础设施（操作系统、数据库、通信）；
* 应用程序（电子邮件、文档处理、数码照片）；
* 出版（书籍、杂志、网络内容）；
* 网络（无线网络、社交网络、互联网）；
* 交易处理（金融、零售、网络搜索）。

本章中将会讨论一个有代表性的示例，即 **B- 树**。它是为 20 世纪 60 年代的大型机发明的一种复杂的数据结构，但今天它仍然是现代数据库系统的基础结构。此外，还将讨论用于文本索引的**后缀数组**。

**科学计算**

自从冯·诺依曼在 1950 年发明了归并排序之后，算法在**科学计算**领域逐渐起到了重要的作用。今天的科学家需要处理大量的实验数据。他们在同时使用数学模型和计算模型来理解自然世界，包括：

* 数学计算（多项式、矩阵、微分方程）；
* 数据处理（实验结果和观测资料，特别是基因组学）；
* 计算模型和模拟。

这些任务都可能需要大量复杂的海量数据计算。在科学计算领域，本章中会详细讨论的一个经典示例就是**事件驱动模拟**问题。它的思想是维护一个复杂的真实世界的模型并根据时间控制模型中发生的变化。这种基础方法有着非常多的应用。此外还将讨论一个基因计算领域的基础数据处理问题。

**工程学**

现代**工程学**的基础是技术，而现代技术的基础是计算机。因此，算法能够发挥重要作用的方面包括：

* 数学计算和数据处理；
* 计算机辅助设计和生产；
* 基于算法的工程设计（网络、控制系统）；
* 图像和其他医学系统。

工程师和科学家使用的许多工具和方法都是相同的。例如，科学家用计算模型和模拟来理解自然世界；而工程师用计算模型和模拟来设计、建造并控制他们所制造的各种产品。

**运筹学**

**运筹学**领域的研究者和实践者开发了各种数学模型并用它们解决了许多问题，包括：

* 任务调度；
* 决策；
* 资源分配。

4.4 节中的最短路径问题就是一个经典的运筹学问题。本章会再次讨论它并介绍**最大流量**问题。我们会展示**规约**的重要性并讨论它对于**问题解决**（problem-solving）的通用模型的影响，特别是对运筹学中核心的**线性规划**模型的影响。

算法在计算机科学的各个子领域中都有着重要的地位，它的应用领域包括，但绝对不局限于：

* 计算几何；
* 密码学；
* 数据库；
* 编程语言与系统；
* 人工智能。

在所有领域中，说明问题并找到有效算法和数据结构来解决问题都是非常重要的。我们已经学过的部分算法是可以直接使用的。更重要的是，本书的核心内容，也就是设计、实现和分析算法的一般方法在所有这些领域中都已经被成功地验证过。这种效应已经从计算机科学扩散到了许多其他领域，包括体育、音乐、语言学、金融、神经科学，等等。

我们现在已经学习了许多重要且实用的算法，那么理解它们之间的相互关系就变得很必要了。在本章的（也是本书的！）结尾我们会简要介绍**计算理论**，重点是**不可解性**（intractability）和 P=NP? 这个问题。它们仍然是理解实践中遇到的各种问题的关键。

###6.0.1　事件驱动模拟

我们的第一个示例是一个基础的科学应用：按照弹性碰撞的原理模拟粒子系统的运动。科学家通过这个系统可以理解和预测物理系统的性质。这个模型可以模拟气体中分子的运动、化学反应的动态过程、原子扩散、最密堆积问题（sphere packing）、行星的环的稳定性、某些元素的相变、一维自引力体系前向阵面传播技术等许多问题。它可应用的范围从分子运动中的微小亚原子粒子到天体物理学中巨大的星体对象。

讨论这个问题需要一些高中物理知识、一些软件工程的知识和一些算法知识。我们把大部分和物理有关的内容留作练习，而主要关注使用基础的算法工具（基于堆的优先队列），以处理它的一个实际应用，将不可能的计算变为可能。

####6.0.1.1　刚性球体模型

首先介绍一个理想模型，它描述的是原子和分子在含有以下性质的容器中的运动：

* 运动的粒子与墙以及互相之间的碰撞是弹性的；
* 每个粒子都是一个已知位置、速度、质量和直径的球体；
* 不存在其他外力。

这个简单的模型在**统计力学**这个既与宏观现象（例如温度和压力）有关又与微观现象（例如单个原子和分子的运动）有关的学科中十分重要。麦克斯韦和玻尔兹曼使用这个模型得到了由温度的函数表示的相互碰撞的分子的速度分布，爱因斯坦用这个模型解释了花粉颗粒在水中的布朗运动。不存在其他外力的假设意味着粒子在碰撞之前是在做匀速直线运动。我们也可以通过添加其他作用力来扩展这个模型。例如，如果加上摩擦力和自旋，那就可以更加准确地描述一些熟悉的物理运动，例如台球桌上的台球。

####6.0.1.2　时间驱动模拟

我们的主要目标是维持这个模型，即希望能够记录所有粒子在任意时间内的位置和速度。为此，需要计算：在给定了时刻 ![t](https://private.codecogs.com/gif.latex?t) 时的所有粒子的位置和速度后，再给出 ![dt](https://private.codecogs.com/gif.latex?dt) 时间之后，即未来的时间点 ![t+dt](https://private.codecogs.com/gif.latex?t+dt) 时它们的位置和速度。如果所有粒子互相之间以及和墙的距离都很远，那么计算就很简单了：因为粒子的轨迹是一条直线，所以只需要用粒子的速度就可以更新它的位置。这个问题的挑战在于要考虑碰撞情况。一种解决方法叫做**时间驱动模拟**（请见图 6.0.1），它基于使用固定长度的 ![dt](https://private.codecogs.com/gif.latex?dt)。在每次更新时，我们都需要检查所有粒子对，判定它们是否可能相遇，然后还原它们的第一次碰撞。此时，我们将会更新两个粒子的速度以反映出碰撞的结果（计算方法会稍后讨论）。在粒子数量很多时，这种方式的计算量非常大：如果 ![dt](https://private.codecogs.com/gif.latex?dt) 是以秒计（一般为一秒的若干分之一），它模拟 ![N](https://private.codecogs.com/gif.latex?N) 个粒子的系统一秒钟的运动所需的时间与 ![N^2/dt](https://private.codecogs.com/gif.latex?N^2/dt) 成正比。这种成本太昂贵了（比平方级别的算法更高）——在一般的应用中，![N](https://private.codecogs.com/gif.latex?N) 都会非常大而 ![dt](https://private.codecogs.com/gif.latex?dt) 会非常小。![dt](https://private.codecogs.com/gif.latex?dt) 的问题在于如果它太小，计算量就太高，但如果它太大，那就可能错过许多次碰撞，请见图 6.0.2。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.001.png)

**图 6.0.1　以时间作为驱动的模拟**

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.002.png)

**图 6.0.2　驱动模拟的主要问题**

####6.0.1.3　事件驱动模拟

另一种方法是仅关注碰撞发生的时间点，重点关注**下一次**碰撞（因为在此之前由速度计算得到的所有粒子的位置都是有效的）。因此，我们可以使用一个优先队列来记录所有**事件**。事件是未来的某个时间的一次潜在的碰撞，可能发生在两个粒子之间，也可能发生在粒子和墙之间。和每个事件相关联的优先级就是它发生的时间，因此当从优先队列中**删去优先级最低的元素**时，就会得到下一次潜在的碰撞。

####6.0.1.4　碰撞预测

我们如何才能识别潜在的碰撞呢？粒子的速度正好提供了这个必要的信息。例如，假设在单位空间中，在时刻 ![t](https://private.codecogs.com/gif.latex?t) 有一个半径为 ![s](https://private.codecogs.com/gif.latex?s) 速度为 ![(v_x,v_y)](https://private.codecogs.com/gif.latex?(v_x,v_y%29) 的粒子位于 ![(r_x,r_y)](https://private.codecogs.com/gif.latex?(r_x,r_y%29)。假设墙位于 ![x=1](https://private.codecogs.com/gif.latex?x=1) 处，高度 ![y](https://private.codecogs.com/gif.latex?y) 在 0 到 1 之间。我们感兴趣的是运动的横向分量，因此注意力集中在位置的 ![x](https://private.codecogs.com/gif.latex?x) 分量 ![r_x](https://private.codecogs.com/gif.latex?r_x) 和速度的 ![x](https://private.codecogs.com/gif.latex?x) 分量 ![v_x](https://private.codecogs.com/gif.latex?v_x) 上。如果 ![v_x](https://private.codecogs.com/gif.latex?v_x) 是负数，那么粒子的轨迹不会与墙体相交，但如果 ![v_x](https://private.codecogs.com/gif.latex?v_x) 是正数，那就存在一个粒子和墙的潜在碰撞。将例子和墙的间距 ![(1-s-r_x)](https://private.codecogs.com/gif.latex?(1-s-r_x%29) 除以速度的 ![x](https://private.codecogs.com/gif.latex?x) 分量 ![(v_x)](https://private.codecogs.com/gif.latex?(v_x%29)，就可以得到粒子和墙的碰撞时间为 ![dt=(1-s-r_x)/v_x](https://private.codecogs.com/gif.latex?dt=(1-s-r_x%29/v_x) 个时间单位之后，此时粒子的位置将为 ![(1-s,r_y+v_ydt)](https://private.codecogs.com/gif.latex?(1-s,r_y+v_ydt%29)，除非它在之前又撞上了其他某个粒子或者墙，请见图 6.0.3。因此，我们就可以向优先队列中插入一个优先级为 ![t+dt](https://private.codecogs.com/gif.latex?t+dt) 的条目（以及一些描述该示例和墙的碰撞事件的信息）。墙体的碰撞预测计算都是类似的（请见练习 6.1）。两个粒子之间的碰撞也是类似的，但更加复杂一些。不过你会注意到这种计算得到的预测结果通常是**不会**碰撞（比如粒子正在向墙体的反方向移动，或者两个粒子的运动方向相反）——这种情况下就不需要向优先队列中插入任何东西。为了处理另一种典型情况，也就是预测到的碰撞距现在的时间太远时，就需要一个 limit 参数来指定有效的时间段，这样就可以忽略时间晚于 `limit` 发生的所有事件了。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.003.png)

**图 6.0.3　预测并解决粒子和墙体的一次碰撞**

####6.0.1.5　碰撞计算

当发生碰撞时，我们需要使用物理公式来进行计算，以描述一个粒子在和另一个粒子或者墙体发生弹性碰撞时的行为。在示例中，墙体遇到了一面竖墙。如果发生碰撞，粒子的速度将会从 ![(v_x,v_y)](https://private.codecogs.com/gif.latex?(v_x,v_y%29) 变为 ![(-v_x,v_y)](https://private.codecogs.com/gif.latex?(-v_x,v_y%29)，请见图 6.0.3。其他墙体的碰撞和它类似。两个粒子的碰撞也是类似的，但要更加复杂一些（请见练习 6.1）。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.004.png)

**图 6.0.4　预测并计算粒子之间的一次碰撞**

####6.0.1.6　排除无效事件。

预测的许多碰撞实际上都不会发生，因为它们被其他的碰撞打断了，请见图 6.0.7。为了处理这种情况，我们为每个粒子维护一个实例变量来记录和它有关的碰撞数量。当从优先队列中取出一个事件来处理时，我们会检查该事件所涉及粒子的碰撞计数器在事件被创建后是否已经更新。这是排除无效碰撞的**延时**方法：当某个粒子参与了一次碰撞时，我们不会删除优先队列中和该粒子有关的其他碰撞（尽管这些碰撞事件现在都已经无效了），而是会在之后遇到它们时直接将其忽略，请见图 6.0.6。另一种**即时**的方式是立刻从优先队列中删除所有与参与当前事件的粒子相关的其他事件，然后再计算这些粒子的新潜在碰撞事件。这种方式需要的优先队列更加复杂（需要实现**删除**操作）。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.005.png)

**图 6.0.5　可预测的事件**

以上讨论了一些预备知识，这些都是对按照物理定律进行弹性碰撞的运动粒子执行事件驱动模拟所必备的。相应的软件架构会将实现封装在 3 个类中：一个 `Particle` 数据类型，封装了所有和粒子有关的计算；一个 `Event` 数据类型来预测事件；一个它们的用例 `CollisionSystem` 类用来完成模拟。模拟的核心是一个含有所有事件的 `MinPQ` 优先队列，按照时间排序。下面看一下 `Particle`、`Event` 和 `CollisionSystem` 的实现。

![{35%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.006.png)

**图 6.0.6　可预测的不可能发生的事件**

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.007.png)

**图 6.0.7　一次失效的事件**

####6.0.1.7　粒子

练习 6.1 基于牛顿的运动学定律给出了粒子数据类型的实现要点。模拟用例应该能够移动粒子、画出粒子并进行若干和碰撞相关的计算，如表 6.0.1 中的 API 所示。

**表 6.0.1　运动的粒子对象的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class <b>Particle</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Particle()</code></td><td>在单位空间中创造一个新的随机粒子</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Particle(</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double rx, double ry,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double vx, double vy,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double s,</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double mass)</code></td><td>用给定的位置、速度、半径和质量创建一个粒子</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void draw()</code></td><td>画出粒子</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void move(double dt)</code></td><td>根据时间的流逝 <code>dt</code> 改变粒子的位置</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count()</code></td><td>该粒子所参与的碰撞总数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double timeToHit(Particle b)</code></td><td>距离该粒子和粒子 <code>b</code> 碰撞所需的时间</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double timeToHitHorizontalWall()</code></td><td>距离该粒子和水平的墙体碰撞所需的时间</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double timeToHitVerticalWall()</code></td><td>距离该粒子和垂直的墙体碰撞所需的时间</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double bounceOff(Particle b)</code></td><td>碰撞后该粒子的速度</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double bounceOffHorizontalWall()</code></td><td>碰撞水平墙体后该粒子的速度</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double bounceOffVerticalWall()</code></td><td>碰撞垂直墙体后该粒子的速度</td></tr>
</table>

当粒子不在碰撞轨道上时（这是很常见的），3 个 `timeToHit*()` 的方法都会返回 `Double.POSITIVE_INFINITY`。这些方法可以帮助预测给定粒子在未来的所有碰撞，将在 `limit` 时间内发生的碰撞事件插入优先队列。在处理两颗粒子相撞的事件时，使用 `bounceOff()` 方法计算两颗粒子在碰撞之后的速度。`bounceOff*()` 方法用于处理粒子和墙体之间的碰撞事件。

####6.0.1.8　事件

```
private class Event implements Comparable<Event>
{
   private final double time;
   private final Particle a, b;
   private final int countA, countB;

   public Event(double t, Particle a, Particle b)
   {  // 创造一个发生在时间t且与a和b相关的新事件
      this.time = t;
      this.a    = a;
      this.b    = b;
      if (a != null) countA = a.count(); else countA = -1;
      if (b != null) countB = b.count(); else countB = -1;
   }

   public int compareTo(Event that)
   {
      if      (this.time < that.time) return -1;
      else if (this.time > that.time) return +1;
      else return 0;
   }

   public boolean isValid()
   {
      if (a != null && a.count() != countA) return false;
      if (b != null && b.count() != countB) return false;
      return true;
   }
}
```

{-:-}粒子模拟的事件类

我们将应该放入优先队列中的所有对象信息封装在一个私有类之中（各种事件）。实例变量 `time` 记录的是事件的预计发生时间，实例变量 `a` 和 `b` 保存的是和该事件相关的粒子。这里有 3 种不同类型的事件：粒子和垂直墙体碰撞、粒子和水平墙体碰撞、粒子和粒子碰撞。为了平滑动态地显示运动中的粒子，我们添加了第 4 种类型的事件，即重绘事件。它的作用是将所有粒子在它们的当前位置画出。为了使 `Event` 的实现能够表示这 4 种类型的事件，允许粒子的值为空（`null`）：

* `a` 和 `b` 均不为空：粒子与粒子碰撞；
* `a` 非空而 `b` 为空：粒子 `a` 和垂直墙体的碰撞；
* `a` 为空而 `b` 非空：粒子 `b` 和水平墙体的碰撞；
* `a` 和 `b` 均为空：重绘事件（画出所有粒子）。

尽管没有完全遵循面向对象编程的原则，但这些约定能够得到简洁的用例代码。它的实现如上一页右下角的框注所示。

`Event` 类型实现中的第二个技巧是，它维护了两个实例变量 `countA` 和 `countB`，以记录**事件创建时**每个粒子所参与的碰撞事件数量。如果在将事件从优先队列中取出时该值没有发生变化，那么就可以继续模拟这个事件的发生。但如果在这个事件进入优先队列和离开优先队列的这段时间内任何计数器发生了变化，这个事件就失效了，那就可以忽略它。方法 `isValid()` 支持用例代码检查这种情况。

####6.0.1.9　模拟器代码

有了封装在 `Particle` 类和 `Event` 类中的运算，实际模拟所需的代码非常少，如 `CollisionSystem` 的实现所示（请见框注“基于事件模拟互相碰撞的粒子（框架）”和框注“基于事件模拟互相碰撞的粒子（主循环）”）。大多数运算都封装在右侧框注所示的 `predictCollision()` 方法中。这个方法会计算与粒子 `a` 有关的所有潜在碰撞（可能是和另一个粒子，也可能是和一面墙）并将相应的事件加入优先队列中。

```
private void predictCollisions(Particle a, double limit)
{
   if (a == null) return;
   for (int i = 0; i < particles.length; i++)
   {  // 将与particles[i]发生碰撞的事件插入pq中
      double dt = a.timeToHit(particles[i]);
      if (t + dt <= limit)
         pq.insert(new Event(t + dt, a, particles[i]));
   }
   double dtX = a.timeToHitVerticalWall();
   if (t + dtX <= limit)
      pq.insert(new Event(t + dtX, a, null));
   double dtY = a.timeToHitHorizontalWall();
   if (t + dtY <= limit)
      pq.insert(new Event(t + dtY, null, a));
}
```

{-:-}预测其他粒子的碰撞事件

模拟的核心是框注“基于事件模拟互相碰撞的粒子（主循环）”中的 `simulate()` 方法。我们会调用 `predictCollision()` 方法来初始化每个粒子，将所有粒子和墙体以及粒子和粒子之间的潜在碰撞加入优先队列中，然后进入事件驱动模拟的主循环，它的任务包括：

* 取出即将发生的事件（时间为 _**t**_ 的优先级最小的事件）；
* 如果事件无效，将它忽略；
* 按照直线运动轨迹使所有粒子运动到时间 _**t**_；
* 更新所有参与碰撞的粒子速度；
* 使用 `predictCollision()` 方法来预测参与碰撞的粒子在未来可能发生的碰撞，并向优先队列中插入相应的事件。

这个模拟过程可以作为计算系统中的各种有趣性质的基础，如练习所示。例如，我们所感兴趣的一种基本性质是所有粒子向墙体所施加的压力。计算这种压力的一种方法是记录墙体和粒子碰撞的次数和动量（根据粒子的质量和速度计算这个值很简单），这样就很容易得到它们的总量。温度性质的计算也是类似的。

>**基于事件模拟互相碰撞的粒子（框架）**

>```
>public class CollisionSystem
>{
>    private class Event implements Comparable<Event>
>    {  /* 请见正文 */  }
>
>    private MinPQ<Event> pq;        // 优先队列
>    private double t  = 0.0;        // 模拟时钟
>    private Particle[] particles;   // 粒子数组
>
>    public CollisionSystem(Particle[] particles)
>    {  this.particles  = particles;  }
>
>    private void predictCollisions(Particle a, double limit)
>    {  /* 请见正文 */  }
>
>    public void redraw(double limit, double Hz)
>    { // 重绘事件：重新画出所有粒子
>      StdDraw.clear();
>      for(int i = 0; i < particles.length; i++) particles[i].draw();
>      StdDraw.show(20);
>      if (t < limit)
>         pq.insert(new Event(t + 1.0 / Hz, null, null));
>    }
>
>    public void simulate(double limit, double Hz)
>    {  /* 请见后面的主循环代码*/  }
>
>    public static void main(String[] args)
>    {
>       StdDraw.show(0);
>       int N = Integer.parseInt(args[0]);
>       Particle[] particles = new Particle[N];
>
>       for (int i = 0; i < N; i++)
>          particles[i] = new Particle();
>       CollisionSystem system = new CollisionSystem(particles);
>       system.simulate(10000, 0.5);
>    }
>}
>```

>该类使用了优先队列来模拟粒子系统随着时间的运动。测试用例 `main()` 接受命令行参数 _**N**_，创造了 _**N**_ 个随机粒子并创建了含有所有粒子的 `CollisionSystem`，然后调用 `simulate()` 方法模拟系统的演化。其中的实例变量分别保存了模拟所需的优先队列、当前时间和所有粒子。

　

>**基于事件模拟互相碰撞的粒子（主循环）**

>```
>public void simulate(double limit, double Hz)
>{
>    pq = new MinPQ<Event>();
>    for (int i = 0; i < particles.length; i++)
>       predictCollisions(particles[i], limit);
>    pq.insert(new Event(0, null, null));  // 添加重绘事件
>    while (!pq.isEmpty())
>    {  // 处理一个事件
>       Event event = pq.delMin();
>       if (!event.isValid()) continue;
>       for (int i = 0; i < particles.length; i++)
>          particles[i].move(event.time - t); // 更新粒子的位置
>       t = event.time;                       // 和时间
>       Particle a = event.a, b = event.b;
>       if      (a != null && b != null) a.bounceOff(b);
>       else if (a != null && b == null) a.bounceOffVerticalWall();
>       else if (a == null && b != null) b.bounceOffHorizontalWall();
>       else if (a == null && b == null) redraw(limit, Hz);
>       predictCollisions(a, limit);
>       predictCollisions(b, limit);
>    }
>}
>```

>该方法是事件驱动模拟的主要部分。首先，我们用所有粒子预测的所有未来碰撞初始化优先队列。然后，主循环从队列中取出一个事件，更新时间和粒子的位置，并在处理碰撞后向队列中加入由此产生的所有新的潜在碰撞。

>![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.008.png)

####6.0.1.10　性能

如本小节的开头所述，我们对于事件驱动模拟的主要兴趣在于避免时间驱动模拟的内循环所必须的大量计算。

>**命题 A**。对 ![N](https://private.codecogs.com/gif.latex?N) 个能够相互碰撞的粒子系统，基于事件的模拟在初始化时最多需要 ![N^2](https://private.codecogs.com/gif.latex?N^2) 次优先队列操作，在碰撞时最多需要 ![N](https://private.codecogs.com/gif.latex?N) 次优先队列操作（且对于每个无效的事件都需要一次额外的操作）。证明。请见代码。

>**证明**。请见代码。

如果使用 2.4 节中优先队列的标准实现，我们能够保证优先队列的每次操作都是对数级别的，因此每次碰撞所需的时间是线性对数级别的。这样，才有可能模拟大量的粒子。

事件驱动模拟已经被应用于无数需要对运动中的物理对象建模的其他领域，例如分子学、天体物理学和机器人技术。这些应用可能会用其他实体，或是三维空间，或是其他作用力等许多种方法扩展这个模型。每种扩展都会为计算带来新的挑战。这种事件驱动的方式得到的模拟比其他方法更加健壮、准确和高效，而基于堆的优先队列的效率使不可能完成的计算成为了可能。

模拟在科学和工程的各个领域都是帮助研究者理解自然世界中各种性质的重要工具。它的应用从制造业、生物学、金融领域到复杂的工程结构，数不胜数。对于它们其中的一大部分应用，基于堆的优先队列数据类型或是高效的排序算法能够使模拟的质量和范围大有改观。

###6.0.2　B- 树

在第 3 章中我们已经看到，能够快速访问大量数据中的特定元素的算法对于实际应用有着重要意义。例如在巨型数据集中，查找是一项非常重要的操作，该操作在许多计算场景中会消耗掉大部分资源。随着互联网的进步，某项任务访问到的信息可能非常庞大——我们的挑战在于在其中进行有效地查找。在本小节中，我们将介绍一种 3.3 节的平衡树算法的扩展。它支持对保存在磁盘或者网络上的符号表进行**外部查找**，这些文件可能比我们以前考虑的输入要大的多（以前的输入能够保存在内存中）。现代软件系统正在淡化本地文件和网页之间的区别，这些内容也可能保存在一台远程计算机上，因此我们可以找到的信息实际上近似于无限。令人惊讶的是，我们将要学习的算法只需使用 4 ～ 5 个指向一小块数据的引用即可有效支持在含有数百亿或者更多元素的符号表中进行查找和插入操作。

####6.0.2.1　成本模型

数据存储的机制多种多样且在不断发展，因此我们将使用一个能够抓住本质的简单模型。这里用**页**表示一块连续的数据，用**探查**表示访问一个页。假设访问一页需要将它的内容读入本地内存，因此之后的访问就可以相对高效。一个页可能是本地计算机上的一个文件，也可能是远程计算机上的一张网页，也可能是服务器上的某个文件的一部分，等等。我们的目标是实现能够仅用极少次数的探查即可找到任意给定键的查找算法。我们不想假设页的具体大小或者一次探查（对于远程设备显然需要通信）所需时间与随后访问块中内容（显然这发生在本地处理器上）所需时间的比例。在一般情况下，这些值的数量级可能是 100、1000 或者 10 000。我们不需要更精确的值，因为在我们感兴趣的范围内，算法对这些值的不同并不非常敏感。

>**B- 树的成本模型**。我们使用**页的访问**次数（无论读写）作为外部查找算法的成本模型。

####6.0.2.2　B- 树

它是对 3.3 节所述的 2-3 树数据结构的扩展。关键的不同在于：我们不会将数据保存在树中，而是会构造一棵由键的**副本**组成的树，每个副本都关联着一条链接。这种方式能够更加方便地将索引和符号表本身分开，就像一本实体书中的索引一样。和 2-3 树一样，我们限制了每个结点中能够含有的“键—链接”对的上下数量界限：选择一个参数 _**M**_（一般都是一个偶数）并构造一棵多向树，每个结点最多含有 _**M**_-1 对键和链接（假设 _**M**_ 足够小，使得每个 _**M**_ 向结点都能够存放在一个页中），**最少**含有 _**M**_/2 对键和链接（以提供足够多的分支来保证查找路径较短）。根结点是个例外，它可以含有少于 _**M**_/2 对键和链接，但也不能少于 2 对。这种树被 Bayer 和 McCreight 在 1970 年命名为 B- 树。他们是最早使用多向平衡树进行外部查找的研究者。有些人也用 **B- 树**这个术语来描述 Bayer 和 McCreight 发明的算法所构造的数据结构。本节用它泛指所有基于固定页大小的多向平衡查找树的数据结构。我们用 _**M**_ **阶的 B**- **树**来指定 _**M**_ 的值。在一棵 4 阶 B- 树中，每个结点都含有至少 2 对至多 3 对键 - 链接；在一棵 6 阶 B- 树中（请见图 6.0.8），每个结点都至少含有 3 对至多 5 对键 - 链接（根结点除外，它可以只含有 2 对键与链接），等等。对于较大的 _**M**_ 根结点是个例外的原因，在学习构造算法的细节时你就会明白了。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.009.png)

**图 6.0.8　详解用一棵 B-树表示的键集 ![(M=6)](https://private.codecogs.com/gif.latex?(M=6%29)**

####6.0.2.3　约定

为了说明基本的流程，我们先讨论（有序）（集合）`SET` 的一个实现（只有键没有值）。将它扩展得到一个能够将键和值相关联的符号表实现是一个很好的练习（请见练习 6.16）。我们的目标是为一个巨大的键集实现 `add()` 和 `contains()` 方法。使用有序集的原因是我们希望将查找树推广，而这依赖于键的有序性。扩展实现来支持其他有序性操作也是十分有益的练习。外部查找的应用常常会将索引和数据隔离。对于 B- 树，我们通过使用以下两种不同类型的结点做到这一点。

* **内部**结点：含有与页相关联的键的副本。
* **外部**结点：含有指向实际数据的引用。

内部结点中的每个键都与一个结点相关联，以此结点为根的子树中，所有的键都**大于等于**与此结点关联的键，但**小于**原内部结点中更大的键（如果存在的话）。为了方便这里使用了一个特殊的**哨兵键**，它小于其他所有键。一开始 B- 树只含有一个根节点，而根结点在初始化时仅含有该哨兵键。符号表不含有重复键，但我们会（在内部结点中）使用键的多个副本来引导查找。（在示例中，所有键都是单个字母并使用小于所有字母的“*”作为哨兵键。）这些约定能够一定程度上简化代码，并且说明了另一种在内部结点中将所有数据和链接混合的便利（而且是广泛使用的）方式，就像其他查找树一样。

####6.0.2.4　查找和插入

B- 树中查找的基础是在可能含有被查找键的唯一子树中进行递归搜索。当且仅当被查找的键包含在集合中时，每次查找便会结束于一个外部结点。在内部结点中遇到被查找的键的副本时就判断**查找命中**并结束，但总会找到相应的外部结点，因为这么做可以简化将 B- 树扩展为有序符号表的实现（当 _**M**_ 很大时这种情况很少出现）。举一个具体的例子：假设有一棵 6 阶 B- 树，该树由多个含有 3 对键 - 链接的 3- 结点、含有 4 对键 - 链接的 4- 结点和含有 5 对键 - 链接的 5- 结点以及一个 2- 根结点组成，请见图 6.0.9。在查找时，从根结点开始，根据被查找的键选择当前结点中的适当区间并根据适当的链接从一个结点移动到下一个结点。最终，查找过程会到达树底的一个含有键的页。如果被查找的键在该页中，查找命中并结束；如果不在，则查找未命中。和 2-3 树一样，要在树的底部插入一个新键，可以使用递归代码。如果空间不足，那么可以允许被插入的结点暂时“溢出”（变成一个 6- 结点），并在递归调用后向上不断分裂 6- 结点。如果根结点也变成了 6- 结点，则可以将它分裂成连接了两个 3- 结点的 2- 结点；对于树的其他位置，我们将 6- 结点的父 ![k-](https://private.codecogs.com/gif.latex?k-) 结点变为连接着两个 3- 结点的 ![(k+1)-](https://private.codecogs.com/gif.latex?(k+1%29-) 结点。将上文中的 3 替换成 ![M/2](https://private.codecogs.com/gif.latex?M/2)，6 替换成 ![M](https://private.codecogs.com/gif.latex?M)，即可得到 ![M](https://private.codecogs.com/gif.latex?M) 阶 B- 树中的查找和插入操作的方法，请见图 6.0.10。定义如下所示。

>**定义**。一棵 ![M](https://private.codecogs.com/gif.latex?M) 阶 B- 树（![M](https://private.codecogs.com/gif.latex?M) 为正偶数）或者仅是一个外部 ![k-](https://private.codecogs.com/gif.latex?k-) 结点（含有 ![k](https://private.codecogs.com/gif.latex?k) 个键和相关信息的树），或者由若干内部 ![k-](https://private.codecogs.com/gif.latex?k-) 结点（每个结点都含有 ![k](https://private.codecogs.com/gif.latex?k) 个键和 ![k](https://private.codecogs.com/gif.latex?k) 条链接，链接指向的子树表示了键之间的间隔区域）组成。它的结构性质如下：从根结点到每个外部结点的路径长度均相同（完美平衡）；对于根结点，![k](https://private.codecogs.com/gif.latex?k) 在 2 到 ![M-1](https://private.codecogs.com/gif.latex?M-1) 之间，对于其他结点 ![k](https://private.codecogs.com/gif.latex?k) 在 ![M/2](https://private.codecogs.com/gif.latex?M/2) 到 ![M-1](https://private.codecogs.com/gif.latex?M-1) 之间。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.010.png)

**图 6.0.9　在由 B- 树表示的键集中进行查找 ![(M=6)](https://private.codecogs.com/gif.latex?(M=6%29)**

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.011.png)

**图 6.0.10　向由 B- 树表示的键集中插入一个新键**

####6.0.2.5　数据表示

按照刚才的讨论，我们在选择 B- 树结点的表示方法上有很大的自由度。我们将这些选择封装在一个 `Page` API 中（请见表 6.0.2）。它可以关联键与指向 `Page` 对象的链接，支持检测页是否溢出、分裂页并区分内部页和外部页的操作。你可以将 `Page` 看作一张符号表，但是是保存在外部介质上的（本地或是网络上的文件）。API 中的术语“**打开**”（open）和“**关闭**”（close）指的是将外部页读入内存和将内存内容写回外部页（如果需要的话）的过程。内部页的 `add()` 方法是一个符号表操作，会将给定页和以该页为根结点的子树中的最小键关联起来。外部页的 `add()` 和 `contains()` 方法和 `SET` 中相应的方法类似。在所有实现中，最重要的方法都是 `split()`。在分裂一张饱和页时，`split()` 方法会将排序后位置正好大于（或等于）![M/2](https://private.codecogs.com/gif.latex?M/2) 的键移动到一个新的 `Page` 对象中，并返回该对象的引用。练习 6.15 讨论了使用 `BinarySearchST` 对 `Page` 的一种实现。这种方法将 B—树实现在了内存中，和其他查找树的实现一样。在某些系统中，这种外部查找的实现可能已经足够了，因为虚拟内存系统会处理磁盘访问。更加贴近实际的实现可能包含与硬件相关的代码来读取和写入页的内容。练习 6.19 会鼓励你实现 `Page` 用于网页。这里不会讨论这些细节，而强调的重点是 B—树的概念能够广泛用于各种场景之中。

###6.0.2　B- 树的页的 API

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;public class <b>Page&lt;Key></b></code>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Page(boolean bottom)</code></td><td>创建并打开一个页</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void close()</code></td><td>关闭页</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void add(Key key)</code></td><td>将键插入（外部的）页中</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void add(Page p)</code></td><td>打开 <code>p</code>，向这个（内部）页中插入一个条目并将 <code>p</code> 和 <code>p</code> 中的最小键相关联</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean isExternal()</code></td><td>这是一个外部页吗</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean contains(Key key)</code></td><td>键 <code>key</code> 在页中吗</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Page next(Key key)</code></td><td>可能含有键 <code>key</code> 的子树</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean isFull()</code></td><td>页是否已经溢出</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Page split()</code></td><td>将较大的中间键移动到一个新页中</td></tr>
<tr><td><code>Iterable&lt;Key> keys()</code></td><td>页中所有键的迭代器</td></tr>
</table>

在这些准备之后，后面框注“B- 树集合的实现”的 `BTreeSET` 就很简单了。它用递归实现了 `contains()` 方法，接受一个 `Page` 对象作为参数并处理了以下 3 种情况。

* 如果当前页是外部页且键在该页中，返回 `true`。
* 如果当前页是外部页且键不在该页中，返回 `false`。
* 否则，递归地在可能含有该键的子树中查找。

我们用相同的递归结构实现了 `add()` 方法，只是在没有找到该键的时候将它插入到了树底部的页中，然后分裂回溯过程中所遇到的所有饱和结点，请见图 6.0.11。

####6.0.2.6　性能

B- 树最重要的性质就是，在实际应用中对于适当的参数 ![M](https://private.codecogs.com/gif.latex?M)，查找的成本是常数级别的。

>**命题 B**。含有 ![N](https://private.codecogs.com/gif.latex?N) 个元素的 ![M](https://private.codecogs.com/gif.latex?M) 阶 B- 树中的一次查找或插入操作需要 ![\log_MN\sim\log_{M/2}N](https://private.codecogs.com/gif.latex?\log_MN\sim\log_{M/2}N) 次探查——在实际情况下这基本是一个常数。

>**证明**。因为树中的所有内部结点（非根结点也非外部结点的所有结点）的形成都是由含有 ![M](https://private.codecogs.com/gif.latex?M) 个键的饱和结点分裂得到的且大小只可能增长（当它的子结点分裂时），所以其中的链接数总是在 ![M/2](https://private.codecogs.com/gif.latex?M/2) 到 ![M-1](https://private.codecogs.com/gif.latex?M-1) 之间。在最好的情况下，这些结点能够形成一棵 ![M-1](https://private.codecogs.com/gif.latex?M-1) 向的完全树，由此马上就可以得到命题中所述的上下界。在最坏情况下，根结点只含有两个链接并分别指向两棵 ![M/2](https://private.codecogs.com/gif.latex?M/2) 向的完全树。将对数的底设为 ![M](https://private.codecogs.com/gif.latex?M) 可以得到一个非常小的数——例如，当 ![M](https://private.codecogs.com/gif.latex?M) 为 1000 且 ![N](https://private.codecogs.com/gif.latex?N) 小于 625 亿时，树的高度小于 4。

在一般情况下，我们可以将根结点保存在内存中，这样可以将探查次数减 1。在磁盘和网络中进行查找时，应该在开始大量查找前显示地完成这一步。在带有缓存的虚拟内存中，应该将根结点放在最快的缓存中，因为它是访问最频繁的结点。

####6.0.2.7　空间需求

在实际应用中，我们对 B- 树使用的空间也很感兴趣。由页的构造可知，它们至少都是半满的。在最坏的情况下，B- 树所需的空间是所有键占用的实际空间的两倍再加上链接所需的空间。对于随机键，A.Yao 在 1979 年（使用超出了本书范围的数学方法）证明了结点中平均含有 ![M\ln2](https://private.codecogs.com/gif.latex?M\ln2) 个键，因此浪费的空间约占 44%。和其他查找算法一样，这个随机模型也很好地预测了在实际应用中所观察到的键的分布。

>**算法 6.1　B- 树集合的实现**

>```
>public class BTreeSET<Key extends Comparable<Key>>
>{
>    private Page root = new Page(true);
>
>    public BTreeSET(Key sentinel)
>    {  add(sentinel);  }
>
>    public boolean contains(Key key)
>    {  return contains(root, key);  }
>
>    private boolean contains(Page h, Key key)
>    {
>       if (h.isExternal()) return h.contains(key);
>       return contains(h.next(key), key);
>    }
>
>    public void add(Key key)
>    {
>       add (root, key);
>       if (root.isFull())
>       {
>          Page lefthalf = root;
>          Page righthalf = root.split();
>          root = new Page(false);
>          root.add(lefthalf);
>          root.add(righthalf);
>       }
>    }
>
>    public void add(Page h, Key key)
>    {
>       if (h.isExternal()) {  h.add(key); return;  }
>
>       Page next = h.next(key);
>       add(next, key);
>       if (next.isFull())
>          h.add(next.split());
>       next.close();
>    }
>}
>```

>如正文所述，这段代码实现了多向平衡查找树（B- 树）。它在查找时使用了 `Page` 数据类型来将键和可能含有该键的子树相关联，并通过检测键的溢出和分裂结点的方法完成了插入操作，请见图 6.0.11。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.012.png)

**图 6.0.11　构造一棵庞大的 B- 树**

命题 B 的影响之巨大，值得我们思考。你会猜到某种查找算法只需 4 ～ 5 次访问即可搜索你能够想象的最大文件吗？B- 树的应用十分广泛，就是因为它能够实现这一点。在实践中，主要的挑战是在实现时尽量保证 B- 树中结点所需的空间，但随着大部分设备上的存储空间的增长，这已经不算什么问题了。

基本 B- 树抽象的许多变种都很容易理解。一类变化是尽可能在内部结点中保存更多的页引用以节省时间，这样可以使分支增多并将树更加扁平化。另一类变化是在分裂前将兄弟结点合并以提高存储的使用效率。对算法的变种以及参数的选择应该适应于具体的设备和应用。尽管提高的效率也仅限于常数因子的范围之内，但对于巨型符号表或是大量事物处理需求来说，这样的改进也有着重要的意义，这也是为什么 B- 树如此高效的原因。

###6.0.3　后缀数组

字符串处理的高效算法在科学计算和商业应用中都有着重要的地位。从搜索互联网文本信息到科学家为了揭开生命的秘密而努力研究的庞大基因数据库，21 世纪中基于字符串的计算机应用在大规模增长。和以前一样，许多经典的算法都十分有效，但人们也发明了一些很好的新算法。下面，我们将介绍能够支持这些算法的一种数据结构和一份 API。首先，我们来看一个典型的（而且是经典的）字符串处理问题。

####6.0.3.1　最长重复子字符串

在给定的字符串中，至少出现了两次的最长子字符串是什么？例如，在字符串 `"to be or not to be"` 中，最长重复子字符串就是 `"to be"`。你觉得应该怎样解决这个问题呢？你能在长度为数百万个字符的字符串中找出它的最长重复子字符串吗？这个问题的说明很简单，应用也很多，包括数据压缩、密码学和计算机辅助音乐分析等。例如，开发大型软件系统中的一种常见技术叫做**代码重构**。程序员经常会通过复制粘贴代码从原有的程序生成新的程序。对于开发了很长时间的一大段程序，将不断重复出现的代码转化为函数调用能够使程序更加容易理解和维护。我们可以通过在程序中寻找最长重复子字符串做到这一点。这个问题的另一个应用是计算生物学。在给定的基因中存在大量相同的片段吗？同样，这个问题背后的本质也是找出字符串中的最长重复子字符串。科学家一般更关心细节（事实上，重复子字符串的意义正是科学家所希望理解的），但这个问题显然比寻找简单的最长重复子字符串更难以回答。

####6.0.3.2　暴力解法

```
private static int lcp(String s, String t)
{
   int N = Math.min(s.length(), t.length());
   for (int i = 0; i < N; i++)
      if (s.charAt(i) != t.charAt(i)) return i;
   return N;
}
```

{-:-}两个字符串的最长公共前缀

作为热身，考虑以下这个简单的任务：给定两个字符串，找到它们的最长公共**前缀**（两者的前缀字符串中的相同且最长者）。例如，`acctgttaac` 和 `accgttaa` 的最长公共前缀是 `acc`。右边框注中的代码是我们解决更加复杂问题的起点：它所需的时间和相匹配的子字符串长度成正比。现在，我们应该如何在给定的字符串中找到最长重复子字符串呢？根据 `lcp()`，马上可以得到下面这种暴力解法：将字符串中每个起始位置为 `i` 的子字符串与另一个起始位置为 `j` 的子字符串相比较，记录匹配的最长子字符串。这段代码不适合处理长字符串，因为它的运行时间至少是字符串长度的**平方**级别：不同的子字符串对 `i` 和 `j` 的数量为 ![N(N-1)/2](https://private.codecogs.com/gif.latex?N(N-1%29/2)，因此这种方式调用 `lcp()` 的次数将会是 ![\sim N^2/2](https://private.codecogs.com/gif.latex?\sim%20N^2/2)。用这种方法处理含有上百万个字符的碱基对序列将会调用几百亿次 `lcp()`，显然这是不可行的。

####6.0.3.3　后缀排序

下面这种巧妙的方法用一种出人意料的方式利用排序算法高效地找出了字符串中的最长重复子字符串：用 Java 的 `substring()` 方法创建一个由字符串 `s` 的所有后缀字符串（由字符串的所有位置开始得到的后缀字符串）组成的数组，然后将该数组排序，请见图 6.0.12。算法的关键在于原字符串的每个子字符串都是数组中的某个后缀字符串的前缀。在排序之后，最长重复子字符串会出现在数组中的相邻位置。因此，只需要遍历排序后的数组一遍即可在相邻元素中找到最长的公共前缀。这种方法比暴力方法有效得多。但在实现和分析它之前，我们先介绍后缀排序的另一种应用。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.013.png)

**图 6.0.12　使用后缀排序计算最长重复子字符串**

####6.0.3.4　定位字符串

当需要在大量文本中寻找某个特定的子字符串时（例如，当你在使用文本编辑器或是在浏览网页时），你就是在进行一次**子字符串查找**，即 5.3 节中讨论过的问题。对于这个问题，我们假设文本比要查找的字符串庞大得多，并将注意力集中在查找字符串的预处理上，以保证能够在任意给定的文本中高效的找到该子字符串。当在浏览器中输入要查找的关键字时，就是在进行一次**字符串键查找**，即 5.2 节的主题。搜索引擎必然已经预先计算得到了一张索引表，因为它不可能即时地根据输入的关键字扫描互联网中的所有页面。根据 3.5 节的讨论（请见 3.5.4 节框注“文件索引”的 `FileIndex`），理想情况下最好有一张反向索引符号表将每个被查找的字符串和所有含有它的网页关联起来——在符号表的每个条目中，键即为被查找的字符串，而值则为一组指针，请见图 6.0.13（每个指针都含有能够定位该键在互联网上具体位置所需的信息——这可以是一个网页的 URL 加上键的出现位置的偏移量。）在实际应用中，这样的符号表会非常非常大，因此搜索引擎会使用各种复杂的算法来缩小它的体积。一种方法是将网页按照重要程度排序（可以使用 3.5.5 节讨论的 `PageRank` 算法）并只选择排序等级较高的网页而非全部网页。另一种减小符号表大小的方法是将多个**关键词**（以空格分隔）作为预处理得到的索引表的键并和 URL 关联。那么，当你查找一个关键词时，搜索引擎可以通过索引找到含有被查找的键（即关键词）的（相对重要的）网页，并在该页面中使用字符串查找来定位关键词。使用这种方法时，如果文本含有的是“`everything`”而你要找的是“thing”，那可能会找不到。对于某些应用，构造一个能够帮助我们找出文本中的**任意子字符串**的索引是**值得**的。这么做可能是为了对一本非常重要的文学作品进行语言学研究，或是为了找出可能成为许多科学家研究对象的某段碱基对序列，或者找出访问量很大的网页。同样，在理想情况下，索引表应该将文本字符串的所有子字符串分别和它们的出现位置关联起来，如图 6.0.14 所示。这种方法的问题显然是子字符串的总数太大，在符号表中为每个子字符串创建一个条目不现实。（一段含有 ![N](https://private.codecogs.com/gif.latex?N) 个字符的文本含有 ![N(N+1)/2](https://private.codecogs.com/gif.latex?N(N+1%29/2) 个子字符串。）图 6.0.14 中的符号表需要含有 b、be、bes、best、best o、best of、e、es、est、est o、est of、s、st、st o、st of、t、t o、t of、o、of 和许许多多其他子字符串的条目。这次我们也可以用后缀排序的方法解决这个问题，就像 3.1 节中用二分查找对符号表的第一次实现一样。我们可以将 ![N](https://private.codecogs.com/gif.latex?N) 个后缀作为键，以这些键（后缀）创建一个有序的数组并使用二分查找法搜索数组，比较被查找的键和所有后缀，请见图 6.0.15。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.014.png)

**图 6.0.13　理想化的一次典型的网络搜索**

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.015.png)

**图 6.0.14　理想化的一张文本字符串索引表**

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.016.png)

**图 6.0.15　后缀数组中的二分查找**

####6.0.3.5　API 及其用例

为了解决这两个问题，我们给出了以下 API。它含有构造函数、`length()` 方法，`select()` 和 `index()` 方法分别给出了有序后缀数组中给定位置的后缀和它的索引值，`lcp()` 方法会返回每个后缀和它在数组中的前一个后缀的最长公共前缀，`rank()` 方法能够给出小于给定键的后缀数量。（自从第 1 章中第一次学习二分查找后就一直在使用它。）我们用**后缀数组**表示有序后缀字符串列表的这种抽象数据结构，但实际使用的并不一定是字符串数组，如表 6.0.3 所示。

**表 6.0.3　后缀数组的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class <b>SuffixArray</b></code>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SuffixArray(String text)</code></td><td>为文本 <code>text</code> 构造后缀数组</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int length()</code></td><td>文本 <code>text</code> 的长度</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String select(int i)</code></td><td>后缀数组中的第 <code>i</code> 个元素（<code>i</code> 在 0 到 <img src="https://private.codecogs.com/gif.latex?N-1" /> 之间）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index(int i)</code></td><td><code>select(i)</code> 的索引（<code>i</code> 在 0 到 <img src="https://private.codecogs.com/gif.latex?N-1" /> 之间）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int lcp(int i)</code></td><td><code>select(i)</code> 和 <code>select(i-1)</code> 的最长公共前缀的长度（<code>i</code> 在 1 到 <img src="https://private.codecogs.com/gif.latex?N-1" /> 之间）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rank(String key)</code></td><td>小于键 <code>key</code> 的后缀数量</td></tr>
</table>

在图 6.0.15 所示的例子中，`select(9)` 的结果是“`as the best of times...`”、`index(9)` 的值是 4、`lcp(20)` 的值是 10（因为“`it was the best of times...`”和“`it was the`”的公共前缀“`it was the`”的长度为 10）、`rank("th")` 的值是 30。注意，`select(rank(key))` 是有序后缀数组中第一个以 `key` 为前缀的后缀字符串，键 `key` 在正文中出现的其他位置都在后缀数组中紧跟着该条目（请见图 6.0.15）。使用这份 API 可以立即写出框注中的代码。`LRS` 类（见本页框注）会为标准输入得到的文本构造后缀数组，并根据扫描数组所得的最大 `lcp()` 值找出文本中的最长重复子字符串。`KWIC` 类（见下页框注）会为命令行参数指定的文本构造后缀数组，从标准输入接受查询并打印出被查询的子字符串在文本中的上下文（该字符串的前后若干个字符）。`KWIC` 这个名字表示的是**上下文中的关键词**（keyword-in-context）查找，最早出现在 20 世纪 60 年代。这些典型的字符串处理应用代码的简洁和高效令人赞叹。这也说明了精心设计 API 的重要性（以及简单而巧妙的思想的影响力）。

```
public class LRS
{
   public static void main(String[] args)
   {
      String text = StdIn.readAll();
      int N = text.length();
      SuffixArray sa = new SuffixArray(text);
      String lrs = "";
      for (int i = 1; i < N; i++)
      {
         int length = sa.lcp(i);
         if (length > lrs.length())
            lrs = sa.select(i).substring(0, length);
      }
      StdOut.println(lrs);
   }
}
```

{-:-}最长重复子字符串算法的用例

```
% more tinyTale.txt
it was the best of times it was the worst of times
it was the age of wisdom it was the age of foolishness
it was the epoch of belief it was the epoch of incredulity
it was the season of light it was the season of darkness
it was the spring of hope it was the winter of despair

% java LRS < tinyTale.txt
st of times it was the
```

　

```
public class KWIC
{
   public static void main(String[] args)
   {
      In in = new In(args[0]);
      int context = Integer.parseInt(args[1]);

      String text = in.readAll().replaceAll("\\s+", " ");;
      int N = text.length();
      SuffixArray sa = new SuffixArray(text);

      while (StdIn.hasNextLine())
      {
         String q = StdIn.readLine();
         for (int i = sa.rank(q); i < N && sa.select(i).startsWith(q); i++)
         {
            int from = Math.max(0, sa.index(i) - context);
            int to   = Math.min(N-1, from + q.length() + 2*context);
            StdOut.println(text.substring(from, to));
         }
         StdOut.println();
      }
   }
}
```

{-:-}上下文中的关键词的索引用例

```
% java KWIC tale.txt 15
search
o st giless to search for contraband
her unavailing search for your fathe
le and gone in search of her husband
t provinces in search of impoverishe
 dispersing in search of other carri
n that bed and search the straw hold


better thing
t is a far far better thing that i do than
 some sense of better things else forgotte
was capable of better things mr carton ent
```

####6.0.3.6　实现

算法 6.2 中的代码简洁明了地实现了 `SuffixArry` 的 API。它的实例变量包括一个字符串数组和（为了节省代码）一个表示数组长度的的变量 ![N](https://private.codecogs.com/gif.latex?N)（既是字符串的长度也是它的后缀字符串数量）。类的构造函数会构造后缀数组并将它排序，因此 `select(i)` 只需返回 `suffixes[i]` 即可。`index()` 的实现也只要一行代码，但稍微复杂一点，因为**后缀字符串的长度就说明了它的起始位置**。长度为 <code><i>N</i></code> 的后缀字符串的起始位置为 0，长度为 ![N-1](https://private.codecogs.com/gif.latex?N-1) 的后缀字符串的起始位置为 1，长度为 ![N-2](https://private.codecogs.com/gif.latex?N-2) 的后缀字符串的起始位置为 2，依此类推。因此 `index(i)` 的返回值即为 ![N-](https://private.codecogs.com/gif.latex?N-)`suffixes[i].length()`。由 6.0.3.2 节中的静态 `lcp()` 方法可以很容易得到这里的 `lcp()` 方法的实现，`rank()` 方法与 3.1.5 节“算法 3.2（续 1）”中基于二分查找的符号表的实现也基本相同。同样，实现的简洁与优雅并不能掩盖这是一种复杂的算法，它解决了如最长重复子字符串这种其他方法无法解决的重要问题。

####6.0.3.7　性能

后缀排序算法的效率取决于 Java 的子字符串提取操作使用的内存空间，它是一个常数——每个子字符串都是由标准对象、指向原字符串的指针和它的长度组成的。因此，索引的大小和字符串的长度是线性关系。这让人有些意外，因为所有子字符串中的字符总数为 ![\sim N^2/2](https://private.codecogs.com/gif.latex?\sim%20N^2/2)，即字符串长度的平方级别。另外，这种平方级别的性能也会大大影响子字符串数组的排序成本。我们要记住的重要一点是，这种方法对长字符串有效的原因在于 Java 的字符串表示方法：当交换两个字符串时，实际交换的仅仅是对它们的引用，而非字符串本身。虽然当两个字符串有很长的公共前缀时**比较**它们的成本与它们的长度成正比，但在一般的应用场景下，大多数比较都只需要检查几个字符。如果是这样的话，后缀数组的排序时间就是线性对数的。例如，在许多应用中，随机字符串模型都是合理的。

>**命题 C**。使用三向字符串快速排序，构造长度为 ![N](https://private.codecogs.com/gif.latex?N) 的随机字符串的后缀数组，平均所需的空间与 ![N](https://private.codecogs.com/gif.latex?N) 成正比，字符比较次数与 ![\sim2N\ln N](https://private.codecogs.com/gif.latex?\sim2N\ln%20N) 成正比。

>**讨论**。后缀数组的空间需求很明显，但它所需的时间来自于 P.Jaquet 和 W.Szpankowski 的一份艰深而复杂的研究成果。他们证明了将所有后缀排序的成本渐进于将 ![N](https://private.codecogs.com/gif.latex?N) 个随机字符串排序的成本（请见 5.1.4.4 节中的命题 E）。

　

>**算法 6.2　后缀数组（初级实现）**

>```
>public class SuffixArray
>{
>    private final String[] suffixes;  // 后缀数组
>    private final int N;              // 字符串（和数组）的长度
>
>    public SuffixArray(String s)
>    {
>       N = s.length();
>       suffixes = new String[N];
>       for (int i = 0; i < N; i++)
>          suffixes[i] = s.substring(i);
>       Quick3way.sort(suffixes);
>    }
>
>    public int length()         { return N; }
>    public String select(int i) { return suffixes[i]; }
>    public int index(int i)     { return N - suffixes[i].length(); }
>    private static int lcp(string s,string t)
>
>    // 请见6.0.3.2节框注“两个字符串的最长公共前缀”
>    public int lcp(int i)
>    {  return lcp(suffixes[i], suffixes[i-1]); }
>    public int rank(String key)
>    {  // 二分查找
>       int lo = 0, hi = N - 1;
>       while (lo <= hi)
>       {
>          int mid = lo + (hi - lo) / 2;
>          int cmp = key.compareTo(suffixes[mid]);
>          if      (cmp < 0) hi = mid - 1;
>          else if (cmp > 0) lo = mid + 1;
>          else return mid;
>       }
>       return lo;
>    }
>
>}
>```

>`SuffixArray API` 的实现效率取决于 Java 的 `String` 类的不可改变性，这种性质使得子字符串实际上都是引用，提取子字符串只需常数时间（请见正文）。

####6.0.3.8　改进的实现

`SuffixArray` 的初级实现在最坏情况下的性能很糟。例如，如果所有的字符都相同，后缀数组的排序会检查每个后缀字符串中的每个字符，所需的时间为**平方**级别。对于我们用作示例的碱基对序列字符串或是自然语言的文本字符串，这可能不是问题，但算法对于含有一大串相同字符的文本可能会很慢。此外，查找最长重复子字符串所需的时间可能会是**子字符串长度的平方级别**，因为重复的子字符串的所有前缀都会被检查（请见图 6.0.16）。对于《双城记》来说这不是问题，因为其中最长的重复子字符串为：

	"s dropped because it would have been a bad thing for me in a worldly point of view i"

只有 84 个字符。然而，对于经常含有很长的重复部分的碱基对序列来说，这就是一个严重的问题了。如何避免查找重复子字符串时出现的这种平方级别运算呢？幸运的是，P.Weiner 在 1973 年的研究显示**我们可以保证在线性时间内解决最长重复子字符串问题**。Weiner 算法的基础是构造一棵后缀字符串树（即一棵由所有后缀字符串组成的字典查找树）。如果在每个字符处使用多个链接，后缀树在解决许多实际问题时会消耗非常大的空间，这又推动了后缀数组的发展。在 20 世纪 90 年代，U.Manber 和 E.Myers 演示了一种构造后缀数组的线性对数级别的算法，以及一个同时完成预处理和对后缀数组排序以支持**常数时间**的 `lcp()` 方法。之后人们又发明了若干线性时间的后缀排序算法。经过一些改造，Manber-Myers 算法的实现也能够支持两个参数的 `lcp()` 方法，以在常数时间内找出给定的但不一定是相邻的两个后缀之间的最长公共前缀。这也是对初级实现的一项重大改进。这些结果非常令人惊讶，因为它们所达到的效率远远超出了人们的预期。

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.017.png)

**图 6.0.16　查找最长重复子字符串的成本是重复子字符串长度的平方级别**

>**命题 D**。使用后缀数组，我们可以在线性时间内解决后缀排序和最长重复子字符串问题。

>**证明**。解决这些问题的优美算法已经超出了本书的范畴，但你在本书的网站上可以找到线性时间的 `SuffixArray` 的构造函数和常数时间的 `lcp()` 方法的实现。

基于这些思想的 `SuffixArray` 实现足以高效解决许多字符串处理问题，而且用例代码非常简单，如我们的 `LRS` 和 `KWIC` 例子所示。

后缀数组是自 20 世纪 60 年代解决 `KWIC` 索引的单词查找树以来数十年研究积累的成果。我们讨论的很多种算法都是许多研究者在几十年的实践中发明的，这些问题包括将《牛津英语大词典》搬上互联网、第一代搜索引擎以及人类基因组测序，等等。这完全说明了算法的设计和分析的重要性。

###6.0.4　网络流算法

下面我们将讨论一种图的模型，它的成功之处不仅在于为我们提供了能够轻松描述解决实际问题的模型，而且使用这些模型我们能得到许多高效的算法来解决问题。我们将要讨论的解决方案说明了两种特定需求之间的矛盾，即具有广泛适用性的需求与能够解决特殊问题的需求。网络流算法研究的迷人之处在于它紧凑优雅的实现几乎能够同时达到这两个目标。你将会看到，我们的实现非常易懂而且能够保证运行时间与网络大小成正比。

网络流问题的经典解决方案和第 4 章中介绍的那些图算法紧密相关。基于已有的工具，我们可以编写非常精炼的程序来解决它们。我们已经在许多问题中看到，良好的算法和数据结构能够大幅减少解决问题所需的时间。人们还在积极研究该领域中更好的算法和数据结构并不断地发明新的方法。

####6.0.4.1　物理模型

首先用一个理想化的物理模型来介绍几个直观的概念。请想象一组相互连接大小不一的输油管道，在连接处装有能够控制原油流向的开关，如图 6.0.17 所示。

![{35%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.018.png)

**图 6.0.17　为输油网络分配流量**

我们还假设这个输油网只有一个**入口**（比如一处油田）和一个出口（比如一个大型的炼油厂），所有的输油管最终都会和它们相连。在每个结点处，原油流入量和流出量都会达到的平衡。我们用相同的单位衡量流量和管道的输送能力（例如，加仑每秒）。如果在每个开关处都有流入管道的总流量和流出管道的总流量相等，那么问题就不存在了：只需要将所有输油管充满即可。否则，虽然并不是所有管道都是饱和的，但原油仍然会根据各个关节处的开关设置在网络中流动，并将在关节处满足一个**局部平衡**条件：流入结点的流量等于流出结点的流量，请见图 6.0.18。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.019.png)

**图 6.0.18　流量网络中的局部平衡**

例如，如图 6.0.17 所示，一开始操作员可能会将原油的路径设为 0 → 1 → 3 → 5，这条路线能够输送 2 个单位的流量，然后再打开 0 → 2 → 4 → 5 这条路径上的开关，又可以输送 1 个单位的流量。因为 0 → 1、2 → 4 和 3 → 5 都已经饱和，已经无法直接将更多的原油从 0 输送到 5。但如果调整 1 处的开关将 1 → 4 充满，那么就又可以在 3 → 5 空出足够的空间使得 0 → 2 → 3 → 5 可以再增加 1 个单位的流量。即使是这样一个简单的网络，找到能够使得流量最大化的开关配置也并不容易；而对于更加复杂的网络，我们感兴趣的显然是下面这个问题：怎样配置所有开关才能使从入口到出口的流量最大化？我们可以直接用只含有一个起点和一个终点的加权有向图构造出这个问题的模型。图中的边对应的是输油管道，顶点对应的是配有能够控制原油走向和流量的开关结点，边的权重对应的是管道的容量，请见图 6.0.19。我们假设边是有向的，即原油在每个管道中都只能朝着一个方向流动。每条管道中都流动着一定量的原油，流量小于等于管道的容量，而每个顶点都需要满足流入量和流出量相等。这种抽象的流量网络是一个能够解决问题的实用模型，它能够直接应用于许多场景，而间接适用的则更多。我们有时会用原油流过管道的方式直观地说明一些基本的概念，但这里的讨论同样适用于物流分配的通道等情况。鉴于我们在各种最短路径算法中对“距离”概念的用法，在必要的时候会抛弃图的所有物理意义，因为我们讨论的所有定义、性质和算法所基于的抽象模型并不一定遵守物理定律。事实上，人们对网络流问题的主要兴趣在于许多其他问题都能转化为这个模型，下一个小节中将会详述。

![{93%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.020.png)

**图 6.0.19　网络流问题详解**

####6.0.4.2　定义

因为它广泛的应用性，我们需要用精确的语言说明刚才介绍的通俗的概念和术语。

>**定义**。一个**流量网络**是一张边的权重（这里称为**容量**）为正的加权有向图。一个 ![st-](https://private.codecogs.com/gif.latex?st-) **流量网络**有两个已知的顶点，即起点 `s` 和终点 `t`。

有时我们会认为某些边的容量是无限的，或者说是没有容量限制的。这表示不会将其中的流量和它的容量进行比较，或者它的容量必然比所有流量都大。我们将流向一个顶点的总流量（所有指向该顶点的边中的流量之和）称为该顶点的**流入量**，流出一个顶点的总流量（由该顶点指出的所有边中的流量之和）称为该顶点的**流出量**，而两者之差（流入量减去流出量）则为称为该顶点的**净流量**。为了简化讨论，我们假设没有从 `t` 指出的边或是指向 `s` 的边。

>**定义**。![st-](https://private.codecogs.com/gif.latex?st-) 流量网络中的 ![st-](https://private.codecogs.com/gif.latex?st-) **流量配置**是由一组和每条边相关联的值组成的集合，这个值被称为**边的流量**。如果所有边的流量均小于边的容量且满足每个顶点的局部平衡（即净流量均为零，`s` 和 `t` 除外），那么就称这种流量配置方案是**可行的**。

我们将终点的流入量称为 ![st-](https://private.codecogs.com/gif.latex?st-) 流量的值。命题 E 将会证明这个值和起点的流出量是相等的。有了这些定义，就能够正式地描述这个基本问题了。

**最大 ![st-](https://private.codecogs.com/gif.latex?st-) 流量**。给定一个 ![st-](https://private.codecogs.com/gif.latex?st-) 流量网络，找到一种 ![st-](https://private.codecogs.com/gif.latex?st-) 流量配置，使得从 `s` 到 `t` 的流量最大化。

为了简洁，我们将这样的流量配置称为**最大流量**，那么在网络中寻找这种配置的问题就是一个**最大流量问题**。在某些应用中，只需要知道最大流量的值即可，但一般情况下人们还是希望知道达到该值的具体流量配置（各条边的流量值）。

```
private boolean localEq(FlowNetwork G, int v)
{  // 检查顶点v的局部平衡
   double EPSILON = 1E-11;
   double netflow = 0.0;
   for (FlowEdge e : G.adj(v))
      if (v == e.from()) netflow -= e.flow();
      else               netflow += e.flow();

   return Math.abs(netflow) < EPSILON;
}

private boolean isFeasible(FlowNetwork G, int s, int t)
{
   // 确认每条边的流量非负且不大于边的容量
   for (int v = 0; v < G.V(); v++)
      for (FlowEdge e : G.adj(v))
         if (e.flow() < 0 || e.flow() > e.capacity())
            return false;

   // 检查每个顶点的局部平衡
   for (int v = 0; v < G.V(); v++)
      if (v !=s && v != t && !localEq(G, v))
         return false;

   return true;
}
```

{-:-}检查流量网络中的一种流量配置是否可行

####6.0.4.3　API

表 6.0.4 和表 6.0.5 所示的 `FlowEdge` 和 `FlowNetwork` 简单扩展了第 3 章中相应 API。我们将会在 6.0.4.6 节学习 `FlowEdge` 的一种实现，它的基础是 4.3.2 节中的 `Edge` 类并添加了一个实例变量来保存边的流量。流量是有方向的，但 `FlowEdge` 并不是基于 `DirectedEdge`，因为它还需要解决下面将要描述的一个更加抽象的**剩余网络**问题。我们需要使每条边都出现在它的两个顶点的邻接表中才能实现剩余网络。剩余网络能够增减流量并检测一条边是否已经饱和（无法再增大流量）或者是否为空（无法再减小流量）。这些抽象是通过 `residualCapacity()` 和 `addResidualFlow()` 方法实现的，我们将在之后讨论它们。`FlowNetwork` 的实现与 4.3.2 节中 `EdgeWeightedGraph` 的实现基本相同，因此这里将它省略。为了简化文件格式，我们约定起点的编号为 0，终点的编号为 ![V-1](https://private.codecogs.com/gif.latex?V-1)，请见图 6.0.20。有了这些 API 之后最大流量算法的目标就很明确了：构造一个网络，计算所有边中保存流量的实例变量的值并使得网络中的流量最大化。上一页框注所示的是检验一个流量配置方案是否可行的用例代码，一般会将这种检查作为最大流量算法的最后一步。

**表 6.0.4　流量网络中的边的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>FlowEdge</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlowEdge(int v, int w, double cap)</code></td><td></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;from()</code></td><td>这条边的起始顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;to()</code></td><td>这条边的目的顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;other(int v)</code></td><td>边的另一个顶点</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;capacity()</code></td><td>边的容量</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;flow()</code></td><td>边中的流量</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;residualCapacityTo(int v)</code></td><td><code>v</code> 的剩余容量</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;addResidualFlowTo(int v, double delta)</code></td><td>将 <code>v</code> 的流量增加 <code>delta</code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>
</table>

**表 6.0.5　流量网络的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class&nbsp;&nbsp;<b>FlowNetwork</b></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlowNetwork(int V)</code></td><td>创建一个含有 <code>V</code> 个顶点的空网络</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlowNetwork(In in)</code></td><td>从输入流中构造流量网络</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;V()</code></td><td>顶点总数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;E()</code></td><td>边的总数</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;addEdge(FlowEdge e)</code></td><td>向流量网络中添加边 <code>e</code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterable<FlowEdge>&nbsp;&nbsp;adj(int v)</code></td><td>从 <code>v</code> 指出的边</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterable<FlowEdge>&nbsp;&nbsp;edges()</code></td><td>流量网络中的所有边</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>
</table>

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.021.png)

**图 6.0.20　流量网络的表示**

####6.0.4.4　Ford-Fulkerson 算法

在 1962 年，L.R.Ford 和 D.R.Fulkerson 发明了一种解决最大流量问题的有效方法。它是一种沿着由起点到终点的路径逐步增加流量的通用方法，因此它也是同类算法的基础。在经典文献中它被称为 **Ford-Fulkerson 算法**，但它也被称为**增广路径算法**。考虑一个 ![st-](https://private.codecogs.com/gif.latex?st-) 流量网络中的任意一条从起点到终点的有向路径。假设 ![x](https://private.codecogs.com/gif.latex?x) 为该路径上的所有边中未使用容量的最小值。那么只需将所有边的流量增大 ![x](https://private.codecogs.com/gif.latex?x) 即可将网络中的总流量至少增大 ![x](https://private.codecogs.com/gif.latex?x)。反复这个过程，就得到了第一种计算网络中的流量分配方法：找到另一条路径，增大路径中的流量，如此反复，直到所有从起点到终点的路径上至少有一条边是饱和的。（这样在这条路径上就无法继续增大流量了。）这种方法在某些情况下能够计算出网络中的最大流量，但在有些情况下不行，图 6.0.17 就是这类情况。为了改进算法使之总是能够找到最大流量，就要用另一种更加通用的方式增大网络中的流量，即将依据变为网络所对应的**无向图**中从起点到终点的路径。在这样的路径中，当沿着路径从起点向终点**前进**时，经过某条边时的方向可能和流量的方向相同，那这条边即为**正向**边；也可能和流量的方向相反，那这条边即为**逆向**边。现在，对于任意非饱和正向边和非空逆向边，我们可以通过增加正向边的流量和降低逆向边的流量来增加网络中的总流量。流量的增量受路径上的所有正向边的未使用容量最小值和所有逆向边的流量的限制。这样的一条路径被称为增广路径，比如图 6.0.21。在新的流量配置中，路径中至少有一条正向边达到了饱和，或是至少有一条逆向边为空。以上所述的过程就是经典的 Ford-Fulkerson 算法（增广路径算法）的基础。我们将它总结如下。

![{35%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.022.png)

**图 6.0.21　一条增广路径 (0 → 2 → 3 → 1 → 4 → 5)**

>**Ford-Fulkerson 最大流量算法**。网络中的初始流量为零，沿着任意从起点到终点（且不含有饱和的正向边或是空逆向边）的增广路径增大流量，直到网络中不存在这样的路径为止。

令人惊讶的是（在关于流量性质的一定技术性限制之下），无论我们如何选择路径，该方法总能找出最大流量。如同 4.3 节中讨论的贪心最小生成树算法和 4.4 节中讨论的通用最短路径算法一样，它的意义在于证明了所有同类算法的正确性。我们可以用任何方法选择路径。人们发明了多种算法来计算增广路径的序列，以计算最大流量。这些算法的不同之处在于它们得到的增广路径数量和得到每条路径的成本，但它们实现的都是 Ford-Fulkerson 算法并能够找到网络的最大流量。

####6.0.4.5　最大流 - 最小切分{1[也有时译为“最大流-最小割”。——编者注]}定理

为了证明 Ford-Fulkerson 算法的任意实现所计算得到的流量确实是最大流量，需要证明一个叫做**最大流 - 最小切分**的关键定理。理解这个定理是理解所有网络流算法中最重要的一步。顾名思义，定理的基础是网络中的流量和切分的关系，因此需要先定义和切分有关的名词。回顾 4.3 节，图的**切分**是将所有顶点分为两个不相交的集合，而一条横切边则是连接分别存在于两个集合中的两个顶点的一条边。对于流量网络，我们将它们的定义提炼如下。

>**定义**。![st-](https://private.codecogs.com/gif.latex?st-) **切分**是一个将顶点s和顶点t分配于不同集合中的切分。

在一个 ![st-](https://private.codecogs.com/gif.latex?st-) 切分中，每条横切边要么是一条由含有 ![s](https://private.codecogs.com/gif.latex?s) 的集合指向含有 ![t](https://private.codecogs.com/gif.latex?t) 的集合的 ![st-](https://private.codecogs.com/gif.latex?st-) **边**，要么是一条反方向的 ![ts-](https://private.codecogs.com/gif.latex?ts-) **边**。有时我们将 ![st-](https://private.codecogs.com/gif.latex?st-) 边的集合称为一个**切分集**。在流量网络中，一个 ![st-](https://private.codecogs.com/gif.latex?st-) 切分的**容量**为该切分的 ![st-](https://private.codecogs.com/gif.latex?st-) 边的容量之和，![st-](https://private.codecogs.com/gif.latex?st-) 切分的**跨切分流量**（flow across）是切分的所有 ![st-](https://private.codecogs.com/gif.latex?st-) 边的流量之和与所有 ![ts-](https://private.codecogs.com/gif.latex?ts-) 边的流量之和的差。在网络中删去 ![st-](https://private.codecogs.com/gif.latex?st-) 切分的所有 ![st-](https://private.codecogs.com/gif.latex?st-) 边（即切分集）将会切断所有从 ![s](https://private.codecogs.com/gif.latex?s) 到 ![t](https://private.codecogs.com/gif.latex?t) 的路径。而重新添加其中的任意一条边都会得到一条从 ![s](https://private.codecogs.com/gif.latex?s) 到 ![t](https://private.codecogs.com/gif.latex?t) 的路径。切分能够抽象许多应用。比如我们的原油流量模型，切分提供了将从入口流向出口的原油完全切断的方法。如果将切分的容量看作这么做的成本，那么切断流量的最有效方法是解决以下问题。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.023.png)

**最小 ![st-](https://private.codecogs.com/gif.latex?st-) 切分**。给定一个 ![st-](https://private.codecogs.com/gif.latex?st-) 网络，找到容量最小的 ![st-](https://private.codecogs.com/gif.latex?st-) 切分。简单起见，我们将这样的切分称为**最小切分**，而将在网络中找到它的问题称为**最小切分问题**。

最小切分问题的定义中并没有提到流量，而且这些定义似乎和增广路径算法无关。从表面上来看，计算最小切分（得到一组边）似乎比计算最大流量（为所有的边赋权值）更容易。但实际上，最大流量和最小切分问题是紧密相关的。增广路径算法本身就是证明。流量和切分的以下基本关系即可证明 ![st-](https://private.codecogs.com/gif.latex?st-) 流量网络中的局部平衡即意味着整个网络的全局平衡（推论一），并且可以得到任意 ![st-](https://private.codecogs.com/gif.latex?st-) 流量值的上界（推论二）。

>**命题 E**。对于任意 ![st-](https://private.codecogs.com/gif.latex?st-) 流量网络，每种 ![st-](https://private.codecogs.com/gif.latex?st-) 切分中的跨切分流量都和总流量的值相等。

>**证明**。设 ![C_s](https://private.codecogs.com/gif.latex?C_s) 为含有顶点 ![s](https://private.codecogs.com/gif.latex?s) 的集合，![C_t](https://private.codecogs.com/gif.latex?C_t) 为含有顶点 ![t](https://private.codecogs.com/gif.latex?t) 的集合。对 ![C_t](https://private.codecogs.com/gif.latex?C_t) 使用归纳法：当 ![C_t](https://private.codecogs.com/gif.latex?C_t) 仅含有 ![t](https://private.codecogs.com/gif.latex?t) 时该命题成立，若将一个顶点由 ![C_s](https://private.codecogs.com/gif.latex?C_s) 移动到 ![C_t](https://private.codecogs.com/gif.latex?C_t)，则该结点处的局部平衡意味着可以一直保持该性质。因此，通过移动顶点可以得到任意 ![st-](https://private.codecogs.com/gif.latex?st-) 切分。

　

>**推论**。![s](https://private.codecogs.com/gif.latex?s) 的流出量等于 ![t](https://private.codecogs.com/gif.latex?t) 的流入量（即 ![st-](https://private.codecogs.com/gif.latex?st-) 流量网络的值）。

>**证明**。令 ![C_s](https://private.codecogs.com/gif.latex?C_s) 为 ![\{s\}](https://private.codecogs.com/gif.latex?\{s\}) 即可。

　

>**推论**。![st-](https://private.codecogs.com/gif.latex?st-) 流量网络的值不可能超过任意 ![st-](https://private.codecogs.com/gif.latex?st-) 切分的容量。

　

>**命题 F（最大流量—最小切分定理）**。令 ![f](https://private.codecogs.com/gif.latex?f) 为一个 ![st-](https://private.codecogs.com/gif.latex?st-) 流量网络，以下三种条件是等价的：

>i&nbsp;&nbsp;&nbsp;&nbsp;存在某个 ![st-](https://private.codecogs.com/gif.latex?st-) 切分，其容量和 ![f](https://private.codecogs.com/gif.latex?f) 的流量相等；

>ii&nbsp;&nbsp;![f](https://private.codecogs.com/gif.latex?f) 达到了最大流量；

>iii ![f](https://private.codecogs.com/gif.latex?f) 中已经不存在任何增广路径。

>**证明**。根据命题 E 的推论，我们可以由条件 i 得到条件 ii。因为增广路径的存在意味着存在某个流量更大的网络配置，这与 ![f](https://private.codecogs.com/gif.latex?f) 的最大性相冲突，因此由条件 ii 也可以得到条件 iii。

>但还需要证明条件 iii 和条件 i 等价。令 ![C_s](https://private.codecogs.com/gif.latex?C_s) 为由 ![s](https://private.codecogs.com/gif.latex?s) 通过所有不含有任何饱和正向边或空逆向边的无向路径可达的所有顶点组成的集合，令 ![C_t](https://private.codecogs.com/gif.latex?C_t) 为其余的顶点的集合。![t](https://private.codecogs.com/gif.latex?t) 必然存在于 ![C_t](https://private.codecogs.com/gif.latex?C_t) 中，因此 ![(C_s,C_t)](https://private.codecogs.com/gif.latex?(C_s,C_t%29) 为一个 ![st-](https://private.codecogs.com/gif.latex?st-) 切分。它的切分集完全由饱和正向边和空逆向边组成。该切分的跨切分流量和它的容量相等（因为所有正向边都是饱和的，而所有逆向边都是空的），即等于网络中的总流量（由命题 E 可得）。

　

>**推论（完整性）**。当所有容量均为整数时，存在一个整数值的最大流量，而 Ford-Fulkerson 算法能够找出这个最大值。

>**证明**。每条增广路径都会将总流量增大某个正整数值（正向边中未使用容量的最小值和逆向边的容量都是正整数）。

即使所有边的容量均为整数，我们也可以设计出能够达到最大流量的非整数配置，但这里不需要考虑这样的配置。从理论角度来说，下面的意见是很重要的：我们已经演示过并且实际情况也需要允许容量和流量可以为实数，但它会导致一些异常情况。例如，已知 Ford-Fulkerson 算法在原则上可能得到无穷多的增广路径以至于无法收敛到某种最大流量的配置。我们讨论的这个版本总是可以收敛的，即使是实数值的容量和流量也不例外。无论我们用什么方法寻找增广路径，无论我们找到了什么样的路径，最后总是能够得到一种不存在任何增广路径的流量配置，即最大流量的配置。

####6.0.4.6　剩余网络

通用的 Ford-Fulkerson 算法并没有指定寻找增广路径的方法。如何才能找到不含有饱和正向边和空逆向边的路径呢？为此，我们给出如下定义。

>**定义**。给定某个 ![st-](https://private.codecogs.com/gif.latex?st-) 流量网络和其 ![st-](https://private.codecogs.com/gif.latex?st-) 流量配置，这种配置下的**剩余网络**中的顶点和原网络相同。原网络中的每条边都对应着剩余网络中的 1 ～ 2 条边。它的定义如下：对于原网络中的每条从顶点 v 到 w 的边 e，令 ![f_e](https://private.codecogs.com/gif.latex?f_e) 表示它的流量、![c_e](https://private.codecogs.com/gif.latex?c_e) 表示它的容量。如果 ![f_e](https://private.codecogs.com/gif.latex?f_e) 为正，将边 w → v 加入剩余网络且容量为 ![f_e](https://private.codecogs.com/gif.latex?f_e)；如果 ![f_e](https://private.codecogs.com/gif.latex?f_e) 小于ce，将边 v → w 加入剩余网络且容量为 ![c_e-f_e](https://private.codecogs.com/gif.latex?c_e-f_e)。

如果从 ![v](https://private.codecogs.com/gif.latex?v) 到 ![w](https://private.codecogs.com/gif.latex?w) 的边 ![e](https://private.codecogs.com/gif.latex?e) 为空（即 ![f_e](https://private.codecogs.com/gif.latex?f_e) 为 0），剩余网络中就只有一条容量为 ![c_e](https://private.codecogs.com/gif.latex?c_e) 的边 `v` → `w` 与之对应；如果该边饱和（即 ![f_e](https://private.codecogs.com/gif.latex?f_e)等于 ![c_e](https://private.codecogs.com/gif.latex?c_e)），剩余网络就只有一条容量为 ![f_e](https://private.codecogs.com/gif.latex?f_e) 的边 `w` → `v` 与之对应；如果它既不为空，也不饱和，那么剩余网络中将含有相应容量的 `v` → `w` 和 `w` → `v`。请见图 6.0.22。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.024.png)

**图 6.0.22　网络流问题详解**

乍一看，剩余网络有些让人困惑，因为与流量对应的边的方向却和流量本身**相反**。正向边表示的是剩余的容量（即如果选择从这条边通行所能增长的流量）；逆向边表示了实际流量（即如果选择从这条边通行将会减少的流量）。后面框注中的代码给出了在 `FlowEdge` 类中实现剩余网络这种抽象所需的方法。通过这些实现，虽然该算法处理的是剩余网络，但它实际上是在检查所有剩余的容量并（通过边的引用）修正流量配置。

>**流量网络中的边（剩余网络）**

>![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.025.png)

>这里的 `FlowEdge` 类的基础是 4.3 节中对加权边的 `Edge` 类的实现（请见 4.3.2 节框注“带权重的边的数据类型”），它添加了一个实例变量 `flow` 和两个方法来实现剩余网络。

我们可以使用 `from()` 和 `other()` 方法处理两个方向的边：`e.other(v)` 可以返回 `e` 的两个顶点中和 `v` 相对的另一个顶点。`residualCapacityTo()` 和 `addRresidualFlowTo()` 方法实现了剩余网络。剩余网络使得我们可以通过图中的搜索算法寻找增广路径，这是因为在剩余网络中所有从起点到终点的路径都是原流量网络中的一条增广路径。沿着增广路径增大流量意味着修改剩余网络。例如，至少有一条路径上的边变得饱和或变为空，因此在剩余网络中至少有一条边将会改变方向或者消失。（我们使用的是抽象的剩余网络，因此只会检查正容量，不需要实际插入或删除边。）

```
private boolean hasAugmentingPath(FlowNetwork G, int s, int t)
{
   marked = new boolean[G.V()];  // 标记路径已知的顶点
   edgeTo = new FlowEdge[G.V()]; // 路径上的最后一条边
   Queue<Integer> q = new Queue<Integer>();

   marked[s] = true;             // 标记起点
   q.enqueue(s);                 // 并将它入列
   while (!q.isEmpty())
   {
      int v = q.dequeue();
      for (FlowEdge e : G.adj(v))
      {
         int w = e.other(v);
         if (e.residualCapacityTo(w) > 0 && !marked[w])
         {                      // （在剩余网络中）对于任意一条连接到一个未被标记的顶点的边
            edgeTo[w] = e;      // 保存路径上的最后一条边
            marked[w] = true;   // 标记w，因为路径现在是已知的了
            q.enqueue(w);       // 将它入列
         }
      }
   }
   return marked[t];
}
```

{-:-}在剩余网络中通过广度优先搜索寻找增广路径

####6.0.4.7　最短增广路径算法

对 Ford-Fulkerson 算法最简单的实现可能就是**最短**增广路径算法了（最短指的是路径长度最小，而非流量或是容量）。J.Edmonds 和 R.Karp 在 1972 年发明了这个算法。这里，增广路径的查找等价于剩余网络中的广度优先搜索（BFS），如 4.1 节所述。你也可以将 `hasAugmentingPath()` 的实现与广度优先搜索实现的算法 4.2 比较一下。（剩余网络是有向图，因此这实际上是一个有向图处理算法。）这个方法为完整实现剩余网络的算法 6.3 打下了基础，它非常简洁。为了方便，我们将这个方法称为**最短增广路径**的最大流量算法。它处理样例数据的详细轨迹如图 6.0.23 所示。

>**算法 6.3　最短增广路径的 Ford-Fulkerson 最大流量算法。**

>```
>public class FordFulkerson
>{
>    private boolean[] marked;    // 在剩余网络中是否存在从s到v的路径？
>    private FlowEdge[] edgeTo;   // 从s到v的最短路径上的最后一条边
>    private double value;        // 当前最大流量
>    public FordFulkerson(FlowNetwork G, int s, int t)
>    {  // 找出从s到t的流量网络G的最大流量配置
>       while (hasAugmentingPath(G, s, t))
>       {  // 利用所有存在的增广路径
>          // 计算当前的瓶颈容量
>          double bottle = Double.POSITIVE_INFINITY;
>          for (int v = t; v != s; v = edgeTo[v].other(v))
>             bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v));
>          // 增大流量
>          for (int v = t; v != s; v = edgeTo[v].other(v))
>             edgeTo[v].addResidualFlowTo(v, bottle);
>
>          value += bottle;
>       }
>    }
>
>    public double value()        {  return value;      }
>    public boolean inCut(int v)  {  return marked[v];  }
>
>    public static void main(String[] args)
>    {
>       FlowNetwork G = new FlowNetwork(new In(args[0]));
>       int s = 0, t = G.V() - 1;
>       FordFulkerson maxflow = new FordFulkerson(G, s, t);
>
>       StdOut.println(“Max flow from " + s + " to " + t);
>       for (int v = 0; v < G.V(); v++)
>          for (FlowEdge e : G.adj(v))
>             if ((v == e.from()) && e.flow() > 0)
>                StdOut.println("   " + e);
>       StdOut.println("Max flow value = " +  maxflow.value());
>
>    }
>}
>```

>这段 Ford-Fulkerson 算法的实现会在剩余网络中寻找最短增广路径，找出路径上的瓶颈容量并增大该路径上的流量，如此往复直至不再存在从起点到终点的增广路径为止。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.026.png)

**图 6.0.23　最短增广路径的 FordFulkerson 算法的轨迹**

```
% java FordFulkerson tinyFN.txt
Max flow from 0 to 5
  0->2 3.0 2.0
  0->1 2.0 2.0
  1->4 1.0 1.0
  1->3 3.0 1.0
  2->3 1.0 1.0
  2->4 1.0 1.0
  3->5 2.0 2.0
  4->5 3.0 2.0
Max flow value = 4.0
```

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.027.png)

**图 6.0.24　一个较大的流量网络中的最短增广路径**

####6.0.4.8　性能

图 6.0.24 所示的是一个更大的例子。从图中我们可以清晰地看到，增广路径的长度在慢慢变长。这是分析算法性能的第一个要点。

>**命题 G**。最短增广路径的 Ford-Fulkerson 最大流量算法在处理含有 123![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的流量网络时找到的增广路径最多为 ![EV/2](https://private.codecogs.com/gif.latex?EV/2) 条。

>**简略证明**。每条增广路径中都含有一条**关键边**——这条边在剩余网络中会被删掉，因为它对应的可能是一条将会被充满的正向边或是将会被抽干的逆向边。每当一条边成为关键边时，通过它的增广路径的长度就会加 2（请见练习 6.39）。因为增广路径的最大长度为 ![E](https://private.codecogs.com/gif.latex?E) 且每条边最多可能出现在 ![V/2](https://private.codecogs.com/gif.latex?V/2) 条增广路径上，因此增广路径的总数最多为 ![EV/2](https://private.codecogs.com/gif.latex?EV/2)。

>**推论**。Ford-Fulkerson 算法的最短增广路径实现所需的时间在最坏情况下为 ![VE^2/2](https://private.codecogs.com/gif.latex?VE^2/2)。

>**证明**。广度优先搜索最多会检查 ![E](https://private.codecogs.com/gif.latex?E) 条边。

命题 G 所述的上界是非常保守的。例如，图 6.0.24 中含有 11 个顶点和 20 条边，该上界说明算法使用的增广路径最多为 110 条，但实际上它只用了 14 条。

####6.0.4.9　其他实现

Edmonds 和 Karp 发明的另一种 Ford-Fulkerson 算法的实现是优先处理能够将流量增大最多的增广路径。简单起见，我们将这种方法称为**最大容量增广路径**的最大流量算法。对于这种（以及其他一些）方法，可以通过稍加修改 Dijkstra 的最短路径算法、由优先队列得到剩余容量最大的正向边或是流量最大的逆向边来实现。或者也可以寻找最长增广路径，或是随机选择增广路径。要完整分析哪种才是最佳的方法是一个复杂的任务，因为它们的运行时间取决于：

* 找到最大流量所需检查的增广路径数量；
* 寻找每条增广路径所需的时间。

这些量的变化可能很大，和流量网络本身以及图的搜索策略有关。人们还发明了解决最大流量问题的其他几种算法，其中一些在实践中和 Ford-Fulkerson 算法不分高下。但是，为最大流量算法进行数学建模来验证这些猜想是一个非常困难的问题。各种最大流量算法的分析仍然是一个有趣而活跃的研究领域。从理论角度来说，我们已经得到了各种最大流量算法在最坏情况下的上界，但这些上界大多远远高于实际应用中所观察到的真实成本，而且也比较小的下界（线性级别）高出许多。最大流量问题的已知成本和潜在成本之间的差距比（目前）本书中讨论过的任何问题都要大。

最大流量算法的实际应用仍然既是一门艺术也是一门科学。它的艺术之处在于为特定的应用场景选择最有效的策略；它的科学之处在于对问题本质的理解。是否存在能够在线性时间内解决最大流量问题的新数据结构和算法呢？或者我们能否证明它们不存在呢？请见表 6.0.6。

**表 6.0.6　各种最大流量算法的性能特点**

|算法|在含有 _V_ 个顶点和 _E_ 条边的流量网络中（各边容量最大为 _C_），算法的运行时间在最坏情况下的增长数量级|
|-|-|-|
|最短增广路径的 Ford-Fulkerson 算法|![VE^2](https://private.codecogs.com/gif.latex?VE^2)|
|最大容量的 Ford-Fulkerson 算法|![E^2\log C](https://private.codecogs.com/gif.latex?E^2\log%20C)|
|预流推进算法（preflow-push）|![EV\log(E/V^2)](https://private.codecogs.com/gif.latex?EV\log(E/V^2%29)|
|未知算法？|![V+E?](https://private.codecogs.com/gif.latex?V+E?)|

###6.0.5　问题归约

本书中，我们一直注重说明某个特定的问题，然后给出解决问题的算法和数据结构。在许多情况下（以下列出了很多），我们发现如果能够将某个问题转化为已经解决的问题的某个形式，那么解决它将会更容易。在研究已经学习过的各种算法与形形色色的各种问题之间的关系之前，我们应该正式定义这个解决问题的过程。

>**定义**。如果能够用解决问题 B 的算法得到一个解决问题 A 的算法，则说问题 A 能够被**归约**为问题 B。

这个概念在软件开发中显然并不陌生：当你使用一个库方法解决某个问题时，正是在将所需要解决的问题归约为该库方法所解决的问题。本书中，我们一直非正式地将能够归约为给定问题的其他问题称为**应用**。

####6.0.5.1　排序问题

我们在第 2 章第一次遇到了问题的归约，当时我们想说明的是高效的排序算法可以用于解决许多看起来与排序无关的其他问题。例如，在许多有趣的问题中，我们研究了以下几个问题。

* **寻找中位数**。给定一组数字的集合，找出中位数。
* **不重复的值**。在给定的集合中找出所有不同的值。
* **最小平均完成时间的调度问题**。给定一组任务的集合和它们的时耗，在一个处理器上应该如何安排调度使得它们的平均完成时间最小呢？

>**命题 H**。以下问题可以被归约为排序问题：

>* 寻找中位数；
>* 统计不同的值；
>* 最小平均完成时间的调度问题。

>**证明**。请见 2.5.3.4 节和练习 2.5.12。

我们还需要注意归约的成本。例如，我们可以在线性时间内找到一组数的中位数，但是如果归约为排序问题，那就需要线性对数级别的时间。即使是这样，额外的成本或许还是可以接受的，因为我们可以使用已有的排序实现。排序的价值在于以下 3 个方面：

* 它有其自身的实用性；
* 我们的算法能够有效解决排序问题；
* 许多问题都能够归约为排序问题。

一般来说，我们将具有这些性质的问题称为**问题解决模型**。和成熟的库一样，设计良好的问题解决模型能够大大扩展我们能够处理的问题域。但是，在过度关注于问题解决模型时容易犯下的一个错误被称为 **Maslow 的锤子**，这是由 A.Maslow 在 20 世纪 60 年代提出并广为人知的一句话：**如果你有一把锤子，那么什么东西都看起来都像颗钉子**。如果沉迷于若干问题解决模型，我们就可能将它们当作 Maslow 的锤子一样来解决遇到的所有问题，从而妨碍了发现解决问题的更好方法，甚至是新的问题解决模型。尽管本书所讨论的模型都非常重要、实用且应用广泛，但是考虑各种其他可能性仍然是明智的选择。

####6.0.5.2　最短路径问题

在 4.4 节学习最短路径算法时也遇到了问题归约的概念。在许多有趣的问题中，我们研究了以下几个。

* **无向图中的单点最短路径问题**。给定一幅加权**无向图**和起点 `s`，其中所有权重非负，回答“**是否存在从 `s` 到给定目的顶点 `v` 的路径**？如果有，找出这样一条**最短**路径（总权重最小）。”等类似问题。
* **优先级限制下的并行任务调度问题**。给定一组需要完成的任务，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何在若干相同的处理器上（数量不限）安排任务并在最短的时间内完成所有任务？
* **套汇**。在给定的汇率表中找出一个套汇的机会。

和刚才一样，后两个问题看起来和最短路径问题并没有直接的关系，但最短路径算法能够有效地解决它们。这些示例问题虽然都很重要，但并没有什么代表性。许多非常重要的问题（太多了，无法一一讨论）都能够归约为最短路径问题——这是一个非常有效而重要的问题解决模型。

>**命题 I**。以下问题能够归约为加权图中的最短路径问题：

>* 非负权重的无向图中的单点最短路径问题；
>* 优先级限制下的并行调度问题；
>* 套汇问题；
>* 其他许多问题。

>**例证**。请见 4.4.4.2 节命题 R、4.4.5.2 节框注“优先级限制下的并行任务调度问题的关键路径方法”和 4.4.6.9 节框注“货币兑换中的套汇”。

####6.0.5.3　最大流量问题

最大流量问题在许多情况下同样非常重要。我们可以去掉流量网络中的各种限制并解决相关的流量问题，也可以用它解决其他网络或者图的处理问题，甚至是非网络问题。例如以下问题。

* **就业安置**。大学里的就业指导中心会为学生安排公司面试。这些面试的结果是一系列工作机会。假设一次成功的面试表示了学生和公司之间的相互认可且学生将会接受这份职位，那么这样的就业安置数量当然是越多越好。有可能为每一位学生安排一份工作吗？最多可能安排多少份工作？
* **产品配送**。假设有一家只生产一种产品的公司，它拥有能够生产产品的工厂，能够暂时储存产品的物流分配中心以及销售商品的零售直营店。公司需要定期将产品通过物流分配中心分发到各地的直营店，而各地的分配通道的配送能力各有不同。有可能使各地仓库的供应量与直营店的销售量相匹配吗？
* **网络可靠性**。一种简化的模型可以将一个计算机网络看成是通过交换机连接所有电脑的一组主干网，任意两台电脑都能够通过交换机和主干线相互连接。切断某一对计算机之间的连接最少需要切断多少条主干线？

同样，这些问题各不相关，也看起来不属于流量网络的问题范畴，但它们都可以被归约为最大流量问题。

>**命题 J。以下问题可以归约为最大流量问题：**

>* 就业安置；
>* 产品配送；
>* 网络可靠性；
>* 其他许多问题。

>**例证**。这里只证明第一个问题（又叫做**最大二分图匹配问题**），其他的将留作练习。我们可以为给定的就业安置问题构造一个对应的最大流量问题。图中的所有边均由学生指向公司，然后添加一个起点且对于每个学生都有一条从起点指向他的边，添加一个终点且对于每个公司都有一条由公司指向终点的边。图中的每条边的容量都是 1，请见图 6.0.25。现在，这个网络中的最大流量问题的每个解都是对应的二分图匹配问题的的解（请见命题 F 的推论）。匹配中的所有边的两个顶点都正好分别属于学生和公司两个集合且它们在最大流量配置中都会是饱和的。首先，网络流总是会给出一个合法的匹配：因为每个顶点都既有一条流入边（来自于起点）和一条流出边（指向终点）且经过的流量最多为 1，所以每个顶点最多只能出现在一个匹配中。其次，匹配不可能含有更多的边，因为任意类似的匹配都意味着一个比最大流量算法的结果更好的流量配置。

![{95%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.028.png)

**图 6.0.25　将二分图匹配问题归约为网络流问题示例**

例如，如图 6.0.26 所示，一个增广路径最大流量算法可能会使用路径 `s` → `1` → `7` → `t`、`s` → `2` → `8` → `t`、`s` → `3` → `9` → `t`、`s` → `5` → `10` → `t`、`s` → `6` → `11` → `t` 和 `s` → `4` → `7` → `1` → `8` → `2` → `12` → `t` 计算得到匹配 `1-8`、`2-12`、`3-9`、`4-7`、`5-10` 和 `6-11`。因此，在示例中可以找到一种将所有学生和工作相匹配的方法。每条增广路径都会使一条由起点指出的边和一条指向终点的边充满。我们可以注意到，这些边都不是逆向边，因此最多只存在 ![V](https://private.codecogs.com/gif.latex?V) 条增广路径，总运行时间与 ![VE](https://private.codecogs.com/gif.latex?VE) 成正比。

![{30%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.029.png)

**图 6.0.26　二分图匹配中的增广路径**

最短路径和最大流量算法都是重要的问题解决模型，因为它们和排序算法有着相同的性质：

* 它们有其自身的实用性；
* 我们的算法能够有效解决它们；
* 许多问题都能够归约为这些模型。

这段简短的讨论只是为了介绍这个概念。如果你能学习一门有关运筹学的课程，就将会学到许多能够归约为这些模型的其他问题以及更多的问题解决模型。

####6.0.5.4　线性规划

运筹学的基础之一是**线性规划**（Linear Programming，LP），请见图 6.0.27。它的主要思想是将给定的问题归约为以下数学形式。

![{20%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.030.png)

**图 6.0.27　线性规划问题示例**

**线性规划**。给定一个由 ![M](https://private.codecogs.com/gif.latex?M) 个**线性不等式**组成的集合和含有 ![N](https://private.codecogs.com/gif.latex?N) 个决策变量的线性等式，以及一个由该 ![N](https://private.codecogs.com/gif.latex?N) 个决策变量组成的线性**目标函数**，找出能够使目标函数的值最大化的一组变量值，或者证明不存在这样的赋值方案。

线性规划是一种极为重要的问题解决模型，因为：

* 非常多的重要问题都能够归约为线性规划问题；
* 我们的算法能够有效解决线性规划问题。

在讨论其他问题解决模型时的“该问题有其自身的实用性”就不必提了，因为能够归约为线性规划问题的实际问题实在是太多了。

>**命题 K**。以下问题均可归约为线性规划问题：

>* 最大流量问题；
>* 最短路径问题；
>* 许多许多其他问题。

>**例证**。我们只证明第一个问题并将第二个留作练习 6.50。考虑一个由不等式和等式所组成的系统，其中每一个约束变量都对应着一条边，两个不等式也对应着一条边，每一个等式对应着一个顶点（起点和终点除外）。约束变量的值就是边中的流量，不等式指明了边中的流量必须在 0 和边的容量之间，而等式说明指向每个顶点的所有边中的流量之和必须和从该顶点指出的所有边中的流量之和相等。任意最大流量问题都可以用这种方式归约为一个线性规划问题，而它的解又可以很容易地归约为最大流量问题的解。图 6.0.28 给出了一个具体的示例。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.031.png)

**图 6.0.28　将网络流问题归约为线性规划问题**

命题 K 中所说的“许多许多其他问题”有三个含义。第一，**添加约束条件和扩展线性规划模型非常简单**。第二，**问题的归约是有传递性的**，因此能够归约为最短路径和最大流量问题的所有问题也能够归约为线性规划问题。第三，也是更普遍的一种情况，即**各种最优化问题都能够直接构造为线性规划问题**。事实上，**线性规划**这个词的意思就是“将一个最优化问题构造为一个线性规划问题”。这种用法出现在“programming”这个词被用作计算机领域的“编程”之意之前。和非常多的问题都可以归约为线性规划问题同样重要的是，解决线性规划问题的高效算法已经发明了数十年了。其中最著名的是 G. Dantzig 在 20 世纪 40 年代发明的**单纯形法**（simplex algorithm）。理解单纯形法并不困难（请见本书网站上对它的简单实现）。更近一些的时候，L. G. Khachian 在 1979 年演示了**椭球法**（ellipsoid algorithm）并推动了 20 世纪 80 年代**内点法**（interior point methods）的发展。对于人们在现代应用中遇到的各种大型线性规划问题，**内点法**是对**单纯形法**的有效补充。现在，解决线性规划问题的程序都已经十分健壮、久经考验、高效并且对于现代公司机构的基本运作起到了关键的作用。它在科学领域甚至应用程序中的运用也在不断扩展。如果线性规划模型能够表示你的问题，那么离问题的解决也就不远了。

非常现实地说，线性规划是各种问题解决模型的鼻祖，因为非常多的问题都能向它归约。很自然，这一点也使我们不禁思考是否存在比线性规划问题更强大的问题解决模型。还有哪些问题无法归约为线性规划问题？下面就是一个例子。

**负载均衡**。给定一组任务和完成它们的时间，应该如何在两个相同的处理器上分配任务使得所有任务的总完成时间最短？

我们能够找到一个更加一般的问题解决模型并高效解决它的实例吗？这样的思考得到的结果是**不可解性**，它也将是本书的最后一个话题。

###6.0.6　不可解性

本书中讨论的算法一般都是用来解决实际问题的，因此它们消耗的资源都是有限的。大多数算法的实用性是显而易见的，而且对于许多问题，我们还很幸运地能够在几种不同的算法之间进行选择。但不幸的是，现实生活中还有许多其他问题并没有如此有效的解决方法。更糟糕的是，对于许多类问题，人们甚至不知道是否存在有效解决它们的方法。这种情况让程序员和算法的设计者都极度沮丧，因为他们无法为许多实际问题找到有效的算法。对于理论学者而言，沮丧来自于他们无法证明这些问题到底有多难。在这个领域，人们已经进行了大量的研究，并发展出了一种方法来判断一个新问题从技术的角度来说是否能够归于“难以解决”这个类别。尽管这方面的研究大多数都超出了本书的范畴，但是理解它们的核心思想并不困难。我们将在这里介绍它们，因为当面对一个新问题时，每个程序员都应该了解不存在解决它的高效算法的可能性。

####6.0.6.1　准备工作

20 世纪最漂亮和有趣的智力发明之一，就是阿兰·图灵在 20 世纪 30 年代发明的“**图灵机**”。它是一个简单而又非常通用的计算模型，足以描述任意计算机程序和设备。一台图灵机就是一台能够读取输入、变换状态和打印输出的有限状态机。图灵机是理论计算机科学的基础。它来自于下面两个重要的思想。

* **普遍性**。图灵机可以模拟所有物理可实现的计算设备。这被称为**丘奇 - 图灵论题**。这是一个关于自然世界的论断且无法被证明（但可以被证伪）。该论题成立的证据就是数学家和计算机科学家已经发明的无数种计算模型，而它们都已证明和图灵机等价。
* **可计算性**。图灵机（或是任意其他计算设备，根据普遍性可以得到）无法解决的问题是存在的。这在数学上是正确的。停机问题（halting problem）（任意程序都无法保证能够判定给定程序是否会结束）就是这类问题中的一个著名的例子。

在这里，我们感兴趣的是第三个思想，它是关于计算设备效率的。

* **扩展的丘奇—图灵论题**。在任意计算设备上解决某个问题的某个程序所需的运行时间的增长数量级都是在图灵机上（或是任意其他计算设备上）解决该问题的某个程序的多项式倍数。

同样，这也是一个关于自然世界的论断，因为所有已知的计算设备都能够通过图灵机模拟，只是成本最多需要增加一个多项式的倍数。在最近几年，**量子计算**的概念使得一些研究者开始怀疑扩展的丘奇 - 图灵论题的正确性。大多数人都认为，从实践的角度来说，这个论题还能支撑一段时间，但许多学者已经在努力证明它是错误的。

####6.0.6.2　指数级别的运行时间

不可解性理论的目的在于将能够区别多项式时间内解决的问题和在最坏情况下（可能）需要指数级别时间才能解决的问题。我们可以认为指数级别运行时间的算法在输入规模为 ![N](https://private.codecogs.com/gif.latex?N) 时所需的时间（至少）和 ![2^N](https://private.codecogs.com/gif.latex?2^N) 成正比，将底数 2 替换为任意的 ![\alpha>1](https://private.codecogs.com/gif.latex?\alpha%3E1) 均可。我们一般认为指数时间的算法无法保证在合理的时间内解决规模超过（例如）100 的问题，因为无论计算机有多快都没人能够等待一个需要 ![2^{100} ](https://private.codecogs.com/gif.latex?2^{100}) 步的算法。指数增长级别使得科技进步忽略不计：一台超级计算机可能比一张算盘快一万亿倍，但两者都不可能解决需要 ![2^{100} ](https://private.codecogs.com/gif.latex?2^{100}) 步才能完成的问题。有时，“简单”问题和“困难”问题之间只有一线之差。例如，4.1 节中学习的那个能够解决以下问题的算法。

**最短路径长度**。在一幅图中从一个给定的顶点 `s` 到另一个给定的顶点 `t` 之间的最短路径的长度是多少？

但并没有学习解决下面这个问题的算法，但两者看起来本质上似乎是一样的。

**最长路径长度**。在一幅图中从一个给定的顶点 `s` 到另一个给定的顶点 `t` 之间的最长路径的长度是多少？

问题的核心在于，据我们目前所知，从难度上来说这些几乎都是最困难的问题。广度优先搜索能够在**线性**时间内解决第一个问题，但对于第二个问题所有已知算法在最坏情况下均需要**指数级别**的时间。后面框注的代码用一个深度优先搜索的变种解决了这个问题。它和深度优先搜索非常类似，但它检查了图中所有从 `s` 到 `t` 的简单路径才找到了最长的那一条。

```
public class LongestPath
{
   private boolean[] marked;
   private int max;

   public LongestPath(Graph G, int s, int t)
   {
      marked = new boolean[G.V()];
      dfs(G, s, t, 0);
   }

   private void dfs(Graph G, int v, int t, int i)
   {
      if (v == t && i > max) max = i;
      if (v == t) return;
      marked[v] = true;
      for (int w : G.adj(v))
         if (!marked[w]) dfs(G, w, t, i+1);
      marked[v] = false;
   }

   public int maxLength()
   {  return max;  }

}
```

{-:-}找出图中的两个顶点之间的最长路径的长度

####6.0.6.3　搜索问题

本书中已经介绍过的“高效”算法能够解决的问题与还需要如大海捞针一般在各种可能性中寻找解法的问题之间存在巨大差异，这就需要能够用一种简单的形式模型来研究这两类问题之间的关系。第一步就是要说明我们所研究的这类问题。

>**定义**。如果一个问题有解且**验证**它的解的正确性所需的时间不会超过输入规模的多项式，则称这种问题为**搜索问题**。当一个算法给出了一个解或是已证明解不存在时，就称它**解决**了一个搜索问题。

我们将在后面讨论不可解性问题中 4 个比较有趣的问题。这些问题被为“**可满足性**”问题。现在，要证明某个问题是一个搜索问题，只需说明你能够快速验证某个完整的解的正确性即可。解决一个搜索问题就好像“在稻草堆里寻找一根针”一样，你唯一的优势只是在看见它的时候能够认得出来。例如，对于后面列出的每个可满足性问题都给定了一组变量赋值，你都能很容易地验证每个等式或不等式都是满足的，但是寻找这样一组变量赋值就完全不同了。我们常用 NP 描述所有搜索问题——我们会在 6.0.6.6 节说明这个名字的由来。

>**定义**。NP 是所有搜索问题的集合。

NP 准确描述了所有科学家、工程师以及应用程序员**渴望**的能够保证在合理时间范围内**解决**的所有问题的集合。

部分搜索问题。

* **线性等式可满足性**。给定一组由 ![N](https://private.codecogs.com/gif.latex?N) 个变量表示的 ![M](https://private.codecogs.com/gif.latex?M) 个**线性等式**，找出一组满足所有等式的变量赋值，或者证明这样的赋值不存在。
* **线性不等式可满足性（线性规划问题的搜索形式）**。给定一组由 ![N](https://private.codecogs.com/gif.latex?N) 个变量表示的 ![M](https://private.codecogs.com/gif.latex?M) 个线性不等式，找出一组满足所有不等式的变量赋值，或者证明这样的赋值不存在。
* **0 ～ 1 整数线性不等式可满足性（0 ～ 1 整数线性规划问题的搜索形式）**。给定一组由 ![N](https://private.codecogs.com/gif.latex?N) 个整数变量表示的 ![M](https://private.codecogs.com/gif.latex?M) 个线性不等式，找出一组满足所有不等式的变量 0 或 1 赋值，或者证明这样的赋值不存在。
* **布尔可满足性**。给定一组由 ![N](https://private.codecogs.com/gif.latex?N) 个**布尔**变量以及**和 / 或**运算符表示的 ![M](https://private.codecogs.com/gif.latex?M) 个**等式**，找出一组满足所有等式的变量赋值，或者证明这样的赋值不存在。

####6.0.6.4　其他类型的问题

对于构成了不可解性研究的基础的问题集合，搜索问题的概念是多种描述它的方法之一。其他方法包括**决定性**问题（解是否存在？）以及**最优化**问题（最优解是什么？）。例如，6.0.6.2 节中的最长路径长度问题就是一个最优化问题而非一个搜索问题。（给定一个解，无法验证它就是最长路径的长度。）这个问题的搜索版本是找到一条能够连接所有顶点的简单路径。（该问题也叫做**汉密尔顿路径问题**）。这个问题的决定性版本是询问是否**存在**一条能够连接所有顶点的简单路径。套汇问题、布尔可满足性问题和汉密尔顿路径问题都是搜索问题；询问这些问题是否有解是决定性问题；而最短或最长路径问题、最大流量问题和线性规划问题都是最优化问题。虽然它们在技术上并不等价，但搜索问题、决定性问题和最优化问题一般都能够相互归约（请见练习 6.58 和练习 6.59）且我们的主要结论同时适用于这三种类型的问题。

####6.0.6.5　简单的搜索问题

NP 的定义并没有提到寻找解的难度，而只是和解的验证有关。构成不可解性研究的基础的第二类问题的集合被称为 P，它和寻找解的难度有关。在这个模型下，算法的效率是将输入编码所需的比特数量的函数。

>**定义**。P 是能够在多项式时间内解决的所有搜索问题的集合。

这个定义暗示着多项式时间是一个**最坏情况**下的时间界限。对于在集合 P 中的一个问题，必然存在一个算法能够保证在多项式时间内解决它。注意，我们完全没有指定这是一个怎样的多项式。线性、线性对数、平方、立方级别都是多项式时间，因此这个定义显然囊括了目前已经学习的所有标准算法。运行一个算法所需的时间取决于所使用的计算机，但扩展的丘奇 - 图灵论题让这一点变得无关紧要——它说明任意计算设备上的多项式时间的解都意味着任意其他计算设备上也存在多项式时间的解。排序问题属于 P 是因为（例如）插入排序所需的时间与 ![N^2](https://private.codecogs.com/gif.latex?N^2) 成正比（在这里，线性对数时间的排序算法并无意义），最短路径问题、线性等式可满足性问题以及其他许多问题也是这样。一个能够有效解决某个问题的算法足以证明该问题属于集合 P。换句话说，P 准确描述了所有科学家、工程师以及应用程序员能够保证在合理的时间范围内解决的所有问题的集合，请见表 6.0.7 和表 6.0.8。

####6.0.6.6　非确定性

NP 中的 N 表示的是**非确定性**（nondeterminism）。它的意思是，扩展计算机能力的一种（理论上的）方法是赋予它不确定性：即断言当一个算法面对若干个选项时，它有能力“猜出”正确的选择。在我们的讨论中，你可以将非确定性的计算机上的一个算法看作是在“猜测”问题的解，然后验证这个解是否成立。在图灵机中，非确定性只是定义为一个给定状态和一个给定输入时的两个不同的后继状态，解则是能够得到期望结果的所有路径。非确定性也许只是一个数学上的幻想，但它也可以是一种很有用的思想。例如，在 5.4 节中，我们将非确定性用作了一种设计算法的工具——正则表达式模式匹配算法的基础就是有效模拟一个非确定性自动状态机。

**表 6.0.7　集合 NP 中的问题举例**

|问题|输入|描述|存在多项式时间算法|实例|解|
|-|-|-|-|-|-|
|汉密尔顿路径|图 G|找到一条能够访问所有顶点的简单路径|?|![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.032.png)|0-2-1-3|
|分解质因数|整数 ![x](https://private.codecogs.com/gif.latex?x)|找到 ![x](https://private.codecogs.com/gif.latex?x) 的一个非平凡因子|?|97605257271|8784561|
|0-1 线性不等式可满足性|由 ![N](https://private.codecogs.com/gif.latex?N) 个 0-1 变量组成的 ![M](https://private.codecogs.com/gif.latex?M) 个不等式|找出满足所有不等式的变量赋值|?|![\begin{aligned}&x-y\leqslant1\\&2x-z\leqslant2\\&x+y\geqslant2\\&z\geqslant0\end{aligned}](https://private.codecogs.com/gif.latex?\begin{aligned}&x-y\leqslant1\\&2x-z\leqslant2\\&x+y\geqslant2\\&z\geqslant0\end{aligned})|![\begin{aligned}&x=1\\&y=1\\&z=0\end{aligned}](https://private.codecogs.com/gif.latex?\begin{aligned}&x=1\\&y=1\\&z=0\end{aligned})|
|集合 ![P](https://private.codecogs.com/gif.latex?P) 中的所有问题|请见表 6.0.8|||||

**表 6.0.8　集合 P 中的问题举例**

|问题|输入|描述|存在多项式时间算法|实例|解|
|-|-|-|-|-|-|
|最短 ![st-](https://private.codecogs.com/gif.latex?st-) 路径|图 ![G](https://private.codecogs.com/gif.latex?G)<br>顶点 ![s](https://private.codecogs.com/gif.latex?s)、![t](https://private.codecogs.com/gif.latex?t)|找出从 ![s](https://private.codecogs.com/gif.latex?s) 到 ![t](https://private.codecogs.com/gif.latex?t) 的最短路径|广度优先搜索(BFS)|![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.033.png)|0-3|
|排序|数组 ![a](https://private.codecogs.com/gif.latex?a)|将 ![a](https://private.codecogs.com/gif.latex?a) 按升序排列|归并排序|2.8 8.5 4.1 1.3|3 0 2 1|
|线性等式可满足性|![N](https://private.codecogs.com/gif.latex?N) 个变量<br>![M](https://private.codecogs.com/gif.latex?M) 个等式|找出满足所有等式的变量赋值|高斯消元法|![\begin{aligned}&x+y=1.5\\&2x-y=0\end{aligned}](https://private.codecogs.com/gif.latex?\begin{aligned}&x+y=1.5\\&2x-y=0\end{aligned})|![\begin{aligned}&x=0.5\\&y=1\end{aligned}](https://private.codecogs.com/gif.latex?\begin{aligned}&x=0.5\\&y=1\end{aligned})|
|线性不等式可满足性|![N](https://private.codecogs.com/gif.latex?N) 个变量<br>![M](https://private.codecogs.com/gif.latex?M) 个不等式|找出满足所有不等式的变量赋值|椭球法|![\begin{aligned}&x-y\leqslant1.5\\&2x-z\leqslant0\\&x+y\geqslant3.5\\&z\geqslant4.0\end{aligned}](https://private.codecogs.com/gif.latex?\begin{aligned}&x-y\leqslant1.5\\&2x-z\leqslant0\\&x+y\geqslant3.5\\&z\geqslant4.0\end{aligned})|![\begin{aligned}&x=2.0\\&y=1.5\\&z=4.0\end{aligned}](https://private.codecogs.com/gif.latex?\begin{aligned}&x=2.0\\&y=1.5\\&z=4.0\end{aligned})|

####6.0.6.7　主要问题

非确定性十分强大，严肃认真地考虑它似乎有点荒唐。为什么要花心思用一种想象中的工具将困难的问题变得看起来简单呢？答案是，虽然非确定性看起来十分强大，但没人能够**证明**它能够帮助我们解决任何问题！换句话说，还没有人能够找到任何一个问题并证明它属于 NP 而不属于 P（甚至证明存在这样一个问题）。这就留下了一个有待解决的问题：

{-:-}P=NP **成立吗**？

这个问题是由 K.Gödel 在 1950 年写给 J. von Neumann 的一封著名的信中第一次提出的，并且完全难倒了所有数学家和计算机科学家。陈述这个问题的其他方式说明了一些它的基本性质。

* 是否存在**任何**难以解决的搜索问题？
* 如果能构造一种非确定性的计算设备，能够更快地解决某些搜索问题吗？

无法解答这些问题令人们极度懊恼，因为许多重要的实际问题都属于 NP 但却不一定属于 P。（已知的最快确定性算法需要指数级别的时间。）如果能够证明它不属于 P，就可以放弃寻找高效率的算法。既然无法证明，那么就存在发现某种高效算法的可能性。事实上，就我们目前的知识水平而言，NP 中的**每个**问题都可能存在某种高效的算法，这意味着可能还有许多高效的算法没有被人们发现。但实际上没人相信 P=NP，而且很大一部分人都在努力证明该等式不成立。它仍然是计算机科学领域有待证明的最重要的研究课题。

####6.0.6.8　多项式时间问题的相互归约

6.0.5 节通过说明用以下三个步骤可以解决问题 A 的任意实例，证明了问题 A 是可以**归约**为问题 B 的：

* 将 A 的实例归约为 B 的实例；
* 解决 B 的实例；
* 将 B 的实例的解归约为 A 的实例的解。

只要能够有效完成归约（并解决问题 B），我们就能有效的解决问题 A。在这里，为了**效率**我们采用了能够想象的最弱的定义：为了解决问题 A 最多需要解决多项式个问题 B 的实例，且问题归约最多只需多项式时间。在这种情况下，我们称 A 能够在**多项式时间内归约**为 B。在前文中，我们使用问题的归约介绍了各种问题解决模型，使得高效算法所能解决的问题范围大大拓展了。现在，我们要从另一个角度使用问题的归约，即**用它来证明一个问题是难以解决的**。如果一个问题 A 已知是难以解决的，且 A 在多项式时间内能够归约为问题 B，那么问题 B 必然也是难以解决的。否则，问题 B 的一个多项式时间的解必然也能归约为问题 A 的一个多项式时间内的解。

>**命题 L**。布尔可满足性问题能够在多项式时间内归约为 0-1 整数线性不等式可满足性问题。

>**证明**。对于给定的一个布尔可满足性问题的实例，定义一组不等式，其中每个布尔变量都对应着一个 0-1 变量，每个布尔子句也对应着一个 0-1 变量，如图 6.0.29 所示。若布尔变量的值为真（`true`）则对应的整数变量的值为 1，值为假（`false`）时对应的整数变量的值为 0。这样，我们就能够将 0-1 整数线性不等式可满足性问题的解归约为布尔可满足性问题的解。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.034.png)

**图 6.0.29 将布尔可满足性问题归约为 0-1 整数线性不等式可满足性问题的示例**

>**推论**。如果可满足性问题是难以解决的，那么整数线性规划问题也是难以解决的。

即使我们并没有精确定义**难以解决**，关于解决这两种问题的难度关系的陈述仍然是有意义的。在这里，“难以解决”的意思是“不包含在集合 P 中”。一般来说，我们用**不可解**来表示不包含在集合 P 中的问题。以 R.Karp 在 1972 年作出的开创性的工作为起点，一些研究者已经通过这种归约的方式证明了成百上千种各个应用领域的问题都是相关的。此外，这种关系的内涵远比两个单独的问题之间的联系更丰富，下面我们将说明这个概念。

####6.0.6.9　NP- 完全性

许多问题都属于 NP 但可能并不属于 P。也就是说，我们可以轻易地验证任意给定的解是否有效，但即使投入了许多努力，也未能开发出一个有效的算法来寻找问题的解。令人惊讶的是，所有这些问题都有一个额外的性质，令人信服地说明了 P≠NP：

>**定义**。若 NP 中的所有问题都能在多项式时间内归约为搜索问题 A，那么则称问题 A 是 NP- 完全的

这个定义使得我们可以将“难以解决”的定义升级为“除非 P=NP 否则无解”。如果任意 NP- 完全问题能够通过一台有限自动机在多项式时间内解决，那么 ![NP](https://private.codecogs.com/gif.latex?NP) 中的**所有问题**都将得到解决（即 P=NP）。也就是说，所有研究者对于寻找这些问题的高效算法的失败从整体上来说是证明 P=NP 的失败。NP- 完全问题的意思是，我们不期望能够找到多项式时间的算法。大多数实际的搜索问题都已知是 P 或 NP- 完全问题。

####6.0.6.10　Cook-Levin 定理

通过归约，一个问题的 NP- 完全性也意味着另一个问题的 NP- 完全性。但归约在一种情况下是不可用的：如何证明第一个问题是 NP- 完全的？S.Cook 和 L.Levin 在 20 世纪 70 年代早期分别独立地完成了这项工作。

>**命题 M（Cook-Levin 定理）**。布尔可满足性问题是 NP- 完全的。

>**极大简化证明**。目标是证明如果布尔可满足性问题存在多项式时间的算法，那么 NP 集合中的所有问题都能在多项式时间内解决。非确定型图灵机是可以解决 NP 中的任意问题的，因此证明的第一步是用与布尔可满足性问题中一样的逻辑表达式描述非确定型图灵机的所有特性。这可以将 NP 中的每个问题（它们都可以表示为非确定型图灵机上的一个程序）和可满足性问题的某个实例（该程序的逻辑表达式形式）联系起来。这样，可满足性问题的解本质上等价于模拟图灵机在给定的输入下运行给定的程序，因此它将产生给定问题的某个实例的解。这份证明的其他细节已经远远超出了本书的范畴。幸运的是，我们只需要证明这一个命题即可：使用归约来证明 NP- 完全性要简单的多。

Cook-Levin 定理，再加围绕各种 NP- 完全问题所进行的成千上万次多项式时间内的归约，使我们得到了两种可能性：或者 P=NP，即不存在任何不可解的搜索问题（所有搜索问题都能够在多项式时间内得到解决）；或者 P ≠ NP，即存在不可解的搜索问题（某些搜索问题无法在多项式时间内得到解决），请见图 6.0.30。NP- 完全问题在实际应用中经常出现，因此人们找出解决它们的优秀算法的意愿非常强烈。所有这些问题目前都还未找到有效的算法显然强烈说明了 P ≠ NP，大多数研究者也相信这一点。但从另一方面来说，也没人能够证明这些问题中的任意一个不属于 P，这也同样是反方向的一个有力证据。无论 P=NP 是否成立，目前的实际状态是所有 NP- 完全问题的已知最佳算法在最坏情况下都需要指数级别的时间。

![{40%}](http://www.ituring.com.cn/figures/2018/Algorithms/10.d06z.035.png)

**图 6.0.30　问题集的两种可能情况**

####6.0.6.11　问题的分类

要证明一个搜索问题存在于集合 P 中，我们需要展示一个解决它的多项式时间算法，这或许可以通过将它归约为一个已知 P 类问题。要证明 NP 中的一个问题是 NP- 完全的，我们需要证明某个已知的 NP- 完全问题能够在多项式时间内归约为它：也就是说，如果一个新问题的多项式时间的算法能够用于解决 NP- 完全问题，那么它也就能解决 NP 中的所有问题。我们已经用这种方法证明了成千上万的问题都是 NP- 完全问题，就像在命题 L 中对整数线性规划问题进行的转换那样。后面列出了一些有代表性的问题，它包含了 Karp 提出的若干问题，但这只是已知的 NP- 完全问题中极小的一部分。将新问题归入容易解决（属于集合 P）或者难以解决（NP- 完全）的类别可能会出现以下几种情况。

* **显而易见**。例如，著名的高斯消元法就能够证明线性等式可满足性问题属于集合 P。
* **需要一些技巧但并不困难**。例如，给出一份类似于命题 L 的证明需要一些经验和实践，但理解并不困难。
* **非常有挑战性**。例如，线性规划问题曾经长期分类不明，但 Khachian 的椭球法证明了线性规划问题属于集合 P。
* **有待解决**。例如，**图的同构**问题（给定两幅图，给出一种能够使得两幅图相同的顶点重命名方案）和分解**质因数**问题（给定一个整数，找出它的一个非平凡因数）仍然是无解的。

目前这仍然是一块内容丰富、研究活跃的领域，每年都会产生数千篇论文。从后面项目列出的最后几个条目可以看出，它涉及了科学界的各个领域。我们在 NP 的定义中包含了科学家、工程师和应用程序员所**渴望解决**的所有问题——这些问题显然需要分类！

一些著名的 NP- 完全问题。

* **布尔可满足性**。给定一组由 ![N](https://private.codecogs.com/gif.latex?N) 个布尔变量表示的 ![M](https://private.codecogs.com/gif.latex?M) 个等式，找出一组满足所有等式的变量赋值，或者证明这样的赋值不存在。
* **整数线性规划**。给定一组由 ![N](https://private.codecogs.com/gif.latex?N) 个整数变量表示的 ![M](https://private.codecogs.com/gif.latex?M) 个线性不等式，找出一组满足所有不等式的变量赋值，或者证明这样的赋值不存在。
* **负载均衡**。给定一组任务和完成它们的时间以及一个时间上限 ![T](https://private.codecogs.com/gif.latex?T)，应该如何在两个相同的处理器上分配任务以在时间 ![T](https://private.codecogs.com/gif.latex?T) 之内完成所有任务？
* **顶点覆盖**。给定一幅图和一个整数 ![C](https://private.codecogs.com/gif.latex?C)，找出一个含有 ![C](https://private.codecogs.com/gif.latex?C) 个顶点的集合，保证图中的每条边都至少依附于集合中的一个顶点。
* **汉密尔顿路径**。给定一幅图，找出一条正好只经过每个顶点一次的简单路径，或者证明这种路径不存在。
* **蛋白质折叠**。给定能量级别 ![M](https://private.codecogs.com/gif.latex?M)，找出一种蛋白质的某种三维折叠结构，其含有的潜在能量小于 ![M](https://private.codecogs.com/gif.latex?M)。
* **伊辛模型**。给定一个三维晶格伊辛模型和一个能量阈值 ![E](https://private.codecogs.com/gif.latex?E)，是否存在一个自由能小于 ![E](https://private.codecogs.com/gif.latex?E) 的子图？
* **给定收益的风险投资组合**。给定一组风险投资渠道与一个总成本以及一个给定收益。每项投资都有一定的风险值，风险的总阈值为 ![M](https://private.codecogs.com/gif.latex?M)。找到一种分配投资的方法使得总风险小于 ![M](https://private.codecogs.com/gif.latex?M)。

####6.0.6.12　处理 NP- 完全性

在实践中，我们必须为这些各种各样的问题找到某种解决办法，因此人们对解决这些问题非常感兴趣。我们不可能在这一小段文字中说明这个庞大的研究领域，但我们可以简要描述一下人们已经尝试过的各种手段。一种方法是，修改问题并寻找一种“近似”算法来给出接近但并非最佳的解。例如，**欧几里得旅行销售员问题**（traveling salesman problem），我们很容易找到一个长度小于最优路线的两倍的解。但不幸的是，在寻找更好的近似时，这种方法并不足以绕开 NP- 完全性。第二种方法是，给出一种能够有效解决实际应用中所出现的问题的实例算法，但对于最坏情况下的输入，这种算法仍然是无法找到问题的解。这种方法最著名的例子是解决整数线性规划问题的程序，它们是数十年来解决无数工业应用中的大量最优化问题的主力军。尽管它们有可能需要指数级别的时间，但实际应用中的输入数据也显然不是最坏情况下的输入。第三种方法是，使用一种叫做“回溯法”的技术来避免检查所有可能的解，以期找到尽可能“高效”的指数级别算法。最后，计算机科学的理论并没有提到多项式时间和指数时间之间的一个相当大的空档。存在运行时间与 ![N^{\log N}](https://private.codecogs.com/gif.latex?N^{\log%20N}) 以及 ![2^{\sqrt{N}}](https://private.codecogs.com/gif.latex?2^{\sqrt{N}}) 成正比的算法吗？

NP- 完全性触及了本书中我们所研究过的所有应用领域：NP- 完全问题会出现在初级的编程问题、排序和查找、图处理、字符串处理、科学计算、系统编程、运筹学以及所有能够想到的需要计算的地方。NP- 完全性理论对实际生产最重要的贡献在于它给出了一种方法来鉴别来自于这些广泛领域的一个新问题是“容易”还是“困难”呢。如果有人找到了一种解决新问题的有效方法，那么它显然就没什么难度了。如果找不到，那么要是能够证明该问题是 NP- 完全的，这就说明找到一个高效算法基本上是不可能的。（因此或许应该尝试另一种思路。）本书中已经研究过的所有高效算法说明我们已经学习了自欧几里得以来的多种高效的计算方法，但 NP- 完全性理论也说明事实上人们还有很长的路要走。

###练习：碰撞模拟

**6.1**　根据正文完成 `predictCollisions()` 和 `Particle` 的实现。决定一对刚性球体进行弹性碰撞后的运动状态需要 3 个公式：(a) 动量守恒，(b) 动能守恒，(c) 碰撞时，相互作用力和碰撞点的切面垂直（假设没有摩擦力和自旋）。更多细节请见本书的网站。

**6.2**　开发一个版本的 `CollisionSystem`、`Particle` 和 `Event` 类，使之能够处理多个粒子的相互碰撞。在模拟台球比赛的开球时这是非常重要的。（这道习题很难！）

**6.3**　开发一个三维版本的 `CollisionSystem`、`Particle` 和 `Event` 类。

**6.4**　尝试将大片区域分割为长方形的小格，并在一种新的事件类型中仅预测某个粒子在某一时刻和相邻的 9 个方格中的所有粒子的碰撞。用这种方法改进 `CollisionSystem` 的 `simulate()` 方法的性能。这种方法减少了需要计算的预测碰撞数量，代价是需要监视所有粒子在方格之间的运动。

**6.5**　在 `CollisionSystem` 中引入**熵**的概念并用它验证（信息论中的）经典结论。

**6.6**　**布朗运动**。1827 年，植物学家罗伯特·布朗在用显微镜观察到浸入水中的野生花粉颗粒时，发现它们在进行无规则的运动。这种运动后来被称为布朗运动。人们讨论了这种现象，但没人能够给出令人信服的解释，直到爱因斯坦在 1905 年在数学上说明了这个问题。爱因斯坦的解释是：花粉颗粒的运动是由无数微小的分子和花粉粒子相撞造成的。请用模拟来说明这个现象。

**6.7**　**温度**。为 `Particle` 类添加一个 `temperature()` 方法，返回粒子的质量和速度的平方除以 ![{\rm d}k_B](https://private.codecogs.com/gif.latex?{\rm%20d}k_B) 的商之积，其中空间维数 ![d=2](https://private.codecogs.com/gif.latex?d=2)，`Boltzmann` 常数 ![k_B=1.3806488\times10^{-23}](https://private.codecogs.com/gif.latex?k_B=1.3806488\times10^{-23})。系统的温度是所有粒子的这些量的平均值。为 `CollisionSystem` 添加一个 `temperature()` 方法，周期性采集温度数据并绘成图表，检查温度是否恒定。

**6.8**　Maxwell-Boltzmann。刚性球体模型中的所有粒子的速度分布遵循 **Maxwell-Boltzmann 分布**（假设系统已经被加热且粒子的质量足以忽略量子力学效应），在二维系统中又被称为 **Rayleigh 分布**。分布的形状取决于温度。编写一个方法计算粒子速度的直方图并在各种温度下测试它。

**6.9**　**任意形状**。分子的移动速度非常快（超过喷气式飞机）但扩散却很慢，因为它们会互相碰撞并因此改变方向。扩展模型，将两个容器用一根管道相连，容器中分别含有两种不同类型的粒子。模拟粒子的运动并以时间的函数测量每个容器中每种类型的粒子的比例。

**6.10**　**回退**。在某次模拟结束后，将所有速度变为相反的方向并继续模拟系统中的运动，它应该能够回到最初的状态！测量系统的最终状态和初始状态的差异来估计四舍五入造成的误差。

**6.11**　**压强**。为 `Particle` 类添加一个 `pressure()` 方法来测量大量粒子和墙体碰撞造成的压强。系统的压强为所有粒子的冲击力之和。为 `CollisionSystem` 类添加一个 `pressure()` 方法并编写一个用例验证等式 ![pv=nRT](https://private.codecogs.com/gif.latex?pv=nRT)。

**6.12**　**基于索引优先队列的实现**。开发一个版本的 `CollisionSystem`，使用索引优先队列来保证优先队列的长度最多与粒子数量呈线性关系（而非平方级别或者更糟）。

**6.13**　**优先队列的性能**。使用优先队列，在多种温度下测试 `Pressure` 类来定位计算的瓶颈。如果可以，尝试切换到另一种不同的优先队列实现，在高温下获取更好的性能。

###练习：B- 树

**6.14**　假设在一棵三层树中，总共可以在内存中保存 ![a](https://private.codecogs.com/gif.latex?a) 条链接。每个页中可以保存 ![b\sim2b](https://private.codecogs.com/gif.latex?b\sim2b) 条指向内部结点的链接和 ![c\sim2c](https://private.codecogs.com/gif.latex?c\sim2c) 条指向外部结点中的链接。在这样一棵树中最多可以含有多少个项（作为 ![a](https://private.codecogs.com/gif.latex?a)、![b](https://private.codecogs.com/gif.latex?b)、![c](https://private.codecogs.com/gif.latex?c) 的函数）？

**6.15**　开发一个 `Page` 的实现，将 B- 树的结点表示为一个 `BinarySearchST` 类的对象。

**6.16**　扩展 `BTreeSET` 来实现能够关联键和值的 `BTreeST` 类，并完整支持有序符号表 API，包括 `min()`、`max()`、`floor()`、`ceiling()`、`deleteMin()`、`deleteMax()`、`select()`、`rank()` 方法以及接受两个参数的 `size()` 和 `get()` 方法。

**6.17**　编写一个程序，使用 StdDraw 将 B- 树的生长过程可视化，如同正文描述的方式一样。

**6.18**　在一个有缓存的典型系统中，估计对 B- 树的 ![S](https://private.codecogs.com/gif.latex?S) 次随机查找中，每次查找的平均探查次数。缓存可以将 ![T](https://private.codecogs.com/gif.latex?T) 个最近访问的页保存在内存中（因此无需探查）。假设 ![S](https://private.codecogs.com/gif.latex?S) 远大于 ![T](https://private.codecogs.com/gif.latex?T)。

**6.19**　**网络搜索**。开发一个 `Page` 类的实现，为了索引网页，用 B- 树的结点表示网页中的文本。用一个文件表示搜索的关键字。从标准输入接受被索引的网页。为了控制规模，接受命令行参数 ![m](https://private.codecogs.com/gif.latex?m) 并将内部结点的数量限制在 ![10^m](https://private.codecogs.com/gif.latex?10^m) 内。（在使用较大的 ![m](https://private.codecogs.com/gif.latex?m) 前请联系系统管理员。）使用一个 ![m](https://private.codecogs.com/gif.latex?m) 位的数字来表示内部结点。例如，当 ![m](https://private.codecogs.com/gif.latex?m) 为 4 时，结点名可以是 `BTreeNode0000`、`BTreeNode0001`、`BTreeNode0002` 等。在页中保存成对的字符串。向 API 中添加一个 `close()` 操作来排序并写入数据。为了测试实现，尝试在你的学校的网站上搜索你和朋友的名字。

**6.20**　B\*- **树**。在 B- 树中启发式地分裂兄弟结点：当某个结点含有 ![M](https://private.codecogs.com/gif.latex?M) 个条目并需要分裂时，将它和它的一个兄弟结点合并。如果该兄弟结点只含有 ![k](https://private.codecogs.com/gif.latex?k) 个条目且 ![k<M-1](https://private.codecogs.com/gif.latex?k%3CM-1)，可以重新分配并使得两者都只含有 ![(M+k)/2](https://private.codecogs.com/gif.latex?(M+k%29/2) 个条目。否则，我们创建一个新结点并使 3 个结点中都只含有 ![2M/3](https://private.codecogs.com/gif.latex?2M/3) 个条目。同时，我们允许根结点保存 ![4M/3](https://private.codecogs.com/gif.latex?4M/3) 个条目，并在它饱和时将它分裂并创建一个只含有两个条目的新根结点。找出在含有 ![N](https://private.codecogs.com/gif.latex?N) 个元素的 ![M](https://private.codecogs.com/gif.latex?M) 阶 B\*- 树中每次查找或插入所需的探查数的上下界限。将你的结果和 B- 树的相应上下界（请见命题 B）进行比较。实现 **B\* 树**中的插入**操作**。

**6.21**　编写一段程序，计算在 ![N](https://private.codecogs.com/gif.latex?N) 次随机插入所构造的一棵 ![M](https://private.codecogs.com/gif.latex?M) 阶 B- 树中外部页的平均数量。用合理的 ![M](https://private.codecogs.com/gif.latex?M) 和 ![N](https://private.codecogs.com/gif.latex?N) 值运行你的程序。

**6.22**　如果你的系统支持虚拟内存，设计并用实验比较 B- 树和二分查找在一张庞大的符号表中的随机查找性能。

**6.23**　对于你为练习 6.15 给出的保存在内存中的 `Page` 的实现，用实验确定能够使 B- 树在一张庞大的符号表中的使随机查找操作速度最快的 ![M](https://private.codecogs.com/gif.latex?M) 值。特别注意 ![M](https://private.codecogs.com/gif.latex?M) 为 `100` 的倍数的情况。

**6.24**　运行实验比较保存在内存中的 B- 树（使用练习 6.23 中确定的 ![M](https://private.codecogs.com/gif.latex?M) 值）、线性探测散列法和红黑树在一张庞大的符号表中的随机查找用时。

###练习：后缀数组

**6.25**　按照图 6.0.15 的样式给出由以下字符串的后缀、后缀的排序、`index()` 和 `lcp()` 方法的返回值组成的表格。

　　　a. `abacadaba`

　　　b. `mississippi`

　　　c. `abcdefghij`

　　　d. `aaaaaaaaaa`

**6.26**　下面这段代码用于计算字符串的所有后缀，找出其中的问题。

```
suffix = "";

for (int i = s.length() - 1; i >= 0; i--)
{
    suffix = s.charAt(i) + suffix;
    suffixes[i] = suffix;
}
```

　　　**答**：它需要平方级别的时间和空间。

**6.27**　有些应用需要对文本进行**回环变位**，这个操作会涉及文本中的所有字符。对于 `0` 到 ![N-1](https://private.codecogs.com/gif.latex?N-1) 之间的 `i`，长度为 ![N](https://private.codecogs.com/gif.latex?N) 的文本的第 `i` 次回环变位得到的是它的后 ![N-](https://private.codecogs.com/gif.latex?N-)`i` 个字符和前 `i` 个字符相连所得的字符串。下面这段代码用于计算文本的所有回环变位，找出其中的问题。

```
int N = s.length();
for (int i = 0; i < N; i++)
    rotation[i] = s.substring(i, N) + s.substring(0, i);
```

　　　**答**：它需要平方级别的时间和空间。

**6.28**　设计一个线性时间的算法来计算给定文本字符串的所有回环变位。

　　　**答**：

```
String t = s + s;
int N = s.length();
for (int i = 0; i < N; i++)
    rotation[i] = r.substring(i, i + N);
```

**6.29**　按照 1.4 节中的假设，给出一个长度为 ![N](https://private.codecogs.com/gif.latex?N) 的字符串 `SuffixArray` 对象对内存的使用情况。

**6.30**　**最长公共子字符串**。编写一个 `SuffixArray` 的用例 `LCS`，接受两个文件名作为命令行参数，读取这两个文本文件并在线性时间内找出同时出现在两个文件中的最长子字符串。（在 1970 年，D.Knuth 猜测这是不可能的。）**提示**：为字符串 `s#t` 创建后缀数组，其中 `s` 和 `t` 是文本字符串，而 `#` 是一个两者都不包含的字符）。

**6.31**　**Burrow-Wheeler 变换**。**Burrow-Wheeler 变换**（BWT）是一种用于数据压缩算法中的变换，包括 `bzip2` 和高吞吐量的基因组测序等。编写一个 `SuffixArray` 的用例用以下方法在线性时间内计算 BWT。给定一个长度为 ![N](https://private.codecogs.com/gif.latex?N) 的字符串（以一个文件结束符 `$` 结尾，它小于其他任意字符）。使用一个 ![N\times N](https://private.codecogs.com/gif.latex?N\times%20N) 的矩阵，其中每一行均为原文的一个不同的回环变位。按照字典顺序将所有行排序。`Burrow-Wheeler` 变换就是排序后的矩阵中最右侧的列。例如，`mississippi$` 的 BWT 是 `ipssm$pissii`。**Burrow-Wheeler 逆变换**（BWI）是 BWT 的逆序。例如，`ipssm$pissii` 的 BWI 是 `mississippi$`。编写一个用例，在线性时间内，为某个字符串的 BWT 计算它的 BWI。

**6.32**　**环形字符串的线性化**。编写一个 `SuffixArray` 的用例，对于给定的字符串，在线性时间内找出它的字典序列最小的回环变位。这个问题来源于化学数据库中的各种环形分子，每一种分子都表示为一个环形的字符串。人们需要一种标准的表示方法（最小的回环变位）使得用字符串的任意回环变位作为键都能找到该分子。（请见练习 6.27 和练习 6.28。）

**6.33**　**重复 ![k](https://private.codecogs.com/gif.latex?k) 次的最长子字符串**。编写一个 `SuffixArray` 的用例，对于给定的字符串和一个整数 `k`，找出其中被至少重复了 `k` 次的最长子字符串。

**6.34**　**较长的重复字符串**。编写一个 `SuffixArray` 的用例，对于给定的字符串和一个整数 `L`，找出长度至少为 `L` 的重复子字符串。

**6.35**　**![k-{\rm gram}](https://private.codecogs.com/gif.latex?k-{\rm%20gram}) 频率统计**。开发并实现一个抽象数据类型，对字符串进行预处理以支持高效回答如下形式的问题：“**给定的 ![k-{\rm gram}](https://private.codecogs.com/gif.latex?k-{\rm%20gram}) 出现了多少次？**”每次查询在最坏情况下所需的时间应该与 ![k\log N](https://private.codecogs.com/gif.latex?k\log%20N) 成正比，其中 ![N](https://private.codecogs.com/gif.latex?N) 为字符串的长度。

###练习：最大流问题

**6.36**　在含有 ![V](https://private.codecogs.com/gif.latex?V) 个顶点和 ![E](https://private.codecogs.com/gif.latex?E) 条边的任意 ![st-](https://private.codecogs.com/gif.latex?st-) 流量网络中，如果所有边的容量都是小于 ![M](https://private.codecogs.com/gif.latex?M) 的正整数，可能的最大流量值是多少？为存在和不存在平行边的情况分别给出答案。

**6.37**　如果原流量网络在删去终点时将变成一棵树，给出一个算法解决这种流量网络中的最大流量问题。

**6.38**　**真假判断**。如果为真，给出简短的证明；如果为假，给出一个反例。

　　　a. 在任意最大流配置中均不存在所有边的正流均为正的有向环。

　　　b. 存在一种不包含所有边的流量均为正的有向环的最大流配置。

　　　c. 如果所有边的容量均不同，那么最大流量配置是唯一的。

　　　d. 如果所有边的容量是一个等差数列，那么最小切分是唯一的（remains unchanged）。

　　　e. 如果所有边的容量是一个等比数列，那么最小切分是唯一的。

**6.39**　**完成命题 G 的证明**。说明为何每当一条边成为关键边时，经过它的增广路径的长度必然会加 2。

**6.40**　在互联网上找出一个大型网络，使用真实数据测试最大流算法。你可以选择交通运输网络（公路、铁路或者航空）、通信网络（电话或者计算机网络）或者物流配送网络。如果边的容量不明，根据一个合理的模型自己添加这些数据。编写一个程序使用我们学过的接口根据你的数据实现流量网络的配置。如有需要，编写一个私有方法清理数据。

**6.41**　编写一个随机网络生成器来生成稀疏网络，其中边的容量为 0 到 ![2^{20} ](https://private.codecogs.com/gif.latex?2^{20}) 之间的整数。用一个单独的类表示容量并开发两种实现：一种生成均匀分布的容量值，一种根据高斯分布生成容量值。实现一个用例，对于一组精心选择的 ![V](https://private.codecogs.com/gif.latex?V) 和 ![E](https://private.codecogs.com/gif.latex?E) 值用两种分布方法生成随机网络，这样你就可以使用它们进行各种测试了。

**6.42**　编写一个程序，在平面上随机生成 ![V](https://private.codecogs.com/gif.latex?V) 个点。构造流量网络时，对于每个点都将它和距离 ![d](https://private.codecogs.com/gif.latex?d) 以内的所有点相互连接，用练习 6.41 中的随机模型设置每条边的容量。

**6.43**　**简单的归约**。编写 `FordFulkerson` 的用例，在以下类型的流量网络中寻找最大流配置。

* 管道没有方向。
* 起点和终点的数量不限，也不限制指向起点或是由终点指出的边的数量。
* 容量有下限。
* 顶点有流量限制。

**6.44**　**产品分发**。假设流量表示城市之间用卡车运送的产品，边 `u-v` 上的流量表示某一天从 `u` 市运送到 `v` 市的产品数量。编写一个用例，为卡车司机打印出每天的订单，告诉他们应该去哪个城市上多少货，然后去哪个城市卸多少货。假设卡车司机的数量无限多且对于任意一个分发点，所有货物全部收到了之后才会开始发货。

**6.45**　**就业安置**。开发一个 `FordFulkerson` 的用例，根据命题 J 中的归约解决就业安置问题。使用一张符号表将名字变为数字并用于流量网络中。

**6.46**　构造一系列的二分图匹配问题，其中任意增广路径算法解决对应的最大流问题所使用的所有增广路径的平均长度与 ![E](https://private.codecogs.com/gif.latex?E) 成正比。

**6.47**　**![st-](https://private.codecogs.com/gif.latex?st-) 连通性**。开发一个 `FordFulkerson` 的用例，对于给定的无向图 ![G](https://private.codecogs.com/gif.latex?G) 和顶点 ![s](https://private.codecogs.com/gif.latex?s) 和 ![t](https://private.codecogs.com/gif.latex?t)，找出在 ![G](https://private.codecogs.com/gif.latex?G) 中使 ![t](https://private.codecogs.com/gif.latex?t) 和 ![s](https://private.codecogs.com/gif.latex?s) 不连通所需切断的最小边数。

**6.48**　**不同的路径**。开发一个 `FordFulkerson` 的用例，对于给定的无向图 ![G](https://private.codecogs.com/gif.latex?G) 和顶点 ![s](https://private.codecogs.com/gif.latex?s) 和 ![t](https://private.codecogs.com/gif.latex?t)，找出从 ![s](https://private.codecogs.com/gif.latex?s) 到 ![t](https://private.codecogs.com/gif.latex?t) 最多有多少条任意边均不相同的路径。

###练习：问题的归约与不可解性

**6.49**　找到 37 703 491 的一个非平凡因数。

**6.50**　证明最短路径问题可以归约为线性规划问题。

**6.51**　如果 P ≠ NP，是否存在能够在 ![N^{\log N}](https://private.codecogs.com/gif.latex?N^{\log%20N}) 时间内解决某个 NP- 完全问题的算法？解释你的回答。

**6.52**　假设某人发明了一种保证能够在与 ![1.1^N](https://private.codecogs.com/gif.latex?1.1^N) 成正比的时间内解决布尔可满足性问题的算法。这说明我们能够在与 ![1.1^N](https://private.codecogs.com/gif.latex?1.1^N) 成正比的时间内解决其他 NP- 完全问题吗？

**6.53**　一个能够在与 ![1.1^N](https://private.codecogs.com/gif.latex?1.1^N) 成正比的时间内解决整数线性规划问题的程序的意义是什么？

**6.54**　给出一个从顶点覆盖问题向 0-1 整数线性不等式可满足性问题的多项式时间的归约。

**6.55**　使用无向图中的汉密尔顿路径问题的 NP- 完全性证明在**有向图**中寻找汉密尔顿路径的问题也是 NP- 完全的。

**6.56**　假设两个问题都已知是 NP- 完全的，这说明能够在多项式时间内将两者相互归约吗？

**6.57**　假设问题 ![X](https://private.codecogs.com/gif.latex?X) 是 NP- 完全的，![X](https://private.codecogs.com/gif.latex?X) 能够在多项式时间内归约为问题 ![Y](https://private.codecogs.com/gif.latex?Y)，而且 ![Y](https://private.codecogs.com/gif.latex?Y) 也能在多项式时间内归约为 ![X](https://private.codecogs.com/gif.latex?X)，那么 ![Y](https://private.codecogs.com/gif.latex?Y) 一定是 NP- 完全的吗？

　　　**答**：不，因为 ![Y](https://private.codecogs.com/gif.latex?Y) 不一定属于 NP。

**6.58**　假设我们有一个能够解决布尔可满足性问题的确定性版本的算法，这说明存在某种变量赋值能够满足所有的布尔表达式。说明如何找到这种赋值方案。

**6.59**　假设我们有一个能够解决顶点覆盖问题的确定性版本的算法，这说明对于某个给定的大小存在顶点覆盖的方案。说明如何解决最小顶点覆盖问题的最优化版本。

**6.60**　解释为何顶点覆盖问题的最优化版本不一定是一个搜索问题。

　　　**答**：因为并没有很好的方法来验证给定的节是否是最优的。（尽管我们可以用二分查找在这个问题的搜索版本上找到最优解。）

**6.61**　假设问题 ![X](https://private.codecogs.com/gif.latex?X) 和问题 ![Y](https://private.codecogs.com/gif.latex?Y) 均为搜索问题，且 ![X](https://private.codecogs.com/gif.latex?X) 能够在多项式时间内归约为 ![Y](https://private.codecogs.com/gif.latex?Y)。我们可以得到以下哪些结论。

　　　a. 如果 ![Y](https://private.codecogs.com/gif.latex?Y) 是 NP- 完全的，那么 ![X](https://private.codecogs.com/gif.latex?X) 也是。

　　　b. 如果 ![X](https://private.codecogs.com/gif.latex?X) 是 NP- 完全的，那么 ![Y](https://private.codecogs.com/gif.latex?Y) 也是。

　　　c. 如果 ![X](https://private.codecogs.com/gif.latex?X) 属于 P，那么 ![Y](https://private.codecogs.com/gif.latex?Y) 也属于 P。

　　　d. 如果 ![Y](https://private.codecogs.com/gif.latex?Y) 属于 P，那么 ![X](https://private.codecogs.com/gif.latex?X) 也属于 P。

**6.62**　假设 P ≠ NP，我们可以得到以下哪些结论。

　　　a. 如果问题 ![X](https://private.codecogs.com/gif.latex?X) 是 NP- 完全的，那么 ![X](https://private.codecogs.com/gif.latex?X) 无法在多项式时间内得到解决。

　　　b. 如果问题 ![X](https://private.codecogs.com/gif.latex?X) 属于 NP，那么 ![X](https://private.codecogs.com/gif.latex?X) 无法在多项式时间内得到解决。

　　　c. 如果问题 ![X](https://private.codecogs.com/gif.latex?X) 属于 NP 但并不是 NP- 完全的，那么 ![X](https://private.codecogs.com/gif.latex?X) 可以在多项式时间内得到解决。

　　　d. 如果问题 ![X](https://private.codecogs.com/gif.latex?X) 属于 P，那么 ![X](https://private.codecogs.com/gif.latex?X) 就不是 NP- 完全的。