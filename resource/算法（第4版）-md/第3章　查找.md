#第 3 章　查找

现代计算机和网络使我们能够访问海量的信息。高效检索这些信息的能力是处理它们的重要前提。本章描述的都是数十年来在广泛应用中经过实践检验的**经典查找**算法。没有这些算法，现代信息世界的基础计算设施都无从谈起。

我们会使用**符号表**这个词来描述一张抽象的表格，我们会将信息（**值**）存储在其中，然后按照指定的**键**来搜索并获取这些信息。键和值的具体意义取决于不同的应用。符号表中可能会保存很多键和很多信息，因此实现一张高效的符号表也是一项很有挑战性的任务。

符号表有时被称为**字典**，类似于那本将单词的释义按照字母顺序排列起来的历史悠久的参考书。在英语字典里，键就是单词，值就是单词对应的定义、发音和词源。符号表有时又叫做**索引**，即书本最后将术语按照字母顺序列出以方便查找的那部分。在一本书的索引中，键就是术语，而值就是书中该术语出现的所有页码。

在说明了基本的 API 和两种重要的实现之后，我们会学习用三种经典的数据类型来实现高效的符号表：二叉查找树、红黑树和散列表。在总结中我们会看到它们的若干扩展和应用，它们的实现都**有赖于我们在本章中将会学到的高效算法。

##3.1　符号表

符号表最主要的目的就是将一个**键**和一个**值**联系起来。用例能够将一个键值对**插入**符号表并希望在之后能够从符号表的所有键值对中按照键直接**找到**相对应的值。本章会讲解多种构造这样的数据结构的方法，它们不光能够高效地**插入**和**查找**，还可以进行其他几种方便的操作。要实现符号表，我们首先要定义其背后的数据结构，并指明创建并操作这种数据结构以实现插入、查找等操作所需的算法。

查找在大多数应用程序中都至关重要，许多编程环境也因此将符号表实现为高级的抽象数据结构，包括 Java——我们会在 3.5 节中讨论 Java 的符号表实现。表 3.1.1 给出的例子是在一些典型的应用场景中可能出现的键和值。我们马上会看到一些参考性的用例，3.5 节的目的就是向你展示如何在程序中有效地使用符号表。本书中我们还会在其他算法中使用符号表。

>**定义**。符号表是一种存储键值对的数据结构，支持两种操作：**插入**（put），即将一组新的键值对存入表中；**查找**（get），即根据给定的键得到相应的值。

**表 3.1.1　典型的符号表应用**

|应用|查找的目的|键|值|
|-|-|-|-|
|字典|找出单词的释义|单词|释义|
|图书索引|找出相关的页码|术语|一串页码|
|文件共享|找到歌曲的下载地址|歌曲名|计算机 ID|
|账户管理|处理交易|账户号码|交易详情|
|网络搜索|找出相关网页|关键字|网页名称|
|编译器|找出符号的类型和值|变量名|类型和值|

###3.1.1　API

符号表是一种典型的**抽象数据类型**（请见第 1 章）：它代表着一组定义清晰的值以及相应的操作，使得我们能够将类型的实现和使用区分开来。和以前一样，我们要用应用程序编程接口（API）来精确地定义这些操作（如表 3.1.2 所示），为数据类型的实现和用例提供一份“契约”。

**表 3.1.2　一种简单的泛型符号表 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;public class&nbsp;&nbsp;<b>ST</b>&lt;Key, Value></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST()</code></td><td>创建一张符号表</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;put(Key key, Value val)</code></td><td>将键值对存入表中（若值为空则将键 <code>key</code> 从表中删除）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;get(Key key)</code></td><td>获取键 <code>key</code> 对应的值（若键 <code>key</code> 不存在则返回 <code>null</code>）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;delete(Key key)</code></td><td>从表中删去键 <code>key</code>（及其对应的值）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;contains(Key key)</code></td><td>键 <code>key</code> 在表中是否有对应的值</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isEmpty()</code></td><td>表是否为空</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size()</code></td><td>表中的键值对数量</td></tr>
<tr><td><code>Iterable&lt;Key>&nbsp;&nbsp;keys()</code></td><td>表中的所有键的集合</td></tr>
</table>

在查看用例代码之前，为了保证代码的一致、简洁和实用，我们要先说明具体实现中的几个设计决策。

####3.1.1.1　泛型

和排序一样，在设计方法时我们没有指定处理对象的类型，而是使用了泛型。对于符号表，我们通过明确地指定查找时键和值的类型来区分它们的不同角色，而不是像 2.4 节的优先队列那样将键和元素本身混为一谈。在考虑了这份基本的 API 后（例如，这里没有说明键的有序性），我们会用 `Comparable` 的对象来扩展典型的用例，这也会为数据类型带来许多新的方法。

####3.1.1.2　重复的键

我们的所有实现都遵循以下规则：

* 每个键只对应着一个值（表中不允许存在重复的键）；
* 当用例代码向表中存入的键值对和表中已有的键（及关联的值）冲突时，新的值会替代旧的值。

这些规则定义了**关联数组的抽象形式**。你可以将符号表想象成一个数组，键即索引，值即数组的元素。在一个一般的数组中，键就是整型的索引，我们用它来快速访问数组的内容；在一个关联数组（符号表）中，键可以是任意类型，但我们仍然可以用它来快速访问数组的内容。一些编程语言（非 Java）直接支持程序员使用 `st[key]` 来代替 `st.get(key)`，`st[key]=val` 来代替 `st.put(key, val)`，其中 `key`（键）和 `val`（值）都可以是任意类型的对象。

####3.1.1.3　空（null）键

键不能为空。和 Java 中的许多其他机制一样，使用空键会产生一个运行时异常（请见本节答疑的第三条）。

####3.1.1.4　空（null）值

我们还规定不允许有空值。这个规定的直接原因是在我们的 API 定义中，当键不存在时 `get()` 方法会返回空，这也意味着任何不在表中的键关联的值都是空。这个规定产生了两个（我们所期望的）结果：第一，我们可以用 `get()` 方法是否返回空来测试给定的键是否存在于符号表中；第二，我们可以将空值作为 `put()` 方法的第二个参数存入表中来实现删除，也就是 3.1.1.5 节的主要内容。

####3.1.1.5　删除操作

在符号表中，删除的实现可以有两种方法：**延时**删除，也就是将键对应的值置为空，然后在某个时候删去所有值为空的键；或是**即时**删除，也就是立刻从表中删除指定的键。刚才已经说过，`put(key, null)` 是 `delete(key)` 的一种简单的（延时型）实现。而实现（即时型）`delete()` 就是为了替代这种默认的方案。在我们的符号表实现中不会使用默认的方案，而在本书的网站上 `put()` 实现的开头有这样一句防御性代码：

```
if (val == null) { delete(key); return; }
```

这保证了符号表中任何键的值都不为空。为了节省版面我们没有在本书中附上这段代码（我们也不会在调用 `put()` 时使用 `null`）。

####3.1.1.6　便捷方法

为了用例代码的清晰，我们在 API 中加入了 `contains()` 和 `isEmpty()` 方法，它们的实现如表 3.1.3 所示，只需要一行。

**表 3.1.3　默认实现**

|方法|默认实现|
|-|-|
|`void delete(Key key)`|`put(key, null);`|
|`boolean contains(key key)`|`return get(key) != null;`|
|`boolean isEmpty()`|`return size() == 0;`|

为节省篇幅，我们不想重复这些代码，但我们约定它们存在于所有符号表 API 的实现中，用例程序可以自由使用它们。

####3.1.1.7　迭代

为了方便用例处理表中的所有键值，我们有时会在 API 的第一行加上 `implementsIterable<Key>` 这句话，强制所有实现都必须包含 `iterator()` 方法来返回一个实现了 `hasNext()` 和 `next()` 方法的迭代器，如 1.3 节的栈和队列所述。但是对于符号表我们采用了一个更简单的方法。我们定义了 `keys()` 方法来返回一个 `Iterable<Key>` 对象以方便用例遍历所有的键。这么做是为了和以后的有序符号表的所有方法保持一致，使得用例可以遍历表的键集的一个指定的部分。

####3.1.1.8　键的等价性

要确定一个给定的键是否存在于符号表中，首先要确立**对象等价性**的概念。我们在 1.2.5.8 节深入讨论过这一点。在 Java 中，按照约定所有的对象都继承了一个 `equals()` 方法，Java 也为它的标准数据类型例如 `Integer`、`Double` 和 `String` 以及一些更加复杂的类型，如 `File` 和 `URL`，实现了 `equals()` 方法——当使用这些数据类型时你可以直接使用内置的实现。例如，如果 x 和 y 都是 `String` 类型，当且仅当 `x` 和 `y` 的长度相同且每个位置上的字母都相同时，`x.equals(y)` 返回 `true`。而自定义的键则需要如 1.2 节所述重写 `equals()` 方法。你可以参考我们为 `Date` 类型（请见 1.2.5.8 节）实现的 `equals()` 方法为你自己的数据类型实现 `equals()` 方法。和 2.4.4.5 节中讨论的优先队列一样，最好使用不可变的数据类型作为键，否则表的一致性是无法保证的。

###3.1.2　有序符号表

典型的应用程序中，键都是 `Comparable` 的对象，因此可以使用 `a.compareTo(b)` 来比较 `a` 和 `b` 两个键。许多符号表的实现都利用了 `Comparable` 接口带来的键的有序性来更好地实现 `put()` 和 `get()` 方法。更重要的是在这些实现中，我们可以认为**符号表都会保持键的有序**并大大扩展它的 API，根据键的相对位置定义更多实用的操作。例如，假设键是时间，你可能会对最早的或是最晚的键或是给定时间段内的所有键等感兴趣。在大多数情况下用实现 `put()` 和 `get()` 方法背后的数据结构都不难实现这些操作。于是，对于 `Comparable` 的键，在本章中我们实现了表 3.1.4 中的 API。

**表 3.1.4　一种有序的泛型符号表的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>&nbsp;public class <b>ST</b>&lt;Key extends Comparable&lt;key>, Value></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ST()</code></td><td>创建一张有序符号表</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void put(Key key, Value val)</code></td><td>将键值对存入表中（若值为空则将键 <code>key</code> 从表中删除）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value get(Key key)</code></td><td>获取键 <code>key</code> 对应的值（若键 <code>key</code> 不存在则返回空）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void delete(Key key)</code></td><td>从表中删去键 <code>key</code>（及其对应的值）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean contains(Key key)</code></td><td>键 <code>key</code> 是否存在于表中</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean isEmpty()</code></td><td>表是否为空</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size()</code></td><td>表中的键值对数量</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key min()</code></td><td>最小的键</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key max()</code></td><td>最大的键</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key floor(Key key)</code></td><td>小于等于 <code>key</code> 的最大键</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key ceiling(Key key)</code></td><td>大于等于 <code>key</code> 的最小键</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rank(Key key)</code></td><td>小于 <code>key</code> 的键的数量</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key select(int k)</code></td><td>排名为 <code>k</code> 的键</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;deleteMin()</code></td><td>删除最小的键</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;deleteMax()</code></td><td>删除最大的键</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size(Key lo, Key hi)</code></td><td><code>[lo..hi]</code> 之间键的数量</td></tr>
<tr><td><code>Iterable&lt;Key>&nbsp;&nbsp;keys(Key lo, Key hi)</code></td><td><code>[lo..hi]</code> 之间的所有键，已排序</td></tr>
<tr><td><code>Iterable&lt;Key>&nbsp;&nbsp;keys()</code></td><td>表中的所有键的集合，已排序</td></tr>
</table>

只要你见到类的声明中含有泛型变量 `Key extends Comparable<Key>`，那就说明这段程序是在实现这份 API，其中的代码依赖于 `Comparable` 的键并且实现了更加丰富的操作。上面所有这些操作一起为用例定义了一个**有序符号表**。

####3.1.2.1　最大键和最小键

对于一组有序的键，最自然的反应就是查询其中的最大键和最小键。我们在 2.4 节讨论优先队列时已经遇到过这些操作。在有序符号表中，我们也有方法删除最大键和最小键（以及它们所关联的值）。有了这些，符号表就具有了类似于 2.4 节中 `IndexMinPQ()` 的能力。主要的区别在于优先队列中可以存在重复的键但符号表中不行，而且有序符号表支持的操作更多。

####3.1.2.2　向下取整和向上取整

对于给定的键，**向下取整**（floor）操作（找出小于等于该键的最大键）和**向上取整**（ceiling）操作（找出大于等于该键的最小键）有时是很有用的。这两个术语来自于实数的取整函数（对一个实数 ![x](https://private.codecogs.com/gif.latex?x) 向下取整即为小于等于 ![x](https://private.codecogs.com/gif.latex?x) 的最大整数，向上取整则为大于等于 ![x](https://private.codecogs.com/gif.latex?x) 的最小整数）。

####3.1.2.3　排名和选择

检验一个新的键是否插入合适位置的基本操作是**排名**（rank，找出小于指定键的键的数量）和**选择**（select，找出排名为 ![k](https://private.codecogs.com/gif.latex?k) 的键）。要测试一下你是否完全理解了它们的作用，请确认对于 0 到 `size()-1` 的所有 `i` 都有 `i==rank(select(i))`，且所有的键都满足 `key==select(rank(key))`。2.5 节中我们在学习排序时已经遇到过对这两种操作的需求了。对于符号表，我们的挑战是在实现插入、删除和查找的同时快速实现这两种操作。

有序符号表的操作示例如表 3.1.5 所示。

**表 3.1.5　有序符号表的操作示例**

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.001.png)

####3.1.2.4　范围查找

给定范围内（在两个给定的键之间）有多少键？是哪些？在很多应用中能够回答这些问题并接受两个参数的 `size()` 和 `keys()` 方法都很有用，特别是在大型数据库中。能够处理这类查询是有序符号表在实践中被广泛应用的重要原因之一。

####3.1.2.5　例外情况

当一个方法需要返回一个键但表中却没有合适的键可以返回时，我们约定抛出一个异常（另一种合理的方法是在这种情况下返回空）。例如，在符号表为空时，`min()`、`max()`、`deleteMin()`、`deleteMax()`、`floor()` 和 `ceiling()` 都会抛出异常，当 `k<0` 或 `k>=size()` 时 `select(k)` 也会抛出异常。

####3.1.2.6　便捷方法

在基础 API 中我们已经见过了 `contains()` 和 `isEmpty()` 方法，为了用例的清晰我们又在 API 中添加了一些冗余的方法。为了节约版面，除非特别声明，我们约定所有有序符号表 API 的实现都含有如表 3.1.6 所示的方法。

**表 3.1.6　有序符号表中冗余有序性方法的默认实现**

|方法|默认的实现|
|-|-|
|`void deleteMin()`|`delete(min());`|
|`void deleteMax()`|`delete(max());`|
|`int size(Key lo, Key hi)`|<pre>if (hi.compareTo(lo) < 0)<br>   return 0;<br>else if (contains(hi))<br>   return rank(hi) - rank(lo) + 1;<br>else<br>   return rank(hi) - rank(lo);</pre>|
|`Iterable<Key> keys()`|`return keys(min(), max());`|

####3.1.2.7　（再谈）键的等价性

Java 的一条最佳实践就是维护所有 `Comparable` 类型中 `compareTo()` 方法和 `equals()` 方法的一致性。也就是说，任何一种 `Comparable` 类型的两个值 `a` 和 `b` 都要保证 `(a.compareTo(b)==0)` 和 `a.equals(b)` 的返回值相同。为了避免任何潜在的二义性，我们不会在有序符号表的实现中使用 `equals()` 方法。作为替代，我们只会使用 `compareTo()` 方法来比较两个键，即我们用布尔表达式 `a.compareTo(b)==0` 来表示“`a` 和 `b` 相等吗？”。一般来说，这样的比较都代表着在符号表中的一次成功查找（找到了 `b`）。和排序算法一样，Java 为许多经常作为键的数据类型提供了标准的 `compareTo()` 方法，为你自定义的数据类型实现一个 `compareTo()` 方法也不困难（参见 2.5 节）。

####3.1.2.8　成本模型

无论我们是使用 `equals()` 方法（对于符号表的键不是 `Comparable` 对象而言）还是 `compareTo()` 方法（对于符号表的键是 `Comparable` 对象而言），我们使用**比较**一词来表示将一个符号表条目和一个被查找的键进行比较操作。在大多数的符号表实现中，这个操作都出现在内循环。在少数的例外中，我们则会统计数组的访问次数。

>**查找的成本模型**。在学习符号表的实现时，我们会统计**比较**的次数（等价性测试或是键的相互比较）。在内循环不进行比较（极少）的情况下，我们会统计**数组的访问次数**。

符号表实现的重点在于其中使用的数据结构和 `get()`、`put()` 方法。在下文中我们不会总是给出其他方法的实现，因为将它们作为练习能够更好地检验你对实现背后的数据结构的理解程度。为了区别不同的实现，我们在特定的符号表实现的类名前加上了描述性前缀。在用例代码中，除非我们想使用一个特定的实现，我们都会使用 `ST` 表示一个符号表实现。在本章和其他章节中，经过学习和讨论过大量符号表的使用和实现后你会慢慢地理解这些 API 的设计初衷。同时我们也会在答疑和练习中讨论算法设计时的更多选择。

###3.1.3　用例举例

虽然我们会在 3.5 节中详细说明符号表的更多应用，在学习它的实现之前我们还是应该先看看如何使用它。相应地我们这里考察两个用例：一个用来跟踪算法在小规模输入下的行为测试用例，和一个用来寻找更高效的实现的性能测试用例。

####3.1.3.1　行为测试用例

为了在小规模的输入下跟踪算法的行为，我们用以下测试用例测试我们对符号表的所有实现。这段代码会从标准输入接受多个字符串，构造一张符号表来将 `i` 和第 `i` 个字符串相关联，然后打印符号表。在本书中我们假设所有的字符串都只有一个字母。一般我们会使用 `"S E A R C H E X A M P L E"`。按照我们的约定，用例会将键 `S` 和 `0`，键 `R` 和 `3` 关联起来，等等。但 `E` 的值是 `12`（而非 `1` 或者 `6`），`A` 的值为 `8`（而非 `2`），因为我们的关联型数组意味着每个键的值取决于最近一次 `put()` 方法的调用。对于符号表的简单实现（无序），用例的输出中键的顺序是不确定的（这和具体实现有关）；对于有序符号表，用例应该将键按顺序打印出来。这是一种**索引**用例，它是我们将在 3.5 节中讨论的一种重要的符号表应用的一个特殊情况。

测试用例的实现代码如下所示。测试用例的键、值及输出如图 3.1.1 所示。

```
public static void main(String[] args)
{
   ST<String, Integer> st;
   st = new ST<String, Integer>();

   for (int i = 0; !StdIn.isEmpty(); i++)
   {
      String key = StdIn.readString();
      st.put(key, i);
   }

   for (String s : st.keys())
      StdOut.println(s + " " + st.get(s));
}
```

{-:-}简单的符号表测试用例

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.002.png)

**图 3.1.1　测试用例的键、值和输出**

####3.1.3.2　性能测试用例

`FrequencyCounter` 用例会从标准输入中得到的一列字符串并记录每个（长度至少达到指定的阈值）字符串的出现次数，然后遍历所有键并找出出现频率最高的键。这是一种**字典**，我们会在 3.5 节中更加详细地讨论这种应用。这个用例回答了一个简单的问题：哪个（不小于指定长度的）单词在一段文字中出现的频率最高？在本章中，我们会用这个用例以及三段文字来进行性能测试：狄更斯的《双城记》中的前五行（tinyTale.txt），《双城记》全书（tale.txt），以及一个知名的叫做 Leipzig Corpora Collection 的数据库（leipzig1M.txt），内容为一百万条随机从网络上抽取的句子。例如，这是 tinyTale.txt 的内容：

```
% more tinyTale.txt
it was the best of times it was the worst of times
it was the age of wisdom it was the age of foolishness
it was the epoch of belief it was the epoch of incredulity
it was the season of light it was the season of darkness
it was the spring of hope it was the winter of despair
```

{-:-}小型测试输入

这段文字共有 60 个单词，去掉重复的单词还剩 20 个，其中 4 个出现了 10 次（频率最高）。对于这段文字，`FrequencyCounter` 可能会打印出 it、was、the 或者 of 中的某一个单词（具体会打印出哪一个取决于符号表的具体实现），以及它出现的频率 10。表 3.1.7 总结了大型测试输入流的性质。

**表 3.1.7　大型测试输入流的性质**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="2"></th><th colspan="2">tinyTale.txt</th><th colspan="2">tale.txt</th><th colspan="2">leipzig1M.txt</th></tr>
<tr><th>单词数</th><th>不同的单词数</th><th>单词数</th><th>不同的单词数</th><th>单词数</th><th>不同的单词数</th></tr>
<tr><td>所有单词</td><td>60</td><td>20</td><td>135 635</td><td>10 679</td><td>21 191 455</td><td>534 580</td></tr>
<tr><td>长度大于等于 8 的单词</td><td>3</td><td>3</td><td>14 350</td><td>5 131</td><td>4 239 597</td><td>299 593</td></tr>
<tr><td>长度大于等于 10 的单词</td><td>2</td><td>2</td><td>4 582</td><td>2 260</td><td>1 610 829</td><td>165 555</td></tr>
</table>

`FrequencyCounter` 用例实现过程如下所示。

>**符号表的用例**

>```
>public class FrequencyCounter
>
>{
>
>    public static void main(String[] args)
>
>    {
>
>       int minlen = Integer.parseInt(args[0]);   // 最小键长
>
>       ST<String, Integer> st = new ST<String, Integer>();
>
>       while (!StdIn.isEmpty())
>
>       {  // 构造符号表并统计频率
>
>          String word = StdIn.readString();
>
>          if (word.length() < minlen) continue;  // 忽略较短的单词
>
>          if (!st.contains(word)) st.put(word, 1);
>
>          else                    st.put(word, st.get(word) + 1);
>
>       }
>
>       // 找出出现频率最高的单词
>
>       String max = " ";
>
>       st.put(max, 0);
>
>       for (String word : st.keys())
>
>          if (st.get(word) > st.get(max))
>
>             max = word;
>
>       StdOut.println(max + " " + st.get(max));
>
>    }
>
>}
>```

>这个符号表的用例统计了标准输入中各个单词的出现频率，然后将频率最高的单词打印出来。命令行参数指定了表中的键的最短长度。

>```
>% java FrequencyCounter 1 < tinyTale.txt
>it 10
>
>% java FrequencyCounter 8 < tale.txt
>business 122
>
>% java FrequencyCounter 10 < leipzig1M.txt
>government 24763
>```

研究符号表处理大型文本的性能要考虑两个方面的因素：首先，每个单词都会被作为键进行搜索，因此处理性能和输入文本的单词总量必然有关；其次，输入的每个单词都会被存入符号表（输入中不重复单词的总数也就是所有键都被插入以后符号表的大小），因此输入流中不同的单词的总数也是相关的。我们需要这两个量来估计 `FrequencyCounter` 的运行时间（作为开始，请见练习 3.1.6）。我们会在学习了一些算法之后再回头说明一些细节，但你应该对类似这样的符号表应用的需求有一个大致的印象。例如，用 `FrequencyCounter` 分析 leipzig1M.txt 中长度不小于 8 的单词意味着，在一个含有数十万键值对的符号表中进行上百万次的查找，而互联网中的一台服务器可能需要在含有上百万个键值对的表中处理上亿的交易。

这个用例和所有这些例子都提出了一个简单的问题：我们的实现能够在一张用多次 `get()` 和 `put()` 方法构造出的巨型符号表中进行大量的 `get()` 操作吗？如果我们的查找操作不多，那么任意实现都能够满足需要。但没有一个高效的符号表作为基础是无法使用 `FrequencyCounter` 这样的程序来处理大型问题的。`FrequencyCounter` 是一种极为常见的应用的代表，它的这些特性也是许多其他符号表应用的共性：

* 混合使用查找和插入的操作；
* 大量的不同键；
* 查找操作比插入操作多得多；
* 虽然不可预测，但查找和插入操作的使用模式并非随机。

我们的目标就是实现一种符号表来满足这些能够解决典型的实际问题的用例的需要。

下面，我们将会学习两种初级的符号表实现并通过 `FrequencyCounter` 分别评估它们的性能。在之后的几节中，你会学习一些经典的实现，即使对于庞大的输入和符号表它们的性能仍然非常优秀。

###3.1.4　无序链表中的顺序查找

符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对，如算法 3.1 中的代码所示。`get()` 的实现即为遍历链表，用 `equals()` 方法比较需被查找的键和每个结点中的键。如果匹配成功我们就返回相应的值，否则我们返回 `null`。`put()` 的实现也是遍历链表，用 `equals()` 方法比较需被查找的键和每个结点中的键。如果匹配成功我们就用第二个参数指定的值更新和该键相关联的值，否则我们就用给定的键值对创建一个新的结点并将其插入到链表的开头。这种方法也被称为**顺序查找**：在查找中我们一个一个地顺序遍历符号表中的所有键并使用 `equals()` 方法来寻找与被查找的键匹配的键。

算法 3.1（`SequentialSearchST`）用链表实现了符号表的基本 API，我们在第 1 章中的基础数据结构中学习过它。这里我们将 `size()`、`keys()` 和即时型的 `delete()` 方法留做练习。这些练习能够巩固并加深你对链表和符号表的基本 API 的理解。

这种基于链表的实现能够用于和我们的用例类似的、需要大型符号表的应用吗？我们已经说过，分析符号表算法比分析排序算法更困难，因为不同的用例所进行的操作序列各不相同。对于 `FrequencyCounter`，最常见的情形是虽然查找和插入的使用模式是不可预测的，但它们的使用肯定不是随机的。因此我们主要研究最坏情况下的性能。为了方便，我们使用**命中**表示一次成功的查找，**未命中**表示一次失败的查找。使用基于链表的符号表的索引用例的轨迹如图 3.1.2 所示。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.003.png)

**图 3.1.2　使用基于链表的符号表的索引用例的轨迹**

>**算法 3.1　顺序查找（基于无序链表）**

>```
>public class SequentialSearchST<Key, Value>
>
>{
>
>    private Node first;        // 链表首结点
>
>    private class Node
>
>    {  // 链表结点的定义
>
>       Key key;
>
>       Value val;
>
>       Node next;
>
>       public Node(Key key, Value val, Node next)
>
>       {
>
>          this.key  = key;
>
>          this.val  = val;
>
>          this.next = next;
>
>       }
>
>    }
>
>    public Value get(Key key)
>
>    {  // 查找给定的键，返回相关联的值
>
>       for (Node x = first; x != null; x = x.next)
>
>          if (key.equals(x.key))
>
>             return x.val;    // 命中
>
>       return null;           // 未名中
>
>    }
>
>    public void put(Key key, Value val)
>
>    {  // 查找给定的键，找到则更新其值，否则在表中新建结点
>
>       for (Node x = first; x != null; x = x.next)
>
>          if (key.equals(x.key))
>
>          {  x.val = val; return;  }      // 命中，更新
>
>       first = new Node(key, val, first); // 未命中，新建结点
>
>    }
>
>}
>```

>符号表的实现使用了一个私有内部 `Node` 类来在链表中保存键和值。`get()` 的实现会顺序地搜索链表查找给定的键（找到则返回相关联的值）。`put()` 的实现也会顺序地搜索链表查找给定的键，如果找到则更新相关联的值，否则它会用给定的键值对创建一个新的结点并将其插入到链表的开头。`size()`、`keys()` 和即时型的 `delete()` 方法的实现留做练习。

　

>**命题 A**。在含有 ![N](https://private.codecogs.com/gif.latex?N) 对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要 ![N](https://private.codecogs.com/gif.latex?N) 次比较。命中的查找在最坏情况下需要 ![N](https://private.codecogs.com/gif.latex?N) 次比较。特别地，向一个空表中插入 ![N](https://private.codecogs.com/gif.latex?N) 个不同的键需要 ![\sim N^2/2](https://private.codecogs.com/gif.latex?\sim%20N^2/2) 次比较。

>**证明**。在表中查找一个不存在的键时，我们会将表中的每个键和给定的键比较。因为不允许出现重复的键，每次插入操作之前我们都需要这样查找一遍。

　

>**推论**。向一个空表中插入 ![N](https://private.codecogs.com/gif.latex?N) 个不同的键需要 ![\sim N^2/2](https://private.codecogs.com/gif.latex?\sim%20N^2/2) 次比较。

查找一个已经存在的键并不需要线性级别的时间。一种度量方法是查找表中的每个键，并将总时间除以 ![N](https://private.codecogs.com/gif.latex?N)。在查找表中的每个键的可能性都相同的情况下时，这个结果就是一次查找平均所需的比较数。我们将它称为**随机命中**。尽管符号表用例的查找模式不太可能是随机的，这个模型也总能适应得很好。我们很容易就可以得到随机命中所需的平均比较次数为 ![\sim N/2](https://private.codecogs.com/gif.latex?\sim%20N/2)：算法 3.1 中的 `get()` 方法查找第一个键需要 1 次比较，查找第二个键需要 2 次比较，如此这般，平均比较次数为 ![(1+2+\cdots+N)/N=(N+1)/2\sim N/2](https://private.codecogs.com/gif.latex?(1+2+\cdots+N%29/N=(N+1%29/2\sim%20N/2)。

这些分析完全证明了基于链表的实现以及顺序查找是非常低效的，无法满足 `FrequencyCounter` 处理庞大输入问题的需求。比较的总次数和查找次数与插入次数的乘积成正比。对于《双城记》这个数字大于 ![10^9](https://private.codecogs.com/gif.latex?10^9)，而对于 Leipzig Corpora 数据库这个数字大于 10***14***。

按照惯例，为了验证分析结果我们需要进行一些实验。这里我们用 `FrequencyCounter` 以及命令行参数 8 来分析 tale.txt。这将需要 14 350 次 `put()`（已经说过，输入中的每个单词都需要一次 `put()` 操作来更新它的出现频率，`contains()` 方法的调用是可以避免的，这里忽略了它的成本）。符号表将包含 5737 个键，也就是说大约三分之一的操作都将表增大了，其余操作为查找。为了将性能可视化我们使用了 `VisualAccumulator`（请见表 1.2.14）将每次 `put()` 操作转换为两个点：对于第 ![i](https://private.codecogs.com/gif.latex?i) 次 `put()` 操作，我们会在横坐标为 ![i](https://private.codecogs.com/gif.latex?i)，纵坐标为该次操作所进行的比较次数的位置画一个灰点，以及横坐标为 ![i](https://private.codecogs.com/gif.latex?i)，纵坐标为前 ![i](https://private.codecogs.com/gif.latex?i) 次 `put()` 操作累计所需的平均比较次数的位置画一个黑点，如图 3.1.3 所示。和所有科学实验数据一样，这其中包含了很多信息供我们研究（这张图含有 14 350 个灰点和 14 350 个黑点）。这里，我们的主要兴趣在于这张表证实了我们关于 `put()` 平均需要访问半条链表的猜想。虽然实际的数据比一半稍少，但对这个事实（以及图表曲线的形状）最好的解释应该是应用的特性，而非算法（请见练习 3.1.36）。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.004.png)

**图 3.1.3　使用 `SequentialSearchST`，运行 `java FrequencyCounter 8 < tale.txt` 的成本**

尽管某个具体用例的性能特点可能是复杂的，但只要使用我们准备的文本或者随机有序输入以及我们在第 1 章中介绍的 DoublingTest 程序，我们还是能够轻松估计出 `FrequencyCounter` 的性能并测试验证的。我们将这些测试留给练习和接下来将要学习的更加复杂的实现。如果你并不觉得我们需要更快的实现，请一定完成这些练习！（或者用 `FrequencyCounter` 调用 `SequentialSearchST` 来处理 leipzig1M.txt ！）

###3.1.5　有序数组中的二分查找

下面我们要学习有序符号表 API 的完整实现。它使用的数据结构是一对平行的数组，一个存储键一个存储值。算法 3.2（`BinarySearchST`）可以保证数组中 `Comparable` 类型的键有序，然后使用数组的索引来高效地实现 `get()` 和其他操作。

这份实现的核心是 `rank()` 方法，它返回表中小于给定键的键的数量。对于 `get()` 方法，只要给定的键存在于表中，`rank()` 方法就能够精确地告诉我们在哪里能够找到它（如果找不到，那它肯定就**不在**表中了）。

对于 `put()` 方法，只要给定的键存在于表中，`rank()` 方法就能够精确地告诉我们到哪里去更新它的值，以及当键不在表中时将键存储到表的何处。我们将所有更大的键向后移动一格来腾出位置（从后向前移动）并将给定的键值对分别插入到各自数组中的合适位置。结合我们测试用例的轨迹来研究 `BinarySearchST` 也是学习这种数据结构的好方法。

这段代码为键和值使用了两个数组（另一种方式请见练习 3.1.12）。和我们在第 1 章中对泛型的栈和队列的实现一样，这段代码也需要创建一个 `Key` 类型的 `Comparable` 对象的数组和一个 `Value` 类型的 `Object` 对象的数组，并在构造函数中将它们转化回 `Key[]` 和 `Value[]`。和以前一样，我们可以动态调整数组，使得用例无需担心数组大小（请注意，你会发现这种方法对于大数组实在是太慢了）。

使用基于有序数组的符号表实现的索引用例的轨迹如表 3.1.8 所示。

**表 3.1.8　使用基于有序数组的符号表实现的索引用例的轨迹**

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.005.png)

>**算法 3.2　二分查找（基于有序数组）**

>```
>public class BinarySearchST<Key extends Comparable<Key>, Value>
>{
>    private Key[] keys;
>    private Value[] vals;
>    private int N;
>    public BinarySearchST(int capacity)
>    {   // 调整数组大小的标准代码请见算法1.1
>        keys = (Key[]) new Comparable[capacity];
>        vals = (Value[]) new Object[capacity];
>    }
>    public int size()
>    {  return N;  }
>    public Value get(Key key)
>    {
>       if (isEmpty()) return null;
>       int i = rank(key);
>       if (i < N && keys[i].compareTo(key) == 0) return vals[i];
>       else                                      return null;
>    }
>
>    public int rank(Key key)
>    // 请见算法3.2（续1）
>
>    public void put(Key key, Value val)
>    {  // 查找键，找到则更新值，否则创建新的元素
>       int i = rank(key);
>       if (i < N && keys[i].compareTo(key) == 0)
>       {  vals[i] = val; return;  }
>       for (int j = N; j > i; j--)
>       {  keys[j] = keys[j-1]; vals[j] = vals[j-1];  }
>       keys[i] = key; vals[i] = val;
>       N++;
>    }
>
>    public void delete(Key key)
>    // 该方法的实现请见练习3.1.16
>}
>```

>这段符号表的实现用两个数组来保存键和值。和 1.3 节中基于数组的栈一样，`put()` 方法会在插入新元素前将所有较大的键向后移动一格。这里省略了调整数组大小部分的代码。

####3.1.5.1　二分查找

我们使用有序数组存储键的原因是，第 1 章中作为例子出现的经典二分查找法能够根据数组的索引大大减少每次查找所需的比较次数。我们会使用有序索引数组来标识被查找的键可能存在的子数组的大小范围。在查找时，我们先将被查找的键和子数组的中间键比较。如果被查找的键小于中间键，我们就在左子数组中继续查找，如果大于我们就在右子数组中继续查找，否则中间键就是我们要找的键。算法 3.2（续 1）中实现 `rank()` 方法的代码使用了刚才讨论的二分查找法。这个实现值得我们仔细研究。作为开始，我们来看看这段等价的递归代码。

```
public int rank(Key key, int lo, int hi)
{
   if (hi < lo) return lo;
   int mid = lo + (hi - lo) / 2;
   int cmp = key.compareTo(keys[mid]);
   if     (cmp < 0)
        return rank(key, lo, mid-1);
   else if (cmp > 0)
        return rank(key, mid+1, hi);
   else return mid;
}
```

{-:-}递归的二分查找

调用这里的 `rank(key, 0, N-1)` 所进行的比较和调用算法 3.2（续 1）的实现所进行的比较完全相同。但如 1.1 节中讨论的，这个版本更好地暴露了算法的结构。递归的 `rank()` 保留了以下性质：

* 如果表中存在该键，`rank()` 应该返回该键的位置，也就是表中小于它的键的数量；
* 如果表中不存在该键，`rank()` **还是**应该返回表中小于它的键的数量。

好好想想算法 3.2（续 1）中非递归的 `rank()` 为什么能够做到这些（你可以证明两个版本的等价性，或者直接证明非递归版本中的循环在结束时 `lo` 的值正好等于表中小于被查找的键的键的数量），所有程序员都能从这些思考中有所收获。（**提示**：`lo` 的初始值为 `0`，且永远不会变小）

>**算法 3.2（续 1）基于有序数组的二分查找（迭代）**

>```
>public int rank(Key key)
>{
>    int lo = 0, hi = N-1;
>    while (lo <= hi)
>    {
>       int mid = lo + (hi - lo) / 2;
>       int cmp = key.compareTo(keys[mid]);
>       if      (cmp < 0) hi = mid - 1;
>       else if (cmp > 0) lo = mid + 1;
>       else return mid;
>    }
>    return lo;
>}
>```

>该方法实现了正文所述的经典算法来计算小于给定键的键的数量。它首先将 `key` 和中间键比较，如果相等则返回其索引；如果小于中间键则在左半部分查找；大于则在右半部分查找。

>![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.006.png)

>{-:-}**在有序数组中使用二分法查找排名的轨迹**

　

>**算法 3.2（续 2）基于二分查找的有序符号表的其他操作**

>```
>public Key min()
>{  return keys[0];  }
>
>public Key max()
>{  return keys[N-1];  }
>
>public Key select(int k)
>{  return keys[k];  }
>
>public Key ceiling(Key key)
>{
>    int i = rank(key);
>    return keys[i];
>}
>
>public Key floor(Key key)
>// 请见练习3.1.17
>
>public Key delete(Key key)
>// 请见练习3.1.16
>
>public Iterable<Key> keys(Key lo, Key hi)
>{
>    Queue<Key> q = new Queue<Key>();
>    for (int i = rank(lo); i < rank(hi); i++)
>       q.enqueue(keys[i]);
>    if (contains(hi))
>       q.enqueue(keys[rank(hi)]);
>    return q;
>}
>```

>这些方法，以及练习 3.1.16 和练习 3.1.17，组成了我们对使用二分查找的有序符号表的完整实现。`min()`、`max()` 和 `select()` 方法都很简单，只需按照给定的位置从数组中返回相应的值即可。`rank()` 方法实现了二分查找，是其他方法的基石。`floor()` 和 `delete()` 方法虽然也不难，但稍微复杂一些，在此留做练习。

####3.1.5.2　其他操作

因为键被保存在有序数组中，算法 3.2（续 2）中和顺序有关的大多数操作都一目了然。例如，调用 `select(k)` 就相当于返回 `keys[k]`。我们将 `delete()` 和 `floor()` 留做练习。你应该研究一下 `ceiling()` 和带两个参数的 `keys()` 方法的实现，并完成练习来巩固和加深你对有序符号表的 API 及其实现的理解。

###3.1.6　对二分查找的分析

`rank()` 的递归实现还能够让我们立即得到一个结论：二分查找很快，因为递归关系可以说明算法所需比较次数的上界。

>**命题 B**。在 ![N](https://private.codecogs.com/gif.latex?N) 个键的有序数组中进行二分查找最多需要（![\lg N+1](https://private.codecogs.com/gif.latex?\lg%20N+1)）次比较（无论是否成功）。

>**证明**。这里的分析和对归并排序的分析（第 2 章的命题 F）类似（但相对简单）。令 ![C(N)](https://private.codecogs.com/gif.latex?C(N%29) 为在大小为 ![N](https://private.codecogs.com/gif.latex?N) 的符号表中查找一个键所需进行的比较次数。显然我们有 ![C(0)=0](https://private.codecogs.com/gif.latex?C(0%29=0)，![C(1)=1](https://private.codecogs.com/gif.latex?C(1%29=1)，且对于 ![N>0](https://private.codecogs.com/gif.latex?N%3E0) 我们可以写出一个和递归方法直接对应的归纳关系式：

>![C(N)\leqslant\lfloor N/2\rfloor+1](https://private.codecogs.com/gif.latex?C(N%29\leqslant\lfloor%20N/2\rfloor+1)

>无论查找会在中间元素的左侧还是右侧继续，子数组的大小都不会超过 ![\lfloor N/2\rfloor](https://private.codecogs.com/gif.latex?\lfloor%20N/2\rfloor)，我们需要一次比较来检查中间元素和被查找的键是否相等，并决定继续查找左侧还是右侧的子数组。当 ![N](https://private.codecogs.com/gif.latex?N) 为 2 的幂减 1 时（![N=2^n-1](https://private.codecogs.com/gif.latex?N=2^n-1)），这种递推很容易。首先，因为 ![\lfloor N/2\rfloor=2^{n-1}-1](https://private.codecogs.com/gif.latex?\lfloor%20N/2\rfloor=2^{n-1}-1)，所以我们有：

>![C(2^n-1)\leqslant C(2^{n-1}-1)+1](https://private.codecogs.com/gif.latex?C(2^n-1%29\leqslant%20C(2^{n-1}-1%29+1)

>用这个公式代换不等式右边的第一项可得：

>![C(2^n-1)\leqslant C(2^{n-2}-1)+1+1](https://private.codecogs.com/gif.latex?C(2^n-1%29\leqslant%20C(2^{n-2}-1%29+1+1)

>将上面这一步重复 ![k-2](https://private.codecogs.com/gif.latex?k-2) 次可得：

>![C(2^n-1)\leqslant C(2^0)+n](https://private.codecogs.com/gif.latex?C(2^n-1%29\leqslant%20C(2^0%29+n)

>最后的结果即：

>![C(N)=C(2^n)\leqslant n+1<\lg N+1](https://private.codecogs.com/gif.latex?C(N%29=C(2^n%29\leqslant%20n+1<\lg%20N+1)

>对于一般的 ![N](https://private.codecogs.com/gif.latex?N)，确切的结论更加复杂，但不难通过以上论证推广得到（请见练习 3.1.20）。二分查找所需时间必然在对数范围之内。

刚才给出的实现中，`ceiling()` 只是调用了一次 `rank()`，而接受两个参数的默认 `size()` 方法调用了两次 `rank()`，因此这份证明也保证了这些操作（包括 `floor()`）所需的时间最多是对数级别的（`min()`、`max()` 和 `select()` 操作所需的时间都是常数级别的）。

尽管能够保证查找所需的时间是对数级别的，`BinarySearchST` 仍然无法支持我们用类似 `FrequencyCounter` 的程序来处理大型问题，因为 `put()` 方法还是太慢了。二分查找减少了比较的次数但无法减少运行所需时间，因为它无法改变以下事实：在键是随机排列的情况下，构造一个基于有序数组的符号表所需要访问数组的次数是数组长度的平方级别（在实际情况下键的排列虽然不是随机的，但仍然很好地符合这个模型）。`BinarySearchST` 的操作的成本如表 3.1.9 所示。

**表 3.1.9　BinarySearchST 的操作的成本**

|方法|运行所需时间的增长数量级|
|-|-|
|`put()`|![N](https://private.codecogs.com/gif.latex?N)|
|`get()`|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|
|`delete()`|![N](https://private.codecogs.com/gif.latex?N)|
|`contains()`|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|
|`size()`|1|
|`min()`|1|
|`max()`|1|
|`floor()`|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|
|`ceiling()`|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|
|`rank()`|![\log N](https://private.codecogs.com/gif.latex?\log%20N)|
|`select()`|1|
|`deleteMin()`|![N](https://private.codecogs.com/gif.latex?N)|
|`deleteMax()`|1|

>**命题 B（续）**。向大小为 ![N](https://private.codecogs.com/gif.latex?N) 的有序数组中插入一个新的元素在最坏情况下需要访问 ![\sim2N](https://private.codecogs.com/gif.latex?\sim2N) 次数组，因此向一个空符号表中插入 ![N](https://private.codecogs.com/gif.latex?N) 个元素在最坏情况下需要访问 ![\sim N^2](https://private.codecogs.com/gif.latex?\sim%20N^2) 次数组。

>**证明**。同命题 A。

对于含有 ![10^4](https://private.codecogs.com/gif.latex?10^4) 个不同键的《双城记》，构建符号表需要访问数组约 ![10^8](https://private.codecogs.com/gif.latex?10^8) 次；而对于含有 ![10^6](https://private.codecogs.com/gif.latex?10^6) 个不同键的 Leipzig 项目则需要访问数组 ![10^{11} ](https://private.codecogs.com/gif.latex?10^{11}) 次。虽然现代计算机可勉强实现，但这样的成本还是过高了。

回头看看 `FrequencyCounter` 在参数为 8 时 `put()` 操作的性能，我们可以看到平均情况下的比较次数（包括访问数组的次数）从 `SequentialSearchST` 的 2246 次降低到了 `BinarySearchST` 的 484 次（如图 3.1.4 所示）。这比我们在分析中预测的还要更好，额外的部分可能能够再次通过应用的性质得到解释（请见练习 3.1.36）。这次改进令人印象深刻，但你会看到，我们还能做得更好。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.007.png)

**图 3.1.4　使用 `BinarySearchST`，运行 `java FrequencyCounter 8 < tale.txt` 的成本**

###3.1.7　预览

一般情况下二分查找都比顺序查找快得多，它也是众多实际应用程序的最佳选择。对于一个静态表（不允许插入）来说，将其在初始化时就排序是值得的，如第 1 章中的二分查找所示（请见表 1.2.15）。即使查找前所有的键值对已知（这在应用程序中是一种常见的情况），为 `BinarySearchST` 添加一个能够初始化并将符号表排序的构造函数也是有意义的（请见练习 3.1.12）。当然，二分查找也不适合很多应用。例如，它无法处理 Leipzig Corpora 数据库，因为查找和插入操作是混合进行的，而且符号表也太大了。如我们所强调的那样，现代应用需要**同时**能够支持高效的查找和插入两种操作的符号表实现。也就是说，我们需要在构造庞大的符号表的同时能够任意插入（也许还有删除）键值对，同时也要能够完成查找操作。

表 3.1.10 给出了本节中介绍的符号表的初级实现的性能特点。表中给出的是总成本中的最高级项（对于二分查找是数组的访问次数，对于其他则是比较次数），即运行时间的增长数量级。

**表 3.1.10　简单的符号表实现的成本总结**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="2">算法（数据结构）</th><th colspan="2">最坏情况下的成本（<i>N</i> 次插入后）</th><th colspan="2">平均情况下的成本（<i>N</i> 次随机插入后）</th><th rowspan="2">是否高效地支持有序性相关的操作</th></tr>
<tr><th>查找</th><th>插入</th><th>查找</th><th>插入</th></tr>
<tr><td>顺序查找（无序链表）</td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N/2" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td>否</td></tr>
<tr><td>二分查找（有序数组）</td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?2N" /></td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td>是</td></tr>
</table>

核心的问题在于我们能否找到能够同时保证查找和插入操作都是对数级别的算法和数据结构。答案是令人兴奋的“可以”！这个答案也正是本章的重点所在。和第 2 章讨论的高效排序算法一样，能够高效地查找和插入的符号表是算法领域对世界最重要的贡献之一，也是我们今天能够享受的丰富计算性基础设施的开发基础。

我们如何能够实现这个目标呢？要支持高效的插入操作，我们似乎需要一种链式结构。但单链接的链表是无法使用二分查找法的，因为二分查找的高效来自于能够快速通过索引取得任何子数组的中间元素（但得到一条链表的中间元素的唯一方法只能是沿链表遍历）。为了将二分查找的效率和链表的灵活性结合起来，我们需要更加复杂的数据结构。能够同时拥有两者的就是**二叉查找树**，它也是我们下面两节的主题。我们会将**散列表**留到 3.4 节中讨论。

在本章中我们会学习 6 种符号表的实现，这里我们先给出一个简单的预览。表 3.1.11 包含一系列数据结构以及它们适用和不适用于某个应用场景的原因，按照我们学习它们的先后顺序排列。

**表 3.1.11　符号表的各种实现的优缺点**

|使用的数据结构|实现|优点|缺点|
|-|-|-|-|
|链表（顺序查找）|`SequentialSearchST`|适用于小型问题|对于大型符号表很慢|
|有序数组（二分查找）|`BinarySearchST`|最优的查找效率和空间需求，能够进行有序性相关的操作|插入操作很慢|
|二叉查找树|`BST`|实现简单，能够进行有序性相关的操作|没有性能上界的保证链接需要额外的空间|
|平衡二叉查找树|`RedBlackBST`|最优的查找和插入效率，能够进行有序性相关的操作|链接需要额外的空间|
|散列表|`SeparateChainHashST`<br>`LinearProbingHashST`|能够快速地查找和插入常见类型的数据|需要计算每种类型的数据的散列无法进行有序性相关的操作链接和空结点需要额外的空间|

在学习中我们会仔细了解每种算法和实现的各种性质，这里的简单特性是为了帮助你在学习它们的同时能够从全局的高度来理解它们。一句话，我们有若干种高效的符号表实现，它们能够并且已经被应用于无数程序之中了。

###答疑

**问**　为什么符号表不像 2.4 节中优先队列那样使用一个 `Comparable` 的 `Item` 类型，而是对于键和值使用不同的数据类型？

**答**　这的确是一种可行的办法。这两者代表了将键和值关联起来的两种不同方式——我们可以构造一种将键包含在其中的数据结构来**隐式**关联键值或是显式地将键和值区分开来。对于符号表，我们选择突出关联数组的抽象形式。同时也请注意，符号表的用例在查找时只会指定一个键，而非一个键值对。

**问**　为什么要用 `equals()` ？为什么不一直使用 `compareTo()` ？

**答**　并不是所有的数据产生的键值对都能够进行比较，尽管有时候将它们保存在符号表可以。举一个比较极端的例子，你可能会用一幅照片或者一首歌作为键，但没法比较它们，只能知道它们是否相等（也要花点儿工夫）。

**问**　为什么键的值不能为空（`null`）？

**答**　因为我们会用 `Key` 调用 `compareTo()` 或者 `equals()` 方法，因此我们假设它是一个 `Object`。但是当 `a` 为 `null` 时 `a.compareTo(b)` 会抛出一个空指针异常。如果能消除这种可能性，用例的代码能够更简单。

**问**　为什么不和排序一样使用一个类似于 `less()` 的方法？

**答**　在符号表中等价性比较特殊，因此我们还需要一个方法来测试等价性。为了避免增加本质上功能相同的方法，我们使用了 Java 内置的 `equals()` 和 `compareTo()`。

**问**　在 `BinarySearchST` 中的类型转换之前，为什么不将 `keys[]` 和 `vals[]` 一样声明为 `Object[]`（而是 `Comparable[]`）？

**答**　问得好。如果你这么做，你会得到一个 `ClassCastException`，因为键只能是 `Comparable` 的（以保证 `keys[]` 中的元素都有 `compareTo()` 方法）。因此将 `keys[]` 声明为 `Comparable[]` 是必需的。深入程序语言的设计细节来解释这里的原因可能会有些跑题。在本书所有使用泛型的 `Comparable` 对象和数组的代码中我们都会照此办理。

**问**　如果我们需要将多个值关联到同一个键怎么办？例如，如果我们在应用程序中用 Date 日期作为键，那不会需要处理重复的键吗？

**答**　可能会，也可能不会。例如，两列火车不可能同时在同一条轨道上到达同一个车站（但它们可以在不同的铁轨上同时到站）。处理这种情形有两个办法：用其他信息来消除重复或者使用 `Queue` 类型来存储所有有相同键的值。我们会在 3.5 节中详细讨论符号表的应用。

**问**　3.1.7 节中将表预排序的想法看起来是个好主意，为什么把它留作一道练习（请见练习 3.1.12）？

**答**　的确，在某些应用中它确实是最佳的选择。但在一个希望实现快速查找的数据结构中为了“图方便”而加入一个低效的插入方法会变成一个性能陷阱，因为一个普通用例可能会在一张很大的表中混合使用查找和插入操作却发现运行所需的时间是平方级别的。这种陷阱太常见了，因此当你使用他人开发的软件，尤其是接口繁多时，你应该加倍小心。当对象含有大量“便捷”方法而导致到处都是性能陷阱，而用例却可能认为所有的方法都同样高效时，这个问题就非常严重了。Java 的 `ArrayList` 类就是这样的一个例子（请见练习 3.5.27）。

###练习

**3.1.1**　编写一段程序，创建一张符号表并建立字母成绩和数值分数的对应关系，如下表所示。从标准输入读取一系列字母成绩，计算并打印 GPA（字母成绩对应的分数的平均值）。

<table class="table table-bordered table-striped table-condensed">
<tr><td>A+</td><td>A</td><td>A-</td><td>B+</td><td>B</td><td>B-</td><td>C+</td><td>C</td><td>C-</td><td>D</td><td>F</td></tr>
<tr><td>4.33</td><td>4.00</td><td>3.67</td><td>3.33</td><td>3.00</td><td>2.67</td><td>2.33</td><td>2.00</td><td>1.67</td><td>1.00</td><td>0.00</td></tr>
</table>

**3.1.2**　开发一个符号表的实现 `ArrayST`，使用（无序）数组来实现我们的基本 API。

**3.1.3**　开发一个符号表的实现 `OrderedSequentialSearchST`，使用有序链表来实现我们的有序符号表 API。

**3.1.4**　开发抽象数据类型 `Time` 和 `Event` 来处理表 3.1.5 中的例子中的数据。

**3.1.5**　实现 `SequentialSearchST` 中的 `size()`、`delete()` 和 `keys()` 方法。

**3.1.6**　用输入中的单词总数 ![W](https://private.codecogs.com/gif.latex?W) 和不同单词总数 ![D](https://private.codecogs.com/gif.latex?D) 的函数给出 `FrequencyCounter` 调用的 `put()` 和 `get()` 方法的次数。

**3.1.7**　对于 ![N=10](https://private.codecogs.com/gif.latex?N=10)、![10^2](https://private.codecogs.com/gif.latex?10^2)、![10^3](https://private.codecogs.com/gif.latex?10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)，在 ![N](https://private.codecogs.com/gif.latex?N) 个小于 1000 的随机非负整数中 `FrequencyCounter` 平均能够找到多少个不同的键？

**3.1.8**　在《双城记》中，使用频率最高的长度大于等于 10 的单词是什么？

**3.1.9**　在 `FrequencyCounter` 中添加追踪 `put()` 方法的**最后一次调用**的代码。打印出最后插入的那个单词以及在此之前总共从输入中处理了多少个单词。用你的程序处理 tale.txt 中长度分别大于等于 1、8 和 10 的单词。

**3.1.10**　给出用`SequentialSearchST` 将键`E A S Y Q U E S T I O N` 插入一个空符号表的过程的轨迹。一共进行了多少次比较？

**3.1.11**　给出用 `BinarySearchST` 将键 `E A S Y Q U E S T I O N` 插入一个空符号表的过程的轨迹。一共进行了多少次比较？

**3.1.12**　修改 `BinarySearchST`，用一个 `Item` 对象的数组而非两个平行数组来保存键和值。添加一个构造函数，接受一个 `Item` 的数组为参数并将其归并排序。

**3.1.13**　对于一个会随机混合进行 ![10^3](https://private.codecogs.com/gif.latex?10^3) 次 `put()` 和 ![10^6](https://private.codecogs.com/gif.latex?10^6) 次 `get()` 操作的应用程序，你会使用本节中的哪种符号表的实现？说明理由。

**3.1.14**　对于一个会随机混合进行 ![10^6](https://private.codecogs.com/gif.latex?10^2) 次 `put()` 和 ![10^3](https://private.codecogs.com/gif.latex?10^3) 次 `get()` 操作的应用程序，你会使用本节中的哪种符号表的实现？说明理由。

**3.1.15**　假设在一个 `BinarySearchST` 的用例程序中，查找操作的次数是插入操作的 1000 倍。当分别进行 ![10^3](https://private.codecogs.com/gif.latex?10^3)、![10^6](https://private.codecogs.com/gif.latex?10^6) 和 ![10^9](https://private.codecogs.com/gif.latex?10^9) 次查找时，请估计插入操作在总耗时中的比例。

**3.1.16**　为 `BinarySearchST` 实现 `delete()` 方法。

**3.1.17**　为 `BinarySearchST` 实现 `floor()` 方法。

**3.1.18**　证明 `BinarySearchST` 中 `rank()` 方法的实现的正确性。

**3.1.19**　修改 `FrequencyCounter`，打印出现频率最高的所有单词，而非其中之一。**提示**：请用 `Queue`。

**3.1.20**　补全命题 B 的证明（证明 ![N](https://private.codecogs.com/gif.latex?N) 的一般情况）。**提示**：先证明 ![C(N)](https://private.codecogs.com/gif.latex?C(N%29) 的单调性，即对于所有的 ![N>0](https://private.codecogs.com/gif.latex?N%3E0)，![C(N)\leqslant C(N+1)](https://private.codecogs.com/gif.latex?C(N%29\leqslant%20C(N+1%29)

###提高题

**3.1.21**　**内存使用**。基于 1.4 节中的假设，对于 ![N](https://private.codecogs.com/gif.latex?N) 对键值比较 `BinarySearchST` 和 `SequentialSearchST` 的内存使用情况。不需要记录键值本身占用的内存，只统计它们的引用。对于 `BinarySearchST`，假设数组大小可以动态调整，数组中被占用的空间比例为 25% ～ 100%。

**3.1.22**　**自组织查找**。自组织查找指的是一种能够将数组元素重新排序使得被访问频率较高的元素更容易被找到的查找算法。请修改你为练习 3.1.2 给出的答案，在每次查找命中时：将被找到的键值对移动到数组的开头，将所有中间的键值对向右移动一格。这个启发式的过程被称为**前移编码**。

**3.1.23**　**二分查找的分析**。请证明对于大小为 ![N](https://private.codecogs.com/gif.latex?N) 的符号表，一次二分查找所需的最大比较次数正好是 ![N](https://private.codecogs.com/gif.latex?N) 的二进制表示的位数，因为右移一位的操作会将二进制的 ![N](https://private.codecogs.com/gif.latex?N) 变为二进制的 ![[N/2]](https://private.codecogs.com/gif.latex?[N/2])。

**3.1.24**　**插值法查找**。假设符号表的键支持算术操作（例如，它们可能是 `Double` 或者 `Interger` 类型的值）。编写一个二分查找来模拟查字典的行为，例如当单词的首字母在字母表的开头时我们也会在字典的前半部分进行查找。具体来说，设 ![k_{lo}](https://private.codecogs.com/gif.latex?k_{lo}) 为符号表的第一个键，![k_{hi}](https://private.codecogs.com/gif.latex?k_{hi}) 为符号表的最后一个键，当要查找 ![k_{x}](https://private.codecogs.com/gif.latex?k_{x}) 时，先和 ![\lfloor(k_x-k_{lo})/(k_{hi}-k_{lo})\rfloor](https://private.codecogs.com/gif.latex?\lfloor(k_x-k_{lo}%29/(k_{hi}-k_{lo}%29\rfloor) 进行比较，而非取中间元素。用 `SearchCompare` {1[`SearchCompare` 应该是一个类似于 `SortCompare` 的类，但实际上正文中并没有任何关于这个 `SearchCompare` 类的内容。——译者注]}调用 `FrequencyCounter` 来比较你的实现和 `BinarySearchST` 的性能。

**3.1.25**　**缓存**。因为默认的 `contains()` 的实现中调用了 `get()`，所以 `FrequencyCounter` 的内循环会将同一个键查找两三遍：

```
if (!st.contains(word)) st.put(word, 1);
else                    st.put(word, st.get(word) + 1);
```

为了能够提高这样的用例代码的效率，我们可以用一种叫**缓存**的技术手段，即将访问最频繁的键的位置保存在一个变量中。修改 `SequentialSearchST` 和 `BinarySearchST` 来实现这个点子。

**3.1.26**　**基于字典的频率统计**。修改 `FrequencyCounter`，接受一个字典文件作为参数，统计标准输入中出现在字典中的单词的频率，并将单词和频率打印为两张表格，一张按照频率高低排序，一张按照字典顺序排序。

**3.1.27**　**小符号表**。假设一段 `BinarySearchST` 的用例插入了 ![N](https://private.codecogs.com/gif.latex?N) 个不同的键并会进行 ![S](https://private.codecogs.com/gif.latex?S) 次查找。当构造表的成本和所有查找的总成本相同时，给出 ![S](https://private.codecogs.com/gif.latex?S) 的增长数量级。

**3.1.28**　**有序的插入**。修改 `BinarySearchST`，使得插入一个比当前所有键都大的键只需要常数时间（这样在构造符号表时有序地使用 `put()` 插入键值对就只需要线性时间了）

**3.1.29**　**测试用例**。编写一段测试代码 TestBinarySearch.java 用来测试正文中 `min()`、`max()`、`floor()`、`ceiling()`、`select()`、`rank()`、`deleteMin()`、`deleteMax()` 和 `keys()` 的实现。可以参考 3.1.3.1 节的索引用例，添加代码使其在适当的情况下接受更多的命令行参数。

**3.1.30**　**验证**。向 `BinarySearchST` 中加入断言（assert）语句，在每次插入和删除数据后检查算法的有效性和数据结构的完整性。例如，对于每个索引必有 `i==rank(select(i))` 且数组应该总是有序的。

###实验题

**3.1.31**　**性能测试**。编写一段性能测试程序，先用 `put()` 构造一张符号表，再用 `get()` 进行访问，使得表中的每个键平均被命中 10 次，且有大致相同次数的未命中访问。键为长度从 2 到 50 不等的随机字符串。重复这样的测试若干遍，记录每遍的运行时间，打印平均运行时间或将它们绘制成图。

**3.1.32**　**练习**。编写一段练习程序，用困难或者极端的但在实际应用中可能出现的情况来测试我们的有序符号表 API。一些简单的例子包括有序的键列、逆序的键列、所有键全部相同或者只含有两种不同的值。

**3.1.33**　**自组织查找**。编写一段程序调用自组织查找的实现（请见练习 3.1.22），用 `put()` 构造一个大小为 ![N](https://private.codecogs.com/gif.latex?N) 的符号表，然后根据预先定义好的概率分布进行 ![10N](https://private.codecogs.com/gif.latex?10N) 次命中查找。对于 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)，用这段程序比较你在练习 3.1.22 中的实现和 `BinarySearchST` 的运行时间，在预定义的概率分布中查找命中第 ![i](https://private.codecogs.com/gif.latex?i) 小的键的概率为 ![1/2^{i}](https://private.codecogs.com/gif.latex?1/2^{i})。

**3.1.34**　**Zipf 法则**。用命中第 ![i](https://private.codecogs.com/gif.latex?i) 小的键的概率为 ![1/(i{\rm H}_N)](https://private.codecogs.com/gif.latex?1/(i{\rm%20H}_N%29) 的分布重新完成上一道练习，其中 ![{\rm H}_N](https://private.codecogs.com/gif.latex?{\rm%20H}_N) 为调和级数（请见表 1.4.6）。这种分布被称为 Zipf 法则。比较前移编码和上一道练习中的在特定分布下的最优安排，该安排将所有键按升序排列（即按照它们的期望频率的降序排列）。

**3.1.35**　**性能验证 I**。用各种不同的 ![N](https://private.codecogs.com/gif.latex?N) 运行双倍测试，取《双城记》的前 ![N](https://private.codecogs.com/gif.latex?N) 个单词，验证 `FrequencyCounter` 在使用 `SequentialSearchST` 时所需的运行时间是 ![N](https://private.codecogs.com/gif.latex?N) 的平方级别的猜想。

**3.1.36**　**性能验证 II**。解释 `FrequencyCounter` 在使用 `BinarySearchST` 时比使用 `SequentialSearchST` 时的性能提高程度好于预期的原因。

**3.1.37**　**`put`/`get` 的比例**。当 `FrequencyCounter` 使用 `BinarySearchST` 在 100 万个长度为 ![M](https://private.codecogs.com/gif.latex?M) 个二进位的随机整数中统计每个值的出现频率时，根据经验判断 `BinarySearchST` 中 `put()` 操作和 `get()` 操作的耗时比，其中 ![M=10](https://private.codecogs.com/gif.latex?M=10)、20 和 30。再统计 tale.txt 并评估耗时比，并比较两次的结果。

**3.1.38**　**均摊成本图**。修改 `FrequencyCounter`、`SequentialSearchST` 和 `BinarySearchST`，统计计算中每次 `put()` 操作的成本并生成类似本节所示的图。

**3.1.39**　**实际耗时**。修改 `FrequencyCounter`，用 `Stopwatch` 和 `StdDraw` 绘图，其中 ![x](https://private.codecogs.com/gif.latex?x) 轴为 `get()` 和 `put()` 的调用次数之和，![y](https://private.codecogs.com/gif.latex?y) 轴为总运行时间，每次调用时就根据已运行时间画一个点。分别用 `SequentialSearchST` 和 `BinarySearchST` 处理《双城记》并讨论运行的结果。**注意**：曲线中突然的跳跃可能是缓存导致的，这已经超出了这个问题的讨论范围。

**3.1.40**　**二分查找的临界点**。找出使用二分查找比顺序查找要快 10 000 倍和 1000 倍的 ![N](https://private.codecogs.com/gif.latex?N) 值。分析并预测 ![N](https://private.codecogs.com/gif.latex?N) 的大小并通过实验验证它。

**3.1.41**　**插值查找的临界点**。找出使用插值查找比二分查找要快 1 倍、2 倍和 10 倍的 ![N](https://private.codecogs.com/gif.latex?N) 值，其中假设所有键为随机的 32 二进位整数（请见练习 3.1.24）。分析并预测 ![N](https://private.codecogs.com/gif.latex?N) 的大小并通过实验验证它。

##3.2　二叉查找树

在本节中我们将学习一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。具体来说，就是使用每个结点含有**两个**链接（链表中每个结点只含有一个链接）的二叉查找树来高效地实现符号表，这也是计算机科学中最重要的算法之一。

首先，我们需要定义一些术语。我们所使用的数据结构由**结点**组成，结点包含的**链接**可以为空（`null`）或者指向其他结点。在**二叉树**中，每个结点只能有一个父结点（只有一个例外，也就是**根结点**，它没有父结点），而且每个结点都只有**左右**两个链接，分别指向自己的**左子结点**和**右子结点**（如图 3.2.1 所示）。尽管链接指向的是结点，但我们可以将每个链接看做指向了另一棵二叉树，而这棵树的根结点就是被指向的结点。因此我们可以将二叉树定义为一个空链接，或者是一个有左右两个链接的结点，每个链接都指向一棵（独立的**）子二叉树**。在**二叉查找树**中，每个结点还包含了一个键和一个值，键之间也有顺序之分以支持高效的查找。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.008.png)

**图 3.2.1　详解二叉树**

>**定义**。一棵**二叉查找树**（BST）是一棵二叉树，其中每个结点都含有一个 `Comparable` 的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。

我们在画出二叉查找树时会将键写在结点上。我们使用“A 是 E 的左子结点”的说法用键指代结点。我们用连接结点的线表示链接，并将键对应的值写在结点旁边（若值不确定则省略）。除了空结点只表示为向下的一条线段以外，每个结点的链接都指向它下方的结点。和以前一样，我们在例子中只会使用索引测试用例生成的单个字母作为键，如图 3.2.2 所示。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.009.png)

**图 3.2.2　详解二叉查找树**

###3.2.1　基本实现

算法 3.3 定义了二叉查找树（BST）的数据结构，我们会在本节中用它实现有序符号表的 API。首先我们要研究一下这个经典的数据类型，以及与它的特点紧密相关的 `get()`（查找）和 `put()`（插入）方法的实现。

####3.2.1.1　数据表示

和链表一样，我们嵌套定义了一个私有类来表示二叉查找树上的一个结点。每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器（有需要时我们会在图中将结点计数器的值写在结点上方）。左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。变量 `N` 给出了以该结点为根的子树的结点总数。你将会看到，它简化了许多有序符号表的操作的实现。算法 3.3 中实现的私有方法 `size()` 会将空链接的值当作 0，这样我们就能保证以下公式对于二叉树中的任意结点 `x` 总是成立。

```
size(x) = size(x.left) + size(x.right) + 1
```

一棵二叉查找树代表了一组键（及其相应的值）的**集合**，而同一个集合可以用多棵不同的二叉查找树表示（如图 3.2.3 所示）。如果我们将一棵二叉查找树的所有键投影到一条直线上，保证一个结点的左子树中的键出现在它的左边，右子树中的键出现在它的右边，那么我们一定可以得到一条有序的键列。我们会利用二叉查找树的这种天生的灵活性，用多棵二叉查找树表示同一组有序的键来实现构建和使用二叉查找树的高效算法。

![{40%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.010.png)

**图 3.2.3　两棵能够表示同一组键的二叉查找树**

####3.2.1.2　查找

一般来说，在符号表中查找一个键可能得到两种结果。如果含有该键的结点存在于表中，我们的查找就**命中**了，然后返回相应的值。否则查找**未命中**（并返回 `null`）。根据数据表示的递归结构我们马上就能得到，在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中，否则我们就（递归地）在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。算法 3.3（续 1）中递归的 `get()` 方法完全实现了这段算法。它的第一个参数是一个结点（子树的根结点），第二个参数是被查找的键。代码会保证只有该结点所表示的子树才会含有和被查找的键相等的结点。和二分查找中每次迭代之后查找的区间就会减半一样，在二叉查找树中，随着我们不断向下查找，当前结点所表示的子树的大小也在减小（理想情况下是减半，但至少会有一个结点）。当找到一个含有被查找的键的结点（命中）或者当前子树变为空（未命中）时这个过程才会结束。从根结点开始，在每个结点中查找的进程都会递归地在它的一个子结点上展开，因此一次查找也就定义了树的一条路径。对于命中的查找，路径在含有被查找的键的结点处结束。对于未命中的查找，路径的终点是一个空链接，如图 3.2.4 所示。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.011.png)

**图 3.2.4　二叉查找树中的查找命中（左）和未命中（右）**

>**算法 3.3　基于二叉查找树的符号表**

>```
>public class BST<Key extends Comparable<Key>, Value>
>{
>    private Node root;               // 二叉查找树的根结点
>
>    private class Node
>    {
>       private Key key;              // 键
>       private Value val;            // 值
>       private Node left, right;     // 指向子树的链接
>       private int N;                // 以该结点为根的子树中的结点总数
>
>       public Node(Key key, Value val, int N)
>       {  this.key = key; this.val = val; this.N = N; }
>    }
>
>    public int size()
>    {  return size(root);  }
>
>    private int size(Node x)
>    {
>       if (x == null) return 0;
>       else           return x.N;
>    }
>
>    public Value get(Key key)
>    // 请见算法3.3（续1）
>
>    public void put(Key key, Value val)
>    // 请见算法3.3（续1）
>
>    // max()、min()、floor()、ceiling()方法请见算法3.3（续2）
>    // select()、rank()方法请见算法3.3（续3）
>    // delete()、deleteMin()、deleteMax()方法请见算法3.3（续4）
>    // keys()方法请见算法3.3（续5）
>}
>```

>这段代码用二叉查找树实现了有序符号表的 API，树由 `Node` 对象组成，每个对象都含有一对键值、两条链接和一个结点计数器 `N`。每个 `Node` 对象都是一棵含有 `N` 个结点的子树的根结点，它的左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找树。`root` 变量指向二叉查找树的根结点 `Node` 对象（这棵树包含了符号表中的所有键值对）。本节会陆续给出其他方法的实现。

算法 3.3（续 1）的实现过程如下所示。

>**算法 3.3（续 1）二叉查找树的查找和排序方法的实现**

>```
>public Value get(Key key)
>{  return get(root, key);  }
>private Value get(Node x, Key key)
>{  // 在以x为根结点的子树中查找并返回key所对应的值；
>    // 如果找不到则返回null
>    if (x == null) return null;
>    int cmp = key.compareTo(x.key);
>    if      (cmp < 0) return get(x.left, key);
>    else if (cmp > 0) return get(x.right, key);
>    else return x.val;
>}
>
>public void put(Key key, Value val)
>{  // 查找key，找到则更新它的值，否则为它创建一个新的结点
>    root = put(root, key, val);
>}
>
>private Node put(Node x, Key key, Value val)
>{
>    // 如果key存在于以x为根结点的子树中则更新它的值；
>    // 否则将以key和val为键值对的新结点插入到该子树中
>    if (x == null) return new Node(key, val, 1);
>    int cmp = key.compareTo(x.key);
>    if      (cmp < 0) x.left  = put(x.left,  key, val);
>    else if (cmp > 0) x.right = put(x.right, key, val);
>    else x.val = val;
>    x.N = size(x.left) + size(x.right) + 1;
>    return x;
>}
>```

>这段代码实现了有序符号表 `API` 中的 `put()` 和 `get()` 方法，它们的递归实现也是本章稍后将会讨论的其他几种实现的模板。每个方法的实现既可以看做是实用的代码，也可以看做是之前讨论的递推猜想的证明。

####3.2.1.3　插入

算法 3.3（续 1）中的查找代码几乎和二分查找的一样简单，这种简洁性是二叉查找树的重要特性之一。而二叉查找树的另一个更重要的特性就是插入的实现难度和查找差不多。当查找一个不存在于树中的结点并结束于一条空链接时，我们需要做的就是将链接指向一个含有被查找的键的新结点（详见图 3.2.5）。算法 3.3（续 1）中递归的 `put()` 方法的实现逻辑和递归查找很相似：如果树是空的，就返回一个含有该键值对的新结点；如果被查找的键小于根结点的键，我们会继续在左子树中插入该键，否则在右子树中插入该键。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.012.png)

**图 3.2.5　二叉查找树的插入操作**

####3.2.1.4　递归

这些递归实现值得我们花点儿时间去理解其中的运行细节。可以将递归调用**前**的代码想象成**沿着树向下走**：它会将给定的键和每个结点的键相比较并根据结果向左或者向右移动到下一个结点。然后可以将递归调用**后**的代码想象成**沿着树向上爬**。对于 `get()` 方法，这对应着一系列的返回指令（`return`），但是对于 `put()` 方法，这意味着重置搜索路径上每个父结点指向子结点的链接，并增加路径上每个结点中的计数器的值。在一棵简单的二叉查找树中，唯一的新链接就是在最底层指向新结点的链接，重置更上层的链接可以通过比较语句来避免。同样，我们只需要将路径上每个结点中的计数器的值加 1，但我们使用了更加通用的代码，使之等于结点的所有子结点的计数器之和加 1。在本节和下一节中，我们会学习一些更加高级但原理相同的算法，但它们在搜索路径上需要改变的链接更多，也需要适应性更强的代码来更新结点计数器。基本的二叉查找树的实现常常是非递归的（请见练习 3.2.13）——我们在实现中使用了递归，一来是为了便于读者理解代码的工作方式，二来也是为学习更加复杂的算法做准备。

图 3.2.6 是对我们的标准索引用例轨迹的一份详细的研究，它向你展示了二叉树是如何生长的。新结点会连接到树底层的空链接上，树的其他部分则不会改变。例如，第一个被插入的键就是根结点，第二个被插入的键是根结点的两个子结点之一，以此类推。因为每个结点都含有两个链接，树会逐渐长大而不是萎缩。不仅如此，因为只有查找或者插入路径上的结点才会被访问，所以随着树的增长，被访问的结点数量占树的总结点数的比例也会不断的降低。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.013.png)

**图 3.2.6　使用二叉查找树的标准索引用例的轨迹**

###3.2.2　分析

使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。在最好的情况下，一棵含有 ![N](https://private.codecogs.com/gif.latex?N) 个结点的树是完全平衡的，每条空链接和根结点的距离都为 ![\sim\lg N](https://private.codecogs.com/gif.latex?\sim\lg%20N)。在最坏的情况下，搜索路径上可能有 ![N](https://private.codecogs.com/gif.latex?N) 个结点。如图 3.2.7 所示。但在一般情况下树的形状和最好情况更接近。

![{35%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.014.png)

**图 3.2.7　二叉查找树的可能形状**

对于很多应用来说，图 3.2.8 所示的简单模型都是适用的：我们假设键的分布是（均匀）随机的，或者说它们的插入顺序是**随机的**。对这个模型的分析而言，二叉查找树和快速排序几乎就是“双胞胎”。树的根结点就是快速排序中的第一个切分元素（左侧的键都比它小，右侧的键都比它大），而这对于所有的子树同样适用，这和快速排序中对子数组的递归排序完全对应。这使我们能够分析得到二叉查找树的一些性质。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.015.png)

**图 3.2.8　一棵典型的二叉查找树，由 256 个随机键组成**

>**命题 C**。在由 ![N](https://private.codecogs.com/gif.latex?N) 个随机键构造的二叉查找树中，查找命中平均所需的比较次数为 ![\sim2\ln N](https://private.codecogs.com/gif.latex?\sim2\ln%20N)（约 ![1.39\lg N](https://private.codecogs.com/gif.latex?1.39\lg%20N)）。

>**证明**。一次结束于给定结点的命中查找所需的比较次数为查找路径的深度加 1。如果将树中的所有结点的深度加起来，我们就能够得到一棵树的**内部路径长度**。因此，在二叉查找树中的平均比较次数即为平均内部路径长度加 1。我们可以使用 2.3 节的命题 K 的证明得到它：令 ![C_N](https://private.codecogs.com/gif.latex?C_N) 为由 ![N](https://private.codecogs.com/gif.latex?N) 个随机排序的不同键构造得到的二叉查找树的内部路径长度，则查找命中的平均成本为（![1+C_N/N](https://private.codecogs.com/gif.latex?1+C_N/N)）。我们有 ![C_0=C_1=0](https://private.codecogs.com/gif.latex?C_0=C_1=0)，且对于 ![N>1](https://private.codecogs.com/gif.latex?N%3E1) 我们可以根据二叉查找树的递归结构直接得到一个归纳关系式：

>![C_N=N-1+(C_0+C_{N-1})/N+(C_1+C_{N-2})/N+\cdots+(C_{N-1}+C_0)/N](https://private.codecogs.com/gif.latex?C_N=N-1+(C_0+C_{N-1}%29/N+(C_1+C_{N-2}%29/N+\cdots+(C_{N-1}+C_0%29/N)

>其中 ![N-1](https://private.codecogs.com/gif.latex?N-1) 这一项表示根结点使得树中的所有 ![N-1](https://private.codecogs.com/gif.latex?N-1) 个非根结点的路径上都加了 1。表达式的其他项代表了所有子树，它们的计算方法和大小为 ![N](https://private.codecogs.com/gif.latex?N) 的二叉查找树的方法相同。整理表达式后我们会发现，这个归纳公式和我们在2.3节中为快速排序得到的公式几乎完全相同，因此我们同样可以得到 ![C_N\sim2N\ln N](https://private.codecogs.com/gif.latex?C_N\sim2N\ln%20N)。

　

>**命题 D**。在由 ![N](https://private.codecogs.com/gif.latex?N) 个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为  ![\sim2\ln N](https://private.codecogs.com/gif.latex?\sim2\ln%20N)（约 ![1.39\lg N](https://private.codecogs.com/gif.latex?1.39\lg%20N)）。

>**证明**。插入操作和查找未命中平均比查找命中需要一次额外的比较。这一点由归纳法不难得到（请见练习 3.2.16）。

命题 C 说明在二叉查找树中查找随机键的成本比二分查找高约 39%。命题 D 说明这些额外的成本是值得的，因为插入一个新键的成本是对数级别的——这是基于二分查找的有序数组所不具备的灵活性，因为它的插入操作所需访问数组的次数是线性级别的。和快速排序一样，比较次数的标准差很小，因此 ![N](https://private.codecogs.com/gif.latex?N) 越大这个公式越准确。

**实验**

我们的随机键模型和典型的符号表使用情况是否相符？按照惯例，这个问题的答案需要具体问题具体分析，因为在不同的应用场景中性能的差别可能很大。幸好，对于大多数用例，这个模型都能很好地适应。

作为例子，我们研究用 `FrequencyCounter` 处理长度大于等于 8 的单词时 `put()` 操作的成本。从图 3.2.9 可以看到，每次操作的平均成本从 `BinarySearchST` 的 484 次数组访问降低到了二叉查找树的 13 次，这也再次验证了理论模型所预测的对数级别的性能。根据命题 C 和命题 D，这个数值的合理大小应该是符号表大小的自然对数的两倍左右，因为对于一个几乎充满的符号表，大多数操作都是查找。这个预测至少有以下不准确性：

* 很多操作都是在较小的符号表中进行的；
* 键不随机；
* 符号表可能太小，近似值 ![2\ln N](https://private.codecogs.com/gif.latex?2\ln%20N) 不准确。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.016.png)

**图 3.2.9　使用二叉查找树，运行 `java FrequencyCounter 8 < tale.txt` 的成本**

无论如何，通过表 3.2.1 你都能看到，对于 `FrequencyCounter` 这个预测的误差只有若干次比较。事实上，大多数误差都能通过对近似值的数学表达式的改进得到解释（请见练习 3.2.35）。

**表 3.2.1　使用二叉查找树的 `FrequencyCounter` 的每次 `put()` 操作平均所需的比较次数**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="3"></th><th colspan="4">tale.txt</th><th colspan="4">leipzig1M.txt</th></tr>
<tr><th rowspan="2">单词数</th><th rowspan="2">不同单词数</th><th colspan="2">比较次数</th><th rowspan="2">单词数</th><th rowspan="2">不同单词数</th><th colspan="2">比较次数</th></tr>
<tr><th>模型预测</th><th>实际次数</th><th>模型预测</th><th>实际次数</th></tr>
<tr><td>所有单词</td><td>135 635</td><td>10 679</td><td>18.6</td><td>17.5</td><td>21 191 455</td><td>534 580</td><td>23.4</td><td>22.1</td></tr>
<tr><td>长度大于等于 8 的单词</td><td>14 350</td><td>5 131</td><td>17.6</td><td>13.9</td><td>4 239 597</td><td>299 593</td><td>22.7</td><td>21.4</td></tr>
<tr><td>长度大于等于 10 的单词</td><td>4 582</td><td>2 260</td><td>15.4</td><td>13.1</td><td>1 610 829</td><td>165 555</td><td>20.5</td><td>19.3</td></tr>
</table>

###3.2.3　有序性相关的方法与删除操作

二叉查找树得以广泛应用的一个重要原因就是它能够**保持键的有序性**，因此它可以作为实现有序符号表 API（请见 3.1.2 节）中的众多方法的基础。这使得符号表的用例不仅能够通过键还能通过键的相对顺序来访问键值对。下面，我们要研究有序符号表 API 中各个方法的实现。

####3.2.3.1　最大键和最小键

如果根结点的左链接为空，那么一棵二叉查找树中最小的键就是根结点；如果左链接非空，那么树中的最小键就是左子树中的最小键。这不仅描述了算法 3.3（续 2）中 `min()` 方法的递归实现，同时也递推地证明了它能够在二叉查找树中找到最小的键。简单的循环也能等价实现这段描述，但为了保持一致性我们使用了递归。我们可以让递归调用返回键 `Key` 而非结点对象 `Node`，但我们后面还会用到这方法来找出含有最小键的结点。找出最大键的方法也是类似的，只是变为查找右子树而已。

####3.2.3.2　向上取整和向下取整

如果给定的键 `key` **小于**二叉查找树的根结点的键，那么小于等于 `key` 的最大键 `floor(key)` **一定**在根结点的左子树中；如果给定的键 key **大于**二叉查找树的根结点，那么只有当根结点右子树中存在小于等于 `key` 的结点时，小于等于 `key` 的最大键才会出现在右子树中，否则根结点就是小于等于 `key` 的最大键。这段描述说明了 `floor()` 方法的递归实现，同时也递推地证明了它能够计算出预期的结果。将“左”变为“右”（同时将**小于**变为**大于**）就能够得到 `ceiling()` 的算法。向下取整函数的计算如图 3.2.10 所示。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.017.png)

**图 3.2.10　计算 `floor()` 函数**

####3.2.3.3　选择操作

二叉查找树中的选择操作和 2.5 节中我们学习过的基于切分的数组选择操作类似。我们在二叉查找树的每个结点中维护的子树结点计数器变量 `N` 就是用来支持此操作的。

>**算法 3.3（续 2）二叉查找树中 `max()`、`min()`、`floor()`、`ceiling()` 方法的实现**

>```
>public Key min()
>{
>    return min(root).key;
>}
>private Node min(Node x)
>{
>    if (x.left == null) return x;
>    return min(x.left);
>}
>public Key floor(Key key)
>{
>    Node x = floor(root, key);
>    if (x == null) return null;
>    return x.key;
>}
>private Node floor(Node x, Key key)
>{
>    if (x == null) return null;
>    int cmp = key.compareTo(x.key);
>    if (cmp == 0) return x;
>    if (cmp < 0)  return floor(x.left, key);
>    Node t = floor(x.right, key);
>    if (t != null) return t;
>    else           return x;
>}
>```

>每个公有方法都对应着一个私有方法，它接受一个额外的链接作为参数指向某个结点，通过正文中描述的递归方法查找返回 `null` 或者含有指定 `Key` 的结点 `Node`。`max()` 和 `ceiling()` 的实现分别与 `min()` 和 `floor()` 方法基本相同，只是将代码中的 `left` 和 `right`（以及＞和＜）调换而已。

假设我们想找到排名为 ![k](https://private.codecogs.com/gif.latex?k) 的键（即树中正好有 ![k](https://private.codecogs.com/gif.latex?k) 个小于它的键）。如果左子树中的结点数 ![t](https://private.codecogs.com/gif.latex?t) 大于 ![k](https://private.codecogs.com/gif.latex?k)，那么我们就**继续**（递归地）在左子树中查找排名为 ![k](https://private.codecogs.com/gif.latex?k) 的键；如果 ![t](https://private.codecogs.com/gif.latex?t) 等于 ![k](https://private.codecogs.com/gif.latex?k)，我们就返回根结点中的键；如果 ![t](https://private.codecogs.com/gif.latex?t) 小于 ![k](https://private.codecogs.com/gif.latex?k)，我们就（递归地）在右子树中查找排名为（![k-t-1](https://private.codecogs.com/gif.latex?k-t-1)）的键。和刚才一样，这段描述既说明了 `select()` 方法的递归实现同时也证明了它的正确性，此过程如图 3.2.11 所示。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.018.png)

**图 3.2.11　二叉查找树中的 `select()` 操作**

####3.2.3.4　排名

`rank()` 是 `select()` 的逆方法，它会返回给定键的排名。它的实现和 `select()` 类似：如果给定的键和根结点的键相等，我们返回左子树中的结点总数 ![t](https://private.codecogs.com/gif.latex?t)；如果给定的键小于根结点，我们会返回该键在左子树中的排名（递归计算）；如果给定的键大于根结点，我们会返回 ![t+1](https://private.codecogs.com/gif.latex?t+1)（根结点）加上它在右子树中的排名（递归计算）。

二叉查找树中选择和排名操作的实现如算法 3.3（续 3）所示。

>**算法 3.3（续 3）二叉查找树中 `select()` 和 `rank()` 方法的实现**

>```
>public Key select(int k)
>{
>    return select(root, k).key;
>}
>private Node select(Node x, int k)
>{   // 返回排名为k的结点
>     if (x == null) return null;
>     int t = size(x.left);
>     if      (t > k) return select(x.left,  k);
>     else if (t < k) return select(x.right, k-t-1);
>     else            return x;
>}
>public int rank(Key key)
>{  return rank(key, root);  }
>private int rank(Key key, Node x)
>{  // 返回以x为根结点的子树中小于x.key的键的数量
>    if (x == null) return 0;
>    int cmp = key.compareTo(x.key);
>    if      (cmp < 0) return rank(key, x.left);
>    else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right);
>    else              return size(x.left);
>}
>```

>这段代码使用了和我们已经在本章中学习过的其他实现中一样的递归模式实现了 `select()` 和 `rank()` 方法。它依赖于本节开始处给出的 `size()` 方法来统计每个结点以下的子结点总数。

####3.2.3.5　删除最大键和删除最小键

二叉查找树中最难实现的方法就是 `delete()` 方法，即从符号表中删除一个键值对。作为热身运动，我们先考虑 `deleteMin()` 方法（删除最小键所对应的键值对），如图 3.2.12 所示。和 `put()` 一样，我们的递归方法接受一个指向结点的链接，并返回一个指向结点的链接。这样我们就能够方便地改变树的结构，将返回的链接赋给作为参数的链接。对于 `deleteMin()`，我们要不断深入根结点的左子树中直至遇见一个空链接，然后将指向该结点的链接指向该结点的右子树（只需要在递归调用中返回它的右链接即可）。此时已经没有任何链接指向要被删除的结点，因此它会被垃圾收集器清理掉。我们给出的标准递归代码在删除结点后会正确地设置它的父结点的链接并更新它到根结点的路径上的所有结点的计数器的值。`deleteMax()` 方法的实现和 `deleteMin()` 完全类似。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.019.png)

**图 3.2.12　删除二叉查找树中的最小结点**

####3.2.3.6　删除操作

我们可以用类似的方式删除任意只有一个子结点（或者没有子结点）的结点，但应该怎样删除一个拥有两个子结点的结点呢？删除之后我们要处理两棵子树，但被删除结点的父结点只有一条空出来的链接。T. Hibbard 在 1962 年提出了解决这个难题的第一个方法，在删除结点 `x` 后用它的**后继结点**填补它的位置。因为 `x` 有一个右子结点，因此它的后继结点就是其右子树中的最小结点。这样的替换仍然能够保证树的有序性，因为 `x.key` 和它的后继结点的键之间不存在其他的键。我们能够用 4 个简单的步骤完成将 `x` 替换为它的后继结点的任务（具体过程如图 3.2.13 所示）：

* 将指向即将被删除的结点的链接保存为 `t`；
* 将 `x` 指向它的后继结点 `min(t.right)`；
* 将 `x` 的右链接（原本指向一棵所有结点都大于 `x.key` 的二叉查找树）指向 `deleteMin(t.right)`，也就是在删除后所有结点仍然都大于 `x.key` 的子二叉查找树；
* 将 `x` 的左链接（本为空）设为 `t.left`（其下所有的键都小于被删除的结点和它的后继结点）。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.020.png)

**图 3.2.13　二叉查找树中的删除操作**

在递归调用后我们会修正被删除的结点的父结点的链接，并将由此结点到根结点的路径上的所有结点的计数器减 1（这里计数器的值仍然会被设为其所有子树中的结点总数加一）。尽管这种方法能够正确地删除一个结点，它的一个缺陷是可能会在某些实际应用中产生性能问题。这个问题在于选用后继结点是一个随意的决定，且没有考虑树的对称性。可以使用它的前趋结点吗？实际上，前趋结点和后继结点的选择应该是随机的。详细讨论请见练习 3.2.42。

二叉查找树中删除操作的实现如算法 3.3（续 4）所示。

>**算法 3.3（续 4）二叉查找树的 `delete()` 方法的实现**

>```
>public void deleteMin()
>{
>    root = deleteMin(root);
>}
>
>private Node deleteMin(Node x)
>{
>    if (x.left == null) return x.right;
>    x.left = deleteMin(x.left);
>    x.N = size(x.left) + size(x.right) + 1;
>    return x;
>}
>
>public void delete(Key key)
>{  root = delete(root, key);  }
>
>private Node delete(Node x, Key key)
>{
>    if (x == null) return null;
>    int cmp = key.compareTo(x.key);
>    if      (cmp < 0) x.left  = delete(x.left,  key);
>    else if (cmp > 0) x.right = delete(x.right, key);
>    else
>    {
>       if (x.right == null) return x.left;
>       if (x.left == null) return x.right;
>       Node t = x;
>       x = min(t.right);  // 请见算法3.3（续2）
>       x.right = deleteMin(t.right);
>       x.left = t.left;
>    }
>    x.N = size(x.left) + size(x.right) + 1;
>    return x;
>}
>```

>如前文所述，这段代码实现了 Hibbard 的二叉查找树中对结点的即时删除。`delete()` 方法的代码很简洁，但不简单。也许理解它的最好办法就是读懂正文中的讲解，试着自己实现它并对比自己的代码和这段代码。一般情况下这段代码的效率不错，但对于大规模的应用来说可能会有一点问题（请见练习 3.2.42）。`deleteMax()` 的实现和 `deleteMin()` 类似，只需左右互换即可。

####3.2.3.7　范围查找

要实现能够返回给定范围内键的 `keys()` 方法，我们首先需要一个遍历二叉查找树的基本方法，叫做**中序遍历**。要说明这个方法，我们先看看如何能够将二叉查找树中的所有键按照顺序打印出来。要做到这一点，我们应该先打印出根结点的左子树中的所有键（根据二叉查找树的定义它们应该都小于根结点的键），然后打印出根结点的键，最后打印出根结点的右子树中的所有键（根据二叉查找树的定义它们应该都大于根结点的键），如右侧的代码所示。

```
private void print(Node x)
{
   if (x == null) return;
   print(x.left);
   StdOut.println(x.key);
   print(x.right);
}
```

{-:-}按顺序打印二叉查找树中的所有键

和以前一样，刚才的描述也递推地证明了这段代码能够顺序打印树中的所有键。为了实现接受两个参数并能够将给定范围内的键返回给用例的 `keys()` 方法，我们可以修改一下这段代码，将所有落在给定范围以内的键加入一个队列 `Queue` 并跳过那些不可能含有所查找键的子树。和 `BinarySearchST` 一样，用例不需要知道我们使用 `Queue` 来收集符合条件的键。我们使用什么数据结构来实现 `Iterable<Key>` 并不重要，用例只要能够使用 Java 的 `foreach` 语句遍历返回的所有键就可以了。

二叉查找树的范围查找操作的实现如算法 3.3（续 5）所示。

>**算法 3.3（续 5）二叉查找树的范围查找操作**

>```
>public Iterable<Key> keys()
>{  return keys(min(), max());  }
>
>public Iterable<Key> keys(Key lo, Key hi)
>{
>     Queue<Key> queue = new Queue<Key>();
>     keys(root, queue, lo, hi);
>     return queue;
>}
>
>private void keys(Node x, Queue<Key> queue, Key lo, Key hi)
>{
>    if (x == null) return;
>    int cmplo = lo.compareTo(x.key);
>    int cmphi = hi.compareTo(x.key);
>    if (cmplo < 0) keys(x.left, queue, lo, hi);
>    if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key);
>    if (cmphi > 0) keys(x.right, queue, lo, hi);
>}
>```

>为了确保以给定结点为根的子树中所有在指定范围之内的键加入队列，我们会（递归地）查找根结点的左子树，然后查找根结点，然后（递归地）查找根结点的右子树。

>![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.021.png)

>{-:-}**二叉查找树的范围查找**

####3.2.3.8　性能分析

二叉查找树中和有序性相关的操作的效率如何？要研究这个问题，我们首先要知道**树的高度**（即树中任意结点的最大深度）。给定一棵树，树的高度决定了所有操作在最坏情况下的性能（范围查找除外，因为它的额外成本和返回的键的数量成正比）。

>**命题 E**。在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。

>**证明**。树的所有操作都沿着树的一条或两条路径行进。根据定义，路径的长度不可能大于树的高度。

我们估计树的高度（即最坏情况下的成本）将会大于我们在 3.2.2 节中定义的平均内部路径长度（这个平均值已经包含了所有较短的路径），但会高多少呢？也许在你看来这个问题和命题 C 和命题 D 解答的问题类似，但它的解答其实要困难得多，完全超出了本书的范畴。1979 年，J. Robson 证明了随机键构造的二叉查找树的平均高度为树中结点数的对数级别，随后 L. Devroye 证明了对于足够大的 ![N](https://private.codecogs.com/gif.latex?N)，这个值趋近于 ![2.99\lg N](https://private.codecogs.com/gif.latex?2.99\lg%20N)。因此，如果我们的应用中的插入操作能够适用于这个随机模型，我们距离实现一个支持对数级别的所有操作的符号表的目标就已经不远了。我们可以认为随机构造的树中的所有路径长度都小于 ![3\lg N](https://private.codecogs.com/gif.latex?3\lg%20N)，但如果构造树的键不是随机的怎么办？在下一节中你会看到在实际应用中这个问题其实没有意义，因为还有**平衡二叉查找树**，它能保证无论键的插入顺序如何，树的高度都将是总键数的对数。

总的来说，二叉查找树的实现并不困难，且当树的构造和随机模型近似时在各种实际应用场景中它都能进行快速地查找和插入。对于我们的例子（以及其他许多实际应用场景）来说，二叉查找树将不可能完成的任务变为可能。另外，许多程序员都偏爱基于二叉查找树的符号表的原因是它还支持高效的 `rank()`、`select()`、`delete()` 以及范围查找等操作。但同时，正如我们所强调过的，在某些场景中二叉查找树在最坏情况下的恶劣性能仍然是不可接受的。二叉查找树的基本实现的良好性能依赖于其中的键的分布足够随机以消除长路径。对于快速排序，我们可以先将数组打乱；而对于符号表的 API，我们无能为力，因为符号表的用例控制着各种操作的先后顺序。但最坏情况在实际应用也有可能出现——用例将所有键按照顺序或者逆序插入符号表就会增加这种情况出现的概率，而在没有明确的警告来避免这种行为时有些用例肯定会尝试这么做。这就是我们寻找更好的算法和数据结构的主要原因，这些算法和数据结构我们会在下一节学习。

本书中简单的符号表实现的成本列在表 3.2.2 中。

**表 3.2.2　简单的符号表实现的成本总结**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="2">算法（数据结构）</th><th colspan="2">最坏情况下的运行时间的增长数量级（<i>N</i>次插入之后）</th><th colspan="2">平均情况下的运行时间的增长数量级（<i>N</i>次插入随机键之后）</th><th rowspan="2">是否支持有序性相关的操作</th></tr>
<tr><th>查找</th><th>插入</th><th>查找命中</th><th>插入</th></tr>
<tr><td>顺序查询（无序链表）</td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N/2" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td>否</td></tr>
<tr><td>二分查找（有序数组）</td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N/2" /></td><td>是</td></tr>
<tr><td>二叉树查找（二叉查找树）</td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.39\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.39\lg%20N" /></td><td>是</td></tr>
</table>

###答疑

**问**　我见过二叉查找树，但它的实现没有使用递归。这两种方式各有哪些优缺点？

**答**　一般来说，递归的实现更容易验证其正确性，而非递归的实现效率更高。在练习 3.2.13 中你需要用另一种方法实现 `get()`，你可能会注意到性能上的改进。如果树不是平衡的，函数调用的栈的深度可能会成为递归实现的一个问题。我们使用递归的一个主要原因是使读者能够轻松过渡到下一节中的平衡二叉查找树，而且递归版本显然更易于实现和调试。

**问**　维护 `Node` 对象中的结点计数器似乎需要很多代码，这有必要吗？为什么不只用一个变量来保存整棵树中的结点总数来实现用例中的 `size()` 方法？

**答**　`rank()` 和 `select()` 方法需要知道每个结点所代表的子树中的结点总数。如果你不需要实现这些操作，可以去掉这个变量以简化代码（请见练习 3.2.12）。要保证所有结点中的计数器的正确性的确很容易出错，但这个值在调试中同样有用。你也可以用递归的方法实现用例中的 `size()` 函数，但这样统计所有结点的运行时间可能是**线性**的。这十分危险，因为如果不知道这么一个简单的操作会如此耗时，用例的性能可能会变得很差。

###练习

**3.2.1**　将 `E A S Y Q U E S T I O N` 作为键按顺序插入一棵初始为空的二叉查找树中（方便起见设第 `i` 个键对应的值为 `i`），画出生成的二叉查找树。构造这棵树需要多少次比较？

**3.2.2**　将 `A X C S E R H` 作为键按顺序插入将会构造出一棵最坏情况下的二叉查找树结构，最下方的结点的两个链接全部为空，其他结点都含有一个空链接。用这些键给出构造最坏情况下的树的其他 5 种排列。

**3.2.3**　给出 `A X C S E R H` 的 5 种能够构造出**最优**二叉查找树的排列。

**3.2.4**　假设某棵二叉查找树的所有键均为 1 至 10 的整数，而我们要查找 5。那么以下哪个**不可能**是键的检查序列？

　　　a. 10, 9, 8, 7, 6, 5

　　　b. 4, 10, 8, 7, 5, 3

　　　c. 1, 10, 2, 9, 3, 8, 4, 7, 6, 5

　　　d. 2, 7, 3, 8, 4, 5

　　　e. 1, 2, 10, 4, 8, 5

**3.2.5**　假设已知某棵二叉查找树中的每个结点的查找频率，且我们可以以任意顺序用它们构造一棵树。我们是应该按照查找频率的顺序由高到低或是由低到高将它们插入，还是用其他某种顺序？证明你的结论。

**3.2.6**　为二叉查找树添加一个方法 `height()` 来计算树的高度。实现两种方案：一种使用递归（用时为线性级别，所需空间和树高成正比），一种模仿 `size()` 在每个结点中添加一个变量（所需空间为线性级别，查询耗时为常数）。

**3.2.7**　为二叉查找树添加一个方法 `avgCompares()` 来计算一棵给定的树中的一次随机命中查找平均所需的比较次数（即树的内部路径长度除以树的大小再加 1）。实现两种方案：一种使用递归（用时为线性级别，所需空间和树高成正比），一种模仿 `size()` 在每个结点中添加一个变量（所需空间为线性级别，查询耗时为常数）。

**3.2.8**　编写一个静态方法 `optCompares()`，接受一个整型参数 `N` 并计算一棵最优（完美平衡的）二叉查找树中的一次随机查找命中平均所需的比较次数，如果树中的链接数量为 2 的幂，那么所有的空链接都应该在同一层，否则则分布在最底部的两层中。

**3.2.9**　对于 ![N=2](https://private.codecogs.com/gif.latex?N=2)、3、4、5 和 6，画出用 ![N](https://private.codecogs.com/gif.latex?N) 个键可能构造出的所有不同形状的二叉查找树。

**3.2.10**　编写一个测试用例 TestBST.java 来测试正文中 `min()`、`max()`、`floor()`、`ceiling()`、`select()`、`rank()`、`delete()`、`deleteMin()`、`deleteMax()` 和 `keys()` 方法的实现。可以参考 3.1.3.1 节的标准索引用例，使它接受其他合适的命令行参数。

**3.2.11**　高度为 ![N](https://private.codecogs.com/gif.latex?N) 且含有 ![N](https://private.codecogs.com/gif.latex?N) 个结点的二叉树能有多少种形状？使用 ![N](https://private.codecogs.com/gif.latex?N) 个不同的键能有多少种不同的方式构造一棵高度为 ![N](https://private.codecogs.com/gif.latex?N) 的二叉查找树？（参考练习 3.2.2）

**3.2.12**　实现一种二叉查找树，舍弃 `rank()` 和 `select()` 方法并且不在 `Node` 对象中使用计数器。

**3.2.13**　为二叉查找树实现非递归的 `put()` 和 `get()` 方法。

　　　**部分解答**，以下是 `get()` 方法的实现：

```
public Value get(Key key)
{
   Node x = root;
   while (x != null)
   {
      int cmp = key.compareTo(x.key);
      if (cmp == 0) return x.val;
      else if (cmp < 0) x = x.left;
      else if (cmp > 0) x = x.right;
   }
   return null;
}
```

　　　`put()` 的实现更复杂一些，因为它需要保存一个指向底层结点的链接，以便使之成为新结点的父结点。你还需要额外遍历一遍查找路径来更新所有的结点计数器以保证结点插入的正确性。因为在性能优先的实现中查找的次数比插入多得多，有必要使用这段 `get()` 代码，而相应的 `put()` 实现则无关紧要。

**3.2.14**　实现非递归的 `min()`、`max()`、`floor()`、`ceiling()`、`rank()` 和 `select()` 方法。

**3.2.15**　对于右下方的二叉查找树，给出计算下列方法的过程中结点的访问序列。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.022.png)

　　　a. `floor("Q")`

　　　b. `select(5)`

　　　c. `ceiling("Q")`

　　　d. `rank("J")`

　　　e. `size("D", "T")`

　　　f. `keys("D", "T")`

**3.2.16**　设一棵树的**外部路径长度**为从根结点到空链接的所有路径上的结点总数。证明对于大小为 ![N](https://private.codecogs.com/gif.latex?N) 的任意二叉树，其外部路径长度和内部路径长度之差为 ![2N](https://private.codecogs.com/gif.latex?2N)（可以参考命题 C）

**3.2.17**　从练习 3.2.1 构造的二叉查找树中将所有键按照插入顺序逐个删除并画出每次删除所得到的树。

**3.2.18**　从练习 3.2.1 构造的二叉查找树中将所有键按照字母顺序逐个删除并画出每次删除所得到的树。

**3.2.19**　从练习 3.2.1 构造的二叉查找树中逐次删除树的根结点并画出每次删除所得到的树。

**3.2.20**　请证明：对于含有 ![N](https://private.codecogs.com/gif.latex?N) 个结点的二叉查找树，接受两个参数的 `size()` 方法所需的运行时间最多为树高的倍数加上查找范围内的键的数量。

**3.2.21**　为二叉查找树添加一个 `randomKey()` 方法来在和树高成正比的时间内从符号表中随机返回一个键。

**3.2.22**　请证明：若一棵二叉查找树中的一个结点有两个子结点，那么它的后继结点不会有左子结点，前趋结点不会有右子结点。

**3.2.23**　`delete()` 方法符合交换律吗？（先删除 `x` 后删除 `y` 和先删除 `y` 后删除 `x` 能够得到相同的结果吗？）

**3.2.24**　请证明：使用基于比较的算法构造一棵二叉查找树所需的最小比较次数为 ![\lg(N!)\sim N\lg N](https://private.codecogs.com/gif.latex?\lg(N!%29\sim%20N\lg%20N)。

###提高题

**3.2.25**　**完美平衡**。编写一段程序，用一组键构造一棵和二分查找等价的二叉查找树。也就是说，在这棵树中查找任意键所产生的比较序列和在这组键中使用二分查找所产生的比较序列完全相同。

**3.2.26**　**准确的概率**。计算用 ![N](https://private.codecogs.com/gif.latex?N) 个随机的互不相同的键构造出练习 3.2.9 中的每一棵树的概率。

**3.2.27**　**内存使用**。基于 1.4 节的假设，对于 ![N](https://private.codecogs.com/gif.latex?N) 对键值比较二叉查找树和 `BinarySearchST` 以及 `SequentialSearchST` 的内存使用情况。不需要记录键值本身占用的内存，只统计它们的引用。用图精确描述一棵以 `String` 为键、`Integer` 为值的二叉查找树（比如 `FrequencyCounter` 构造的那种）的内存使用情况，然后估计 `FrequencyCounter` 在使用二叉查找树处理《双城记》时树的内存使用情况（精确到字节）。

**3.2.28**　**缓存**。修改二叉查找树的实现，将最近访问的结点 `Node` 保存在一个变量中，这样 `get()` 或 `put()` 再次访问同一个键时就只需要常数时间了（参考练习 3.1.25）。

**3.2.29**　**二叉树检查**。编写一个递归的方法 `isBinaryTree()`，接受一个结点 `Node` 为参数。如果以该结点为根的子树中的结点总数和计数器的值 ![N](https://private.codecogs.com/gif.latex?N) 相符则返回 `true`，否则返回 `false`。**注意**：这项检查也能保证数据结构中不存在环，因此这的确是一棵二叉树！

**3.2.30**　**有序性检查**。编写一个递归的方法 `isOrdered()`，接受一个结点 `Node` 和 `min`、`max` 两个键作为参数。如果以该结点为根的子树中的所有结点都在 `min` 和 `max` 之间，`min` 和 `max` 的确分别是树中的最小和最大的结点且二叉查找树的有序性对树中的所有键都成立，返回 `true`，否则返回 `false`。

**3.2.31**　**等值键检查**。编写一个方法 `hasNoDuplicates()`，接受一个结点 `Node` 为参数。如果以该结点为根的二叉查找树中不含有等值的键则返回 `true`，否则返回 `false`。假设树已经通过了前几道练习的检查。

**3.2.32**　**验证**。编写一个方法 `isBST()`，接受一个结点 `Node` 为参数。若该结点是一个二叉查找树的根结点则返回 `true`，否则返回 `false`。**提示**：这个任务比看起来要困难，它和你调用前三题中各个方法的顺序有关。

　　　**解答**：

```
private boolean isBST()
{
   if (!isBinaryTree(root)) return false;
   if (!isOrdered(root, min(), max())) return false;
   if (!hasNoDuplicates(root)) return false;
   return true;
}
```

**3.2.33**　**选择 / 排名检查**。编写一个方法，对于 0 到 `size()-1` 之间的所有 `i`，检查 `i` 和 `rank(select(i))` 是否相等，并检查二叉查找树中的的任意键 `key` 和 `select(rank(key))` 是否相等。

**3.2.34**　**线性符号表**。你的目标是实现一个扩展的符号表 `ThreadedST`，支持以下两个运行时间为常数的操作：

```
Key next(Key key)，key的下一个键（若key为最大键则返回空）
Key prev(Key key)，key的上一个键（若key为最小键则返回空）
```

　　　要做到这一点需要在结点中增加 `pred` 和 `succ` 两个变量来保存结点的前趋和后继结点，并相应修改 `put()`、`deleteMin()`、`deleteMax()` 和 `delete()` 方法来维护这两个变量。

**3.2.35**　**改进的分析**。为了更好地解释正文表格中的试验结果请改进它的数学模型。证明随着 ![N](https://private.codecogs.com/gif.latex?N) 的增大，在一棵随机构造的二叉查找树中，一次命中查找所需的平均比较次数会趋近于 ![2\ln N+2\gamma-3\approx1.39\lg N-1.85](https://private.codecogs.com/gif.latex?2\ln%20N+2\gamma-3\approx1.39\lg%20N-1.85)，其中 ![\gamma=0.57721\cdots](https://private.codecogs.com/gif.latex?\gamma=0.57721\cdots)，即**欧拉常数**。**提示**：参考 2.3 节中对快速排序的分析，![1/x](https://private.codecogs.com/gif.latex?1/x) 的积分趋近于 ![\ln N+\gamma](https://private.codecogs.com/gif.latex?\ln%20N+\gamma)。

**3.2.36**　**迭代器**。能否实现一个非递归版本的 `keys()` 方法，其使用的额外空间和树的高度成正比（和查找范围内的键的多少无关）？

**3.2.37**　**按层遍历**。编写一个方法 `printLevel()`，接受一个结点 `Node` 作为参数，按照层级顺序打印以该结点为根的子树（即按每个结点到根结点的距离的顺序，同一层的结点应该按从左至右的顺序）。**提示**：使用队列 `Queue`。

**3.2.38**　**绘图**。为二叉查找树添加一个方法 `draw()`，按照正文中的样式将树绘制出来。**提示**：在结点中用变量保存坐标并用递归的方法设置这些变量。

###实验题

**3.2.39**　**平均情况**。用经验数据评估在一棵由 ![N](https://private.codecogs.com/gif.latex?N) 个随机结点构造的二叉查找树中，一次命中的查找和未命中的查找平均所需的比较次数的平均差和标准差，其中 ![N=10^4](https://private.codecogs.com/gif.latex?N=10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)，重复实验 100 遍。将你的实验结果和练习 3.2.35 给出的计算平均比较次数的公式进行对比。

**3.2.40**　**树的高度**。用经验数据评估一棵由 ![N](https://private.codecogs.com/gif.latex?N) 个随机结点构造的二叉查找树的平均高度，其中 ![N=10^4](https://private.codecogs.com/gif.latex?N=10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)，重复实验 100 遍。将你的试验结果和正文中给出的估计值 ![2.99\lg N](https://private.codecogs.com/gif.latex?2.99\lg%20N) 进行对比。

**3.2.41**　**数组表示**。开发一个二叉查找树的实现，用三个数组表示一棵树（预先分配为构造函数中所指定的最大长度）：一个数组用来保存键，一个数组用来保存左链接的索引，一个数组用来保存右链接的索引。比较你的程序和标准实现的性能。

**3.2.42**　**Hibbard 删除方法的性能问题**。编写一个程序，从命令行接受一个参数 ![N](https://private.codecogs.com/gif.latex?N) 并构造一棵由 ![N](https://private.codecogs.com/gif.latex?N) 个随机键生成的二叉查找树，然后进入一个循环。在循环中它先删除一个随机键（`delete(select(StdRandom.uniform(N)))`），然后再插入一个随机键，如此循环 ![N^2](https://private.codecogs.com/gif.latex?N^2) 次。循环结束后，计算并打印树的内部平均路径长度（内部路径长度除以 ![N](https://private.codecogs.com/gif.latex?N) 再加 1）。对于 ![N=10^2](https://private.codecogs.com/gif.latex?N=10^2)、![10^3](https://private.codecogs.com/gif.latex?10^3) 和 ![10^4](https://private.codecogs.com/gif.latex?10^4)，运行你的程序来验证一个有些违反直觉的假设：这个过程会增加树的平均路径长度，增加的长度和 ![N](https://private.codecogs.com/gif.latex?N) 的平方根成正比。使用能够随机选择前趋或后继结点的 `delete()` 方法重复这个实验。

**3.2.43**　**`put()`/`get()` 方法的比例**。用经验数据评估当使用 `FrequencyCounter` 来统计 100 万个随机整数中每个数的出现频率时，二叉查找树中 `put()` 方法和 `get()` 方法所消耗的时间的比例。

**3.2.44**　**绘制成本图**。改造二叉查找树的实现来绘制本节所示的那种能够显示计算中每次 `put()` 操作成本的图。

**3.2.45**　**实际耗时**。改造 `FrequencyCounter`，使用 `Stopwatch` 和 `StdDraw` 绘图，其中 ![x](https://private.codecogs.com/gif.latex?x) 轴表示 `get()` 和 `put()` 调用的总数，![y](https://private.codecogs.com/gif.latex?y) 轴为总运行时间，每次调用之后即在当前运行时间处绘制一个点。使用 `SequentialSearchST` 和你的程序处理《双城记》，再用 `BinarySearchST` 处理一遍，最后用二叉查找树处理一遍，然后讨论运行的结果。**注意**：曲线中突然的跳跃可能是**缓存**导致的，这已经超出了这个问题的讨论范围（请见练习 3.1.39）。

**3.2.46**　**二叉查找树的临界点**。使用随机 `double` 值作为键，分别找出使得二叉查找树的符号表比二分查找要快 10、100 倍和 1000 倍的 ![N](https://private.codecogs.com/gif.latex?N) 值。分析并预测 ![N](https://private.codecogs.com/gif.latex?N) 的大小并通过实验验证它。

**3.2.47**　**平均查找耗时**。用实验研究和计算在一棵由 ![N](https://private.codecogs.com/gif.latex?N) 个随机结点构造的二叉查找树中到达任意结点的平均路径长度（内部路径长度除以 ![N](https://private.codecogs.com/gif.latex?N) 再加 1）的平均差和标准差，对于 100 到 10 000 之间的每个 ![N](https://private.codecogs.com/gif.latex?N) 重复实验 1000 遍。将结果绘制成和图 3.2.14 相似的一张 Tufte 图，并画上函数 ![1.39\lg N-1.85](https://private.codecogs.com/gif.latex?1.39\lg%20N-1.85) 的曲线（请见练习 3.2.35 和练习 3.2.39）。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.023.png)

**图 3.2.14　一棵随机构造的二叉查找树中由根到达任意结点的平均路径长度**

##3.3　平衡查找树

我们在前面几节中学习过的算法已经能够很好地用于许多应用程序中，但它们在最坏情况下的性能还是很糟糕。在本节中我们会介绍一种二分查找树并能**保证**无论如何构造它，它的运行时间都是对数级别的。理想情况下我们希望能够保持二分查找树的平衡性。在一棵含有 ![N](https://private.codecogs.com/gif.latex?N) 个结点的树中，我们希望树高为 ![\sim\lg N](https://private.codecogs.com/gif.latex?\sim\lg%20N)，这样我们就能保证所有查找都能在 ![\sim\lg N](https://private.codecogs.com/gif.latex?\sim\lg%20N) 次比较内结束，就和二分查找一样（请见命题 B）。不幸的是，在动态插入中保证树的完美平衡的代价太高了。在本节中，我们稍稍放松完美平衡的要求并将学习一种能够保证符号表 API 中所有操作（范围查找除外）均能够在对数时间内完成的数据结构。

###3.3.1　2-3 查找树

为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切地说，我们将一棵标准的二叉查找树中的结点称为 2- **结点**（含有一个键和两条链接），而现在我们引入 3- **结点**，它含有两个键和三条链接。2- 结点和 3- 结点中的每条链接都对应着其中保存的键所分割产生的一个区间。

>**定义**。一棵 2-3 **查找树**或为一棵空树，或由以下结点组成：

>* 2- 结点，含有一个键（及其对应的值）和两条链接，左链接指向的 2-3 树中的键都小于该结点，右链接指向的 2-3 树中的键都大于该结点。
>* 3- 结点，含有两个键（及其对应的值）和三条链接，左链接指向的 2-3 树中的键都小于该结点，中链接指向的 2-3 树中的键都位于该结点的两个键之间，右链接指向的 2-3 树中的键都大于该结点。

>和以前一样，我们将指向一棵空树的链接称为**空链接**。2-3 查找树如图 3.3.1 所示。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.024.png)

**图 3.3.1　2-3 查找树示意图**

一棵**完美平衡**的 2-3 查找树中的所有空链接到根结点的距离都应该是相同的。简洁起见，这里我们用 2-3 **树**指代一棵完美平衡的 2-3 查找树（在其他情况下这个词应该表示一种更一般的结构）。稍后我们将会学习定义并高效地实现 2- 结点、3- 结点和 2-3 树的基本操作。现在先假设我们已经能够自如地操作它们并来看看应该如何将它们用作查找树。

####3.3.1.1　查找

将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。具体查找过程如图 3.3.2 所示。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.025.png)

**图 3.3.2　2-3 树中的查找命中（左）和未命中（右）**

####3.3.1.2　向 2- 结点中插入新键

要在 2-3 树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。我们使用 2-3 树的主要原因就在于它能够在插入后继续保持平衡。如果未命中的查找结束于一个 2- 结点，事情就好办了：我们只要把这个 2- 结点替换为一个 3- 结点，将要插入的键保存在其中即可（如图 3.3.3 所示）。如果未命中的查找结束于一个 3- 结点，事情就要麻烦一些。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.026.png)

**图 3.3.3　向 2- 结点中插入新的键**

####3.3.1.3　向一棵只含有一个 3- 结点的树中插入新键

在考虑一般情况之前，先假设我们需要向一棵只含有一个 3- 结点的树中插入一个新键。这棵树中有两个键，所以在它唯一的结点中已经没有可插入新键的空间了。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个 4- **结点**。它很自然地扩展了以前的结点并含有 3 个键和 4 条链接。创建一个 4- 结点很方便，因为很容易将它转换为一棵由 3 个 2- 结点组成的 2-3 树，其中一个结点（根）含有中键，一个结点含有 3 个键中的最小者（和根结点的左链接相连），一个结点含有 3 个键中的最大者（和根结点的右链接相连）。这棵树既是一棵含有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 树，因为其中所有的空链接到根结点的距离都相等。插入前树的高度为 0，插入后树的高度为 1。这个例子很简单但却值得学习，它说明了 2-3 树是如何生长的，如图 3.3.4 所示。

![{%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.027.png)

**图 3.3.4　向一棵只含有一个 3- 结点的树中插入新键**

####3.3.1.4　向一个父结点为 2- 结点的 3- 结点中插入新键

作为第二轮热身，假设未命中的查找结束于一个 3- 结点，而它的父结点是一个 2- 结点。在这种情况下我们需要**在维持树的完美平衡的前提下为新键腾出空间**。我们先像刚才一样构造一个临时的 4- 结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中。你可以将这次转换看成将指向原 3- 结点的一条链接替换为新父结点中的原中键左右两边的两条链接，并分别指向两个新的 2- 结点。根据我们的假设，父结点中是有空间的：父结点是一个 2- 结点（一个键两条链接），插入之后变为了一个 3- 结点（两个键 3 条链接）。另外，这次转换也并不影响（完美平衡的）2-3 树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，插入后所有的空链接到根结点的距离仍然相同。请确认你完全理解了这次转换——它是 2-3 树的动态变化的核心，其过程如图 3.3.5 所示。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.028.png)

**图 3.3.5　向一个父结点为 2- 结点的 3- 结点中插入新键**

####3.3.1.5　向一个父结点为 3- 结点的 3- 结点中插入新键

现在假设未命中的查找结束于一个父结点为 3- 结点的结点。我们再次和刚才一样构造一个临时的 4- 结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个 3- 结点，因此我们再用这个中键构造一个新的临时 4- 结点，然后**在这个结点上进行相同的变换**，即分解这个父结点并将**它的**中键插入到**它的**父结点中去。推广到一般情况，我们就这样一直向上不断分解临时的 4- 结点并将中键插入更高层的父结点，直至遇到一个 2- 结点并将它替换为一个不需要继续分解的 3- 结点，或者是到达 3- 结点的根。该过程如图 3.3.6 所示。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.029.png)

**图 3.3.6　向一个父结点为 3- 结点的 3- 结点中插入新键**

####3.3.1.6　分解根结点

如果从插入结点到根结点的路径上全都是 3- 结点，我们的根结点最终变成一个临时的 4- 结点。此时我们可以按照向一棵只有一个 3- 结点的树中插入新键的方法处理这个问题。我们将临时的 4- 结点分解为 3 个 2- 结点，使得树高加 1，如图 3.3.7 所示。请注意，这次最后的变换仍然保持了树的完美平衡性，因为它变换的是根结点。

![{40%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.030.png)

**图 3.3.7　分解根结点**

####3.3.1.7　局部变换

将一个 4- 结点分解为一棵 2-3 树可能有 6 种情况，都总结在了图 3.3.8 中。这个 4- 结点可能是根结点，可能是一个 2- 结点的左子结点或者右子结点，也可能是一个 3- 结点的左子结点、中子结点或者右子结点。2-3 树插入算法的根本在于这些变换都是**局部的**：除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。需要特别指出的是，不光是在树的底部，树中的**任何地方**只要符合相应的模式，变换都可以进行。每个变换都会将 4- 结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。

![{93%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.031.png)

**图 3.3.8　在一棵 2-3 树中分解一个 4- 结点的情况汇总**

####3.3.1.8　全局性质

这些**局部**变换不会影响树的**全局**有序性和平衡性：任意空链接到根结点的路径长度都是相等的。作为参考，图 3.3.9 所示的是当一个 4- 结点是一个 3- 结点的中子结点时的完整变换情况。如果在变换之前根结点到所有空链接的路径长度为 ![h](https://private.codecogs.com/gif.latex?h)，那么变换之后该长度仍然为 ![h](https://private.codecogs.com/gif.latex?h)。所有的变换都具有这个性质，即使是将一个 4- 结点分解为两个 2- 结点并将其父结点由 2- 结点变为 3- 结点，或是由 3- 结点变为一个临时的 4- 结点时也是如此。当根结点被分解为 3 个 2- 结点时，所有空链接到根结点的路径长度才会加 1。如果你还没有完全理解，请完成练习 3.3.7。它要求你为其他的 5 种情况画出图 3.3.8 的扩展图来证明这一点。理解所有局部变换都不会影响整棵树的有序性和平衡性是理解这个算法的关键。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.032.png)

**图 3.3.9　4- 结点的分解是一次局部变换，不会影响树的有序性和平衡性**

和标准的二叉查找树由上向下生长不同，2-3 树的生长是由下向上的。如果你花点时间仔细研究一下图 3.3.10，就能很好地理解 2-3 树的构造方式。它给出了我们的标准索引测试用例中产生的一系列 2-3 树，以及一系列由同一组键按照升序依次插入到树中时所产生的所有 2-3 树。还记得在二叉查找树中，按照升序插入 10 个键会得到高度为 9 的一棵最差查找树吗？如果使用 2-3 树，树的高度是 2。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.033.png)

**图 3.3.10　2-3 树的构造轨迹**

以上的文字已经足够为我们定义一个使用 2-3 树作为数据结构的符号表的实现了。2-3 树的分析和二叉查找树的分析大不相同，因为我们主要感兴趣的是**最坏情况下**的性能，而非一般情况（这种情况下我们会用随机键模型分析预期的性能）。在符号表的实现中，一般我们无法控制用例会按照什么顺序向表中插入键，因此对最坏情况的分析是唯一能够提供性能保证的办法。

>**命题 F**。在一棵大小为 ![N](https://private.codecogs.com/gif.latex?N) 的 2-3 树中，查找和插入操作访问的结点必然不超过 ![\lg N](https://private.codecogs.com/gif.latex?\lg%20N) 个。

>**证明**。一棵含有 ![N](https://private.codecogs.com/gif.latex?N) 个结点的 2-3 树的高度在 ![\lfloor\log_3N\rfloor=\lfloor(\lg N)/(\lg3)\rfloor](https://private.codecogs.com/gif.latex?\lfloor\log_3N\rfloor=\lfloor(\lg%20N%29/(\lg3%29\rfloor)（如果树中全是 3- 结点）和 ![\lfloor\lg N\rfloor](https://private.codecogs.com/gif.latex?\lfloor\lg%20N\rfloor)（如果树中全是 2- 结点）之间（请见练习 3.3.4）。

因此我们可以确定 2-3 树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。通过对比图 3.3.11 中的 2-3 树和图 3.2.8 中由相同的键构造的二叉查找树，你也可以看到，完美平衡的 2-3 树要平展得多。例如，含有 10 亿个结点的一棵 2-3 树的高度仅在 19 到 30 之间。我们最多只需要访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是相当惊人的。

![{83%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.034.png)

**图 3.3.11　由随机键构造的一棵典型的 2-3 树**

但是，我们和真正的实现还有一段距离。尽管我们可以用不同的数据类型表示 2- 结点和 3- 结点并写出变换所需的代码，但用这种直白的表示方法实现大多数的操作并不方便，因为需要处理的情况实在太多。我们需要维护两种不同类型的结点，将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。幸运的是你将看到，我们只需要一点点代价就能用一种统一的方式完成所有变换。

###3.3.2　红黑二叉查找树

上文所述的 2-3 树的插入算法并不难理解，现在我们会看到它也不难实现。我们要学习一种名为**红黑二叉查找树**的简单数据结构来表达并实现它。最后的代码量并不大，但理解这些代码是如何工作的以及为什么能够工作却需要一番仔细的探究。

####3.3.2.1　替换 3- 结点

红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由 2- 结点构成）和一些额外的信息（替换 3- 结点）来表示 2-3 树。我们将树中的链接分为两种类型：**红链接**将两个 2- 结点连接起来构成一个 3- 结点，**黑链接**则是 2-3 树中的普通链接。确切地说，我们将 3- 结点表示为由一条**左斜**的红色链接（两个 2- 结点其中之一是另一个的左子结点）相连的两个 2- 结点，如图 3.3.12 所示。这种表示法的一个优点是，我们**无需修改**就可以直接使用标准二叉查找树的 `get()` 方法。对于任意的 2-3 树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树。我们将用这种方式表示 2-3 树的二叉查找树称为**红黑二叉查找树**（以下简称为**红黑树**）。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.035.png)

**图 3.3.12　由一条红色左链接相连的两个 2- 结点表示一个 3- 结点**

####3.3.2.2　一种等价的定义

红黑树的另一种**定义**是含有红黑链接并满足下列条件的二叉查找树：

* 红链接均为左链接；
* 没有任何一个结点同时和两条红链接相连；
* 该树是**完美黑色平衡**的，即任意空链接到根结点的路径上的黑链接数量相同。

满足这样定义的红黑树和相应的 2-3 树是一一对应的。

####3.3.2.3　一一对应

如果我们将一棵红黑树中的红链接画平，那么所有的空链接到根结点的距离都将是相同的（如图 3.3.13 所示）。如果我们将由红链接相连的结点合并，得到的就是一棵 2-3 树。相反，如果将一棵 2-3 树中的 3- 结点画作由红色左链接相连的两个 2- 结点，那么不会存在能够和两条红链接相连的结点，且树必然是完美黑色平衡的，因为黑链接即 2-3 树中的普通链接，根据定义这些链接必然是完美平衡的。无论我们选择用何种方式去定义它们，红黑树都**既是**二叉查找树，**也是** 2-3 树，如图 3.3.14 所示。因此，如果我们能够在保持一一对应关系的基础上实现 2-3 树的插入算法，那么我们就能够将两个算法的优点结合起来：二叉查找树中简洁高效的查找方法和 2-3 树中高效的平衡插入算法。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.036.png)

**图 3.3.13　将红链接画平时，一棵红黑树就是一棵 2-3 树**

![{65%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.037.png)

**图 3.3.14　红黑树和 2-3 树的一一对应关系**

####3.3.2.4　颜色表示

方便起见，因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的 `Node` 数据类型的布尔变量 `color` 中。如果指向它的链接是红色的，那么该变量为 `true`，黑色则为 `false`。我们约定空链接为黑色。为了代码的清晰我们定义了两个常量 `RED` 和 `BLACK` 来设置和测试这个变量。我们使用私有方法 `isRed()` 来测试一个结点和它的父结点之间的链接的颜色。当我们提到一个结点的颜色时，我们指的是指向该结点的链接的颜色，反之亦然。颜色表示的代码实现如图 3.3.15 所示。

![{70%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.038.png)

**图 3.3.15　红黑树的结点表示**

####3.3.2.5　旋转

在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心地**旋转**并修复。旋转操作会改变红链接的指向。首先，假设我们有一条红色的右链接需要被转化为**左链接**（请见图 3.3.16）。这个操作叫做**左旋转**，它对应的方法接受一条指向红黑树中的某个结点的链接作为参数。假设被指向的结点的右链接是红色的，这个方法会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根结点的链接。如果你对照图示中调整前后的情况逐行阅读这段代码，你会发现这个操作很容易理解：我们只是将用两个键中的较小者作为根结点变为将较大者作为根结点。实现将一个红色左链接转换为一个红色右链接的一个**右旋转**的代码完全相同，只需要将 `left` 和 `right` 互换即可（如图 3.3.17 所示）。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.039.png)

**图 3.3.16　左旋转 `h` 的右链接**

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.040.png)

**图 3.3.17　右旋转 `h` 的左链接**

####3.3.2.6　在旋转后重置父结点的链接

无论左旋转还是右旋转，旋转操作都会返回一条链接。我们总是会用 `rotateRight()` 或 `rotateLeft()` 的返回值重置父结点（或是根结点）中相应的链接。返回的链接可能是左链接也可能是右链接，但是我们总会将它赋予父结点中的链接。这个链接可能是红色也可能是黑色—— `rotateLeft()` 和 `rotateRight()` 都通过将 `x.color` 设为 `h.color` 保留它原来的颜色。这可能会产生两条连续的红链接，但我们的算法会继续用旋转操作修正这种情况。例如，代码 `h = rotateLeft(h);` 将旋转结点 `h` 的红色右链接，使得 `h` 指向了旋转后的子树的根结点（组成该子树中的所有键和旋转前相同，只是根结点发生了变化）。这种简洁的代码是我们使用递归实现二叉查找树的各种方法的主要原因。你会看到，它使得旋转操作成为了普通插入操作的一个简单补充。

在插入新的键时我们可以使用旋转操作帮助我们保证 2-3 树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要性质：**有序性**和**完美平衡性**。也就是说，我们在红黑树中进行旋转时无需为树的有序性或者完美平衡性担心。下面我们来看看应该如何使用旋转操作来保持红黑树的另外两个重要性质（不存在两条连续的红链接和不存在红色的右链接）。我们先用一些简单的情况热热身。

####3.3.2.7　向单个 2- 结点中插入新键

一棵只含有一个键的红黑树只含有一个 2- 结点。插入另一个键之后，我们马上就需要将它们旋转。如果新键小于老键，我们只需要新增一个红色的结点即可，新的红黑树和单个 3- 结点完全等价。如果新键大于老键，那么新增的红色结点将会产生一条红色的右链接。我们需要使用 `root = rotateLeft(root);` 来将其旋转为红色左链接并修正根结点的链接，插入操作才算完成。两种情况的结果均为一棵和单个 3- 结点等价的红黑树，其中含有两个键，一条红链接，树的黑链接高度为 1，如图 3.3.18 所示。

![{46%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.041.png)

**图 3.3.18　向单个 2- 结点中插入一个新键**

####3.3.2.8　向树底部的 2- 结点插入新键

用和二叉查找树相同的方式向一棵红黑树中插入一个新键会在树的底部新增一个结点（为了保证有序性），但总是用红链接将新结点和它的父结点相连。如果它的父结点是一个 2- 结点，那么刚才讨论的两种处理方法仍然适用。如果指向新结点的是父结点的左链接，那么父结点就直接成为了一个 3- 结点；如果指向新结点的是父结点的右链接，这就是一个错误的 3- 结点，但一次左旋转就能够修正它，如图 3.3.19 所示。

![{40%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.042.png)

**图 3.3.19　向树底部的 2- 结点插入一个新键**

####3.3.2.9　向一棵双键树（即一个 3- 结点）中插入新键

这种情况又可分为三种子情况：新键小于树中的两个键，在两者之间，或是大于树中的两个键。每种情况中都会产生一个同时连接到两条红链接的结点，而我们的目标就是修正这一点。

* 三者中最简单的情况是新键**大于**原树中的两个键，因此它被连接到 3- 结点的右链接。此时树是平衡的，根结点为中间大小的键，它有两条红链接分别和较小和较大的结点相连。如果我们将两条链接的颜色都由红变黑，那么我们就得到了一棵由三个结点组成、高为 2 的平衡树。它正好能够对应一棵 2-3 树，如图 3.3.20（左）。其他两种情况最终也会转化为这种情况。
* 如果新键**小于**原树中的两个键，它会被连接到最左边的空链接，这样就产生了两条连续的红链接，如图 3.3.20（中）。此时我们只需要将上层的红链接右旋转即可得到第一种情况（中值键为根结点并和其他两个结点用红链接相连）。
* 如果新键介于原树中的两个键**之间**，这又会产生两条连续的红链接，一条红色左链接接一条红色右链接，如图 3.3.20（右）。此时我们只需要将下层的红链接左旋转即可得到第二种情况（两条连续的红色左链接）。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.043.png)

**图 3.3.20　向一棵双键树（即一个 3- 结点）中插入一个新键的三种情况**

总的来说，我们通过 0 次、1 次和 2 次旋转以及颜色的变化得到了期望的结果。在 2-3 树中，**请确认你完全理解了这些转换**，它们是红黑树的动态变化的关键。

####3.3.2.10　颜色转换

如图 3.3.21 所示，我们专门用一个方法 `flipColors()` 来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑之外，我们同时还要将父结点的颜色由黑变红。这项操作最重要的性质在于它和旋转操作一样是局部变换，不会影响**整棵树的黑色平衡性**。根据这一点，我们马上能够在下面完整地实现红黑树。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.044.png)

**图 3.3.21　通过转换链接的颜色来分解 4- 结点**

####3.3.2.11　根结点总是黑色

在 3.3.2.9 所述的情况中，颜色转换会使根结点变为红色。这也可能出现在很大的红黑树中。严格地说，红色的根结点说明根结点是一个 3- 结点的一部分，但实际情况并不是这样。因此我们在每次插入后都会将根结点设为黑色。注意，每当根结点由红变黑时树的黑链接高度就会加 1。

####3.3.2.12　向树底部的 3- 结点插入新键

现在假设我们需要在树的底部的一个 3- 结点下加入一个新结点。前面讨论过的三种情况都会出现，如图 3.3.22 所示。指向新结点的链接可能是 3- 结点的右链接（此时我们只需要转换颜色即可），或是左链接（此时我们需要进行右旋转然后再转换颜色），或是中链接（此时我们需要先左旋转下层链接然后右旋转上层链接，最后再转换颜色）。颜色转换会使到中结点的链接变红，相当于将它送入了父结点。这意味着在父结点中继续插入一个新键，我们也会继续用相同的办法解决这个问题。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.045.png)

**图 3.3.22 向树底部的 3- 结点插入一个新键**

####3.3.2.13　将红链接在树中向上传递

2-3 树中的插入算法需要我们分解 3- 结点，将中间键插入父结点，如此这般直到遇到一个 2- 结点或是根结点。我们所考虑过的所有情况都正是为了达成这个目标：每次必要的旋转之后我们都会进行颜色转换，这使得中结点变红。在父结点看来，处理这样一个红色结点的方式和处理一个新插入的红色结点完全相同，即继续把红链接转移到中结点上去。图 3.3.23 中总结的三种情况显示了在红黑树中实现 2-3 树的插入算法的关键操作所需的步骤：要在一个 3- 结点下插入新键，先创建一个临时的 4- 结点，将其分解并将红链接由中间键传递给它的父结点。重复这个过程，我们就能将红链接在树中向上传递，直至遇到一个 2- 结点或者根结点。

![{75%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.046.png)

**图 3.3.23　红黑树中红链接向上传递**

总之，只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作，我们就能够保证插入操作后红黑树和 2-3 树的一一对应关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：

* 如果右子结点是红色的而左子结点是黑色的，进行左旋转；
* 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；
* 如果左右子结点均为红色，进行颜色转换。

你应该花点时间确认以上步骤处理了前文描述的所有情况。请注意，第一个操作表示将一个 2- 结点变为一个 3- 结点和插入的新结点与树底部的 3- 结点通过它的中链接相连的两种情况。

###3.3.3　实现

因为保持树的平衡性所需的操作是**由下向上**在每个所经过的结点中进行的，将它们植入我们已有的实现中十分简单：只需要在递归调用之后完成这些操作即可，如算法 3.4 所示。上一段中列出的三种操作都可以通过一个检测两个结点的颜色的 `if` 语句完成。尽管实现所需的代码量很小，但如果没有我们学习过的两种抽象数据结构（2-3 树和红黑树）作为铺垫，这段实现仍然会非常难以理解。在检查了三到五个结点的颜色之后（也许还需要进行一两次旋转以及颜色转换），我们就可以得到一棵近乎完美平衡的二叉查找树。

>**算法 3.4　红黑树的插入算法**

>```
>public class RedBlackBST<Key extends Comparable<Key>, Value>
>{
>
>    private Node root;
>
>    private class Node // 含有color变量的Node对象（请见3.3.2.4节）
>
>    private boolean isRed(Node h)    // 请见3.3.2.4节
>    private Node rotateLeft(Node h)  // 请见图3.3.16
>    private Node rotateRight(Node h) // 请见图3.3.17
>    private void flipColors(Node h)  // 请见图3.3.21
>
>    private int size()               // 请见算法3.3
>
>    public void put(Key key, Value val)
>    {  // 查找key，找到则更新其值，否则为它新建一个结点
>       root = put(root, key, val);
>       root.color = BLACK;
>    }
>
>    private Node put(Node h, Key key, Value val)
>    {
>       if (h == null)  // 标准的插入操作，和父结点用红链接相连
>          return new Node(key, val, 1, RED);
>
>       int cmp = key.compareTo(h.key);
>       if      (cmp < 0) h.left  = put(h.left,  key, val);
>       else if (cmp > 0) h.right = put(h.right, key, val);
>       else h.val = val;
>
>       if (isRed(h.right) && !isRed(h.left))    h = rotateLeft(h);
>       if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
>       if (isRed(h.left) && isRed(h.right))     flipColors(h);
>
>       h.N = size(h.left) + size(h.right) + 1;
>       return h;
>    }
>}
>```

>除了递归调用后的三条 `if` 语句，红黑树中 `put()` 的递归实现和二叉查找树中 `put()` 的实现完全相同。它们在查找路径上保证了红黑树和 2-3 树的一一对应关系，使得树的平衡性接近完美。第一条 `if` 语句会将任意含有红色右链接的 3- 结点（或临时的 4- 结点）向左旋转；第二条 `if` 语句会将临时的 4- 结点中两条连续红链接中的上层链接向右旋转；第三条 `if` 语句会进行颜色转换并将红链接在树中向上传递（详情请见正文）。

图 3.3.24 给出了使用我们的标准索引测试用例进行测试的轨迹和用同一组键按照升序构造一棵红黑树的测试轨迹。仅从红黑树的三种标准操作的角度分析这些例子对我们理解问题很有帮助，之前我们也是这样做的。另一个基本练习是检查它们和 2-3 树的一一对应关系（可以对比图 3.3.10 中由同一组键构造的 2-3 树）。在两种情况中你都能通过思考**将 P 插入红黑树**所需的转换来检验你对算法的理解程度（请见练习 3.3.12）。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.047.png)

**图 3.3.24　红黑树的构造轨迹**

###3.3.4　删除操作

算法 3.4 中的 `put()` 方法是本书中最复杂的实现之一，而红黑树的 `deleteMin()`、`deleteMax()` 和 `delete()` 的实现更麻烦，我们将它们的完整实现留做练习，但这里仍然需要学习它们的基本原理。要描述删除算法，首先我们要回到 2-3 树。和插入操作一样，我们也可以定义一系列局部变换来在删除一个结点的同时保持树的完美平衡性。这个过程比插入一个结点更加复杂，因为我们不仅要在（为了删除一个结点而）构造临时 4- 结点时沿着查找路径**向下**进行变换，还要在分解遗留的 4- 结点时沿着查找路径**向上**进行变换（同插入操作）。

####3.3.4.1　自顶向下的 2-3-4 树

作为第一轮热身，我们先学习一个沿查找路径既能向上也能向下进行变换的稍简单的算法：2-3-4 树的插入算法，2-3-4 **树**中允许存在我们以前见过的 4- 结点。它的插入算法沿查找路径向下进行变换是为了保证当前结点不是 4- 结点（这样树底才有空间来插入新的键），沿查找路径向上进行变换是为了将之前创建的 4- 结点配平，如图 3.3.25 所示。向下的变换和我们在 2-3 树中分解 4- 结点所进行的变换**完全相同**。如果根结点是 4- 结点，我们就将它分解成三个 2- 结点，使得树高加 1。在向下查找的过程中，如果遇到一个父结点为 2- 结点的 4- 结点，我们将 4- 结点分解为两个 2- 结点并将中间键传递给它的父结点，使得父结点变为一个 3- 结点；如果遇到一个父结点为 3- 结点的 4- 结点，我们将 4- 结点分解为两个 2- 结点并将中间键传递给它的父结点，使得父结点变为一个 4- 结点；我们不必担心会遇到父结点为 4- 结点的 4- 结点，因为插入算法本身就保证了这种情况不会出现。到达树的底部之后，我们也只会遇到 2- 结点或者 3- 结点，所以我们可以插入新的键。要用红黑树实现这个算法，我们需要：

* 将 4- 结点表示为由三个 2- 结点组成的一棵平衡的子树，根结点和两个子结点都用红链接相连；
* 在**向下**的过程中分解所有 4- 结点并进行颜色转换；
* 和插入操作一样，在**向上**的过程中用旋转将 4- 结点配平{2[因为4-结点可以存在，所以可以允许一个结点同时连接到两条链接。——译者注]}。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.048.png)

**图 3.3.25　自顶向下的 2-3-4 树的插入算法中的变换**

令人惊讶的是，你只需要移动算法 3.4 的 `put()` 方法中的一行代码就能实现 2-3-4 树中的插入操作：将 `colorFlip()` 语句（及其 `if` 语句）移动到递归调用之前（`null` 测试和比较操作之间）。在多个进程可以同时访问同一棵树的应用中这个算法优于 2-3 树，因为它操作的总是当前结点的一个或两个链接。我们下面要讲的删除算法和它的插入算法类似，而且也适用于 2-3 树。

####3.3.4.2　删除最小键

在第二轮热身中我们要学习 2-3 树中删除最小键的操作。我们注意到从树底部的 3- 结点中删除键是很简单的，但 2- 结点则不然。从 2- 结点中删除一个键会留下一个空结点，一般我们会将它替换为一个空链接，但这样会破坏树的完美平衡性。所以我们需要这样做：为了保证我们不会删除一个 2- 结点，我们沿着左链接向下进行变换，确保当前结点不是 2- 结点（可能是 3- 结点，也可能是临时的 4- 结点）。首先，根结点可能有两种情况。如果根是 2- 结点且它的两个子结点都是 2- 结点，我们可以直接将这三个结点变成一个 4- 结点；否则我们需要保证根结点的左子结点不是 2- 结点，如有必要可以从它右侧的兄弟结点“借”一个键来。以上情况如图 3.3.26 所示。在沿着左链接向下的过程中，保证以下情况之一成立：

* 如果当前结点的左子结点不是 2- 结点，完成；
* 如果当前结点的左子结点是 2- 结点而它的亲兄弟结点不是 2- 结点，将左子结点的兄弟结点中的一个键移动到左子结点中；
* 如果当前结点的左子结点和它的亲兄弟结点都是 2- 结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个 4- 结点，使父结点由 3- 结点变为 2- 结点或者由 4- 结点变为 3- 结点。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.049.png)

**图 3.3.26　删除最小键操作中的变换**

在遍历的过程中执行这个过程，最后能够得到一个含有最小键的 3- 结点或者 4- 结点，然后我们就可以直接从中将其删除，将 3- 结点变为 2- 结点，或者将 4- 结点变为 3- 结点。然后我们再回头向上分解所有临时的 4- 结点。

####3.3.4.3　删除操作

在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是 2- 结点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后继结点交换，就和二叉查找树一样。因为当前结点必然不是 2- 结点，问题已经转化为在一棵根结点不是 2- 结点的子树中删除最小的键，我们可以在这棵子树中使用前文所述的算法。和以前一样，删除之后我们需要向上回溯并分解余下的 4- 结点。

本节末尾的练习中有几道是关于这些删除算法的例子和实现的。有兴趣理解或实现删除算法的读者应该掌握这些练习中的细节。对算法研究感兴趣的读者应该认识到这些方法的重要性，因为这是我们见过的第一种能够同时实现高效的**查找**、**插入**和**删除**操作的符号表实现。下面我们将会验证这一点。

###3.3.5　红黑树的性质

研究红黑树的性质就是要检查对应的 2-3 树并对相应的 2-3 树进行分析的过程。我们的最终结论是**所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别**（范围查找除外，它所需的额外时间和返回的键的数量成正比）。我们重复并强调这一点是因为它十分重要。

####3.3.5.1　性能分析

首先，无论键的插入顺序如何，红黑树都几乎是完美平衡的（请见图 3.3.27）。这从它和 2-3 树的一一对应关系以及 2-3 树的重要性质可以得到。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.050.png)

**图 3.3.27　使用随机键构造的典型红黑树，没有画出空链接**

>**命题 G**。一棵大小为 ![N](https://private.codecogs.com/gif.latex?N) 的红黑树的高度不会超过 ![2\lg N](https://private.codecogs.com/gif.latex?2\lg%20N)。

>**简略的证明**。红黑树的最坏情况是它所对应的 2-3 树中构成最左边的路径结点全部都是 3- 结点而其余均为 2- 结点。最左边的路径长度是只包含 2- 结点的路径长度（![\sim\lg N](https://private.codecogs.com/gif.latex?\sim\lg%20N)）的两倍。要按照某种顺序构造一棵平均路径长度为 ![2\lg N](https://private.codecogs.com/gif.latex?2\lg%20N) 的最差红黑树虽然可能，但并不容易。如果你喜欢数学，你也许会喜欢在练习 3.3.24 中探究这个问题的答案。

这个上界是比较保守的。使用随机的键序列和典型应用中常见的键序列进行的实验都证明，在一棵大小为 ![N](https://private.codecogs.com/gif.latex?N) 的红黑树中一次查找所需的比较次数约为（![1.00\lg N-0.5](https://private.codecogs.com/gif.latex?1.00\lg%20N-0.5)）。另外，在实际情况下你不太可能遇到比这个数字高得多的平均比较次数，如表 3.3.1 所示。

**表 3.3.1　使用 `RedBlackBST` 的 `FrequencyCounter` 的每次 `put()` 操作平均所需的比较次数**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="3"></th><th colspan="4">tale.txt</th><th colspan="4">leipzig1M.txt</th></tr>
<tr><th rowspan="2">单词数</th><th rowspan="2">不同单词数</th><th colspan="2">比较次数</th><th rowspan="2">单词数</th><th rowspan="2">不同单词数</th><th colspan="2">比较次数</th></tr>
<tr><th>模型预测</th><th>实际次数</th><th>模型预测</th><th>实际次数</th></tr>
<tr><td>所有单词</td><td>135 635</td><td>10 679</td><td>13.6</td><td>13.5</td><td>21 191 455</td><td>534 580</td><td>19.4</td><td>19.1</td></tr>
<tr><td>长度大于等于 8 的单词</td><td>14 350</td><td>5 131</td><td>12.6</td><td>12.1</td><td>4 239 597</td><td>299 593</td><td>18.7</td><td>18.4</td></tr>
<tr><td>长度大于等于 10 的单词</td><td>4 582</td><td>2 260</td><td>11.4</td><td>11.5</td><td>1 610 829</td><td>165 555</td><td>17.5</td><td>17.3</td></tr>
</table>

>**命题 H**。一棵大小为 ![N](https://private.codecogs.com/gif.latex?N) 的红黑树中，根结点到任意结点的平均路径长度为 ![\sim1.00\lg N](https://private.codecogs.com/gif.latex?\sim1.00\lg%20N)。

>**例证**。和典型的二叉查找树（例如图 3.2.8 中所示的树）相比，一棵典型的红黑树的平衡性是很好的，例如图 3.3.27 所示（甚至是图 3.3.28 中由升序键列构造的红黑树）。表 3.3.1 显示的数据表明 `FrequencyCounter` 在运行中构造的红黑树的路径长度（即查找成本）比初等二叉查找树低 40% 左右，和预期相符。自红黑树的发明以来，无数的实验和实际应用都印证了这种性能改进。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.051.png)

**图 3.3.28　使用升序键列构造的一棵红黑树，没有画出空链接**

以使用 `FrequencyCounter` 在处理长度大于等于 8 的单词时 `put()` 操作的成本为例，我们可以看到平均成本降低得更多（如图 3.3.29 所示）。这又一次验证了理论模型所预测的对数级别的运行时间，只不过这次的惊喜比二叉查找树的小，因为性质 G 已经向我们保证了这一点。节约的总成本低于在查找上节约的 40% 的成本，因为除了比较我们也统计了旋转和颜色变换的次数。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.052.png)

**图 3.3.29　使用 `RedBlackBST`，运行 `java FrequencyCounter 8 < tale.txt` 的成本**

红黑树的 `get()` 方法不会检查结点的颜色，因此平衡性相关的操作不会产生任何负担；因为树是平衡的，所以查找比二叉查找树更快。每个键只会被插入一次，但却可能被查找无数次，因此最后我们只用了很小的代价（和二分查找不同，我们可以保证插入操作是对数级别的）就取得了和最优情况近似的查找时间（因为树是接近完美平衡的，且查找过程中不会进行任何平衡性的操作）。查找的内循环只会进行一次比较并更新一条链接，非常简短，和二分查找的内循环类似（只有比较和索引运算）。这是我们见到的第一个能够保证对数级别的查找和插入操作的实现，它的内循环更紧凑。它通过了各种应用的考验，包括许多库实现。

####3.3.5.2　有序符号表 API 

红黑树最吸引人的一点是它的实现中最复杂的代码仅限于 `put()`（和删除）方法。二叉查找树中的查找最大和最小键、`select()`、`rank()`、`floor()`、`ceiling()` 和范围查找方法**不做任何变动**即可继续使用，因为红黑树也是二叉查找树而这些操作也不会涉及结点的颜色。算法 3.4 和这些方法（以及删除方法）一起完整地实现了我们的有序符号表 API。这些方法都能从红黑树近乎完美的平衡性中受益，因为它们最多所需的时间都和树高成正比。因此命题 G 和命题 E 一起保证了**所有操作**的运行时间是对数级别的。

>**命题 I**。在一棵红黑树中，以下操作在最坏情况下所需的时间是对数级别的：查找（`get()`）、插入（`put()`）、查找最小键、查找最大键、`floor()`、`ceiling()`、`rank()`、`select()`、删除最小键（`deleteMin()`）、删除最大键（`deleteMax()`）、删除（`delete()`）和范围查询（`range()`）。

>**证明**。我们已经讨论过 `put()`、`get()` 和 `delete()` 方法。对于其他方法，代码可以从 3.2 节中照搬（它们不涉及结点颜色）。命题 G 和命题 E 可以保证算法是对数级别的，所有操作在所经过的结点上只会进行常数次数的操作也说明了这一点。

各种符号表实现的性能总结如表 3.3.2 所示。

**表 3.3.2　各种符号表实现的性能总结**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="2">算法（数据结构）</th><th colspan="2">最坏情况下的运行时间的增长数量级（<i>N</i>次插入之后）</th><th colspan="2">平均情况下的运行时间的增长数量级（<i>N</i>次随机插入之后）</th><th rowspan="2">是否支持有序性相关的操作</th></tr>
<tr><th>查找</th><th>插入</th><th>查找</th><th>插入</th></tr>
<tr><td>顺序查询（无序链表）</td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N/2" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td>否</td></tr>
<tr><td>二分查找（有序数组）</td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N/2" /></td><td>是</td></tr>
<tr><td>二叉树查找（BST）</td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.39\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.39\lg%20N" /></td><td>是</td></tr>
<tr><td>2-3 树查找（红黑树）</td><td><img src="https://private.codecogs.com/gif.latex?2\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?2\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.00\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.00\lg%20N" /></td><td>是</td></tr>
</table>

想想看，这样的保证是一个非凡的成就。在信息世界的汪洋大海中，表的大小可能上千亿，但我们仍能够确保在几十次比较之内就完成这些操作。

###答疑

**问**　为什么不允许存在红色右链接和 4- 结点？

**答**　它们都是可用的，并且已经应用了几十年了。在练习中你会遇到它们。只允许红色左链接的存在能够减少可能出现的情况，因此实现所需的代码会少得多。

**问**　为什么不在 `Node` 类型中使用一个 `Key` 类型的数组来表示 2- 结点、3- 结点和 4- 结点？

**答**　问得好。这正是我们在 B- 树（请见第６章）的实现中使用的方案，它的每个结点中可以保存更多的键。因为 2-3 树中的结点较少，数组所带来的额外开销太高了。

**问**　在分解一个 4- 结点时，我们有时会在 `rotateRight()` 中将右结点的颜色设为 `RED`（红）然后立即在 `flipColors()` 中将它的颜色变为 `BLACK`（黑）。这不是浪费时间吗？

**答**　是的，有时我们还会不必要地反复改变中结点的颜色。从整体来看，多余的几次颜色变换和将所有方法的运行时间的增长数量级从线性级别提升到对数级别不是一个级别的。当然，在有性能要求的应用中，你可以将 `rotateRight()` 和 `flipColors()` 的代码在所需要的地方展开来消除那些额外的开销。我们在删除中也会使用这两个方法。在能够保证树的完美平衡的前提下，它们更加容易使用、理解和维护。

###练习

**3.3.1**　将键 `E A S Y Q U T I O N` 按顺序插入一棵空 2-3 树并画出结果。

**3.3.2**　将键 `Y L P M X H C R A E S` 按顺序插入一棵空 2-3 树并画出结果。

**3.3.3**　使用什么顺序插入键 `S E A C H X M` 能够得到一棵高度为 1 的 2-3 树？

**3.3.4**　证明含有 ![N](https://private.codecogs.com/gif.latex?N) 个键的 2-3 树的高度在 ![\sim\lfloor\log_3N\rfloor](https://private.codecogs.com/gif.latex?\sim\lfloor\log_3N\rfloor) 即 ![0.63\lg N](https://private.codecogs.com/gif.latex?0.63\lg%20N)（树完全由 3- 结点组成）和 ![\sim\lfloor\lg N\rfloor](https://private.codecogs.com/gif.latex?\sim\lfloor\lg%20N\rfloor)（树完全由 2- 结点组成）之间。

**3.3.5**　右图显示了 ![N=1](https://private.codecogs.com/gif.latex?N=1) 到 6 之间大小为 ![N](https://private.codecogs.com/gif.latex?N) 的所有**不同的** 2-3 树（无先后次序）。请画出 ![N=7](https://private.codecogs.com/gif.latex?N=7)、8、9 和 10 的大小为 ![N](https://private.codecogs.com/gif.latex?N) 的所有不同的 2-3 树。

![{30%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.053.png)

**3.3.6**　计算用 ![N](https://private.codecogs.com/gif.latex?N) 个随机键构造练习 3.3.5 中每棵 2-3 树的概率。

**3.3.7**　以图 3.3.9 为例为图 3.3.8 中的其他 5 种情况画出相应的示意图。

**3.3.8**　画出使用三个 2- 结点和红链接一起表示一个 4- 结点的所有可能方法（不一定只能使用红色左链接）。

**3.3.9**　下图中哪些是红黑树（粗的链接为红色）？

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.054.png)

**3.3.10**　将含有键 `E A S Y Q U T I O N` 的结点按顺序插入一棵空红黑树并画出结果。

**3.3.11**　将含有键 `Y L P M X H C R A E S` 的结点按顺序插入一棵空红黑树并画出结果。

**3.3.12**　在我们的标准索引测试用例中插入键 `P` 并画出插入的过程中每次变换（颜色转换或是旋转）后的红黑树。

**3.3.13**　真假判断：如果你按照升序将键顺序插入一棵红黑树中，树的高度是单调递增的。

**3.3.14**　用字母 A 到 K 按顺序构造一棵红黑树并画出结果，然后大致说明在按照升序插入键来构造一棵红黑树的过程中发生了什么（可以参考正文中的图例）。

**3.3.15**　在键按照降序插入红黑树的情况下重新回答上面两道练习。

**3.3.16**　向右图所示的红黑树（黑色加粗部分的链接为红色）中插入 `n` 并画出结果（图中只显示了插入时的查找路径，你的解答中只需包含这些结点即可）。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.055.png)

**3.3.17**　随机生成两棵均含有 16 个结点的红黑树。画出它们（手绘或者代码绘制均可）并将它们和使用同一组键构造的（非平衡的）二叉查找树进行比较。

**3.3.18**　对于 2 到 10 之间的 ![N](https://private.codecogs.com/gif.latex?N)，画出所有大小为 ![N](https://private.codecogs.com/gif.latex?N) 的不同红黑树（请参考练习 3.3.5）。

**3.3.19**　每个结点只需要 1 位来保存结点的颜色即可表示 2- 结点、3- 结点和 4- 结点。使用二叉树，我们在每个结点需要几位信息才能表示 5- 结点、6- 结点、7- 结点和 8- 结点？

**3.3.20**　计算一棵大小为 ![N](https://private.codecogs.com/gif.latex?N) 且完美平衡的二叉查找树的内部路径长度，其中 ![N](https://private.codecogs.com/gif.latex?N) 为 2 的幂减 1。

**3.3.21**　基于你为练习 3.2.10 给出的答案编写一个测试用例 TestRB.java。

**3.3.22**　找出一组键的序列使得用它顺序构造的二叉查找树比用它顺序构造的红黑树的高度更低，或者证明这样的序列不存在。

###提高题

**3.3.23**　**没有平衡性限制的 2-3 树**。使用 2-3 树（不一定平衡）作为数据结构实现符号表的基本 API。树中的 3- 结点中的红链接可以左斜也可以右斜。树底部的 3- 结点和新结点通过**黑色**链接相连。实验并估计随机构造的这样一棵大小为 ![N](https://private.codecogs.com/gif.latex?N) 的树的平均路径长度。

**3.3.24**　**红黑树的最坏情况**。找出如何构造一棵大小为 ![N](https://private.codecogs.com/gif.latex?N) 的最差红黑树，其中从根结点到几乎所有空链接的路径长度均为 ![2\lg N](https://private.codecogs.com/gif.latex?2\lg%20N)。

**3.3.25**　**自顶向下的 2-3-4 树**。使用平衡 2-3-4 树作为数据结构实现符号表的基本 API。在树的表示中使用红黑链接并实现正文所述的插入算法，其中在沿查找路径向下的过程中分解 4- 结点并进行颜色转换，在回溯向上的过程中将 4- 结点配平。

**3.3.26**　**自顶向下一遍完成**。修改你为练习 3.3.25 给出的答案，**不使用**递归。在沿查找路径向下的过程中分解并平衡 4- 结点（以及 3- 结点），最后在树底插入新键即可。

**3.3.27**　**允许红色右链接**。修改你为练习 3.3.25 给出的答案，允许红色右链接的存在。

**3.3.28**　**自底向上的 2-3-4 树**。使用平衡 2-3-4 树作为数据结构实现符号表的基本 API。在树的表示中使用红黑链接并用和算法 3.4 相同的递归方式实现**自底向上**的插入。你的插入方法应该只需要分解查找路径底部的 4- 结点（如果有的话）。

**3.3.29**　**最优存储**。修改 `RedBlackBST` 的实现，用下面的技巧实现无需为结点颜色的存储使用额外的空间：要将结点标记为红色，只需交换它的左右链接。要检测一个结点是否是红色，检测它的左子结点是否大于它的右子结点。你需要修改一些比较语句来适应链接的交换。这个技巧将变量的比较变成了键的比较，显然成本会更高，但它说明在需要的情况下这个变量是可以被删掉的。

**3.3.30**　**缓存**。修改 `RedBlackBST` 的实现，将最近访问的结点 `Node` 保存在一个变量中，这样 `get()` 或 `put()` 在再次访问同一个键时就只需要常数时间了（请参考练习 3.1.25）。

**3.3.31**　**树的绘制**。为 RedBlackBST 添加一个 `draw()` 方法，像正文一样绘制出红黑树。

**3.3.32**　**AVL 树**。AVL 树是一种二叉查找树，其中任意结点的两棵子树的高度最多相差 1（最早的平衡树算法就是基于使用旋转保持 AVL 树中子树高度的平衡）。证明将其中由高度为偶数的结点指向高度为奇数的结点的链接设为红色就可以得到一棵（完美平衡的）2-3-4 树，其中红色链接可以是右链接。**附加题**：使用 AVL 树作为数据结构实现符号表的 API。一种方法是在每个结点中保存它的高度并在递归调用后使用旋转来根据需要调整这个高度；另一种方法是在树的表示中使用红黑链接并使用类似练习 3.3.39 和练习 3.3.40 的 `moveRedLeft()` 和 `moveRedRight()` 的方法。

**3.3.33**　**验证**。为 `RedBlackBST` 实现一个 `is23()` 方法来检查是否存在同时和两条红链接相连的结点和红色右链接，以及一个 `isBalanced()` 方法来检查从根结点到所有空链接的路径上的黑链接的数量是否相同。将这两个方法和练习 3.2.32 的 `isBST()` 方法结合起来实现一个 `isRedBlackBST()` 来检查一棵树是否是红黑树。

**3.3.34**　**所有的 2-3 树**。编写一段代码来生成高度为 2、3 和 4 的所有结构不同的 2-3 树，分别共有 2、7 和 122 种（**提示**：使用符号表）。

**3.3.35**　**2-3 树**。编写一段程序 TwoThreeST.java，使用两种结点类型来直接表示和实现 2-3 查找树。

**3.3.36**　**2-3-4-5-6-7-8 树**。说明平衡的 2-3-4-5-6-7-8 树中的查找和插入算法。

**3.3.37**　**无记忆性**。请证明红黑树不是**没有记忆**的。例如，如果你向树中插入一个小于所有键的新键，然后立即删除树的最小键，你可能得到一棵不同的树。

**3.3.38**　**旋转的基础定理**。请证明，使用一系列左旋转或者右旋转可以将一棵二叉查找树转化为由同一组键生成的其他任意一棵二叉查找树。

**3.3.39**　**删除最小键**。实现红黑树的 `deleteMin()` 方法，在沿着树的最左路径向下的过程中实现正文所述的变换，保证当前结点不是 2- 结点。

　　　**解答**：

```
private Node moveRedLeft(Node h)
{  // 假设结点h为红色，h.left和h.left.left都是黑色，
   // 将h.left或者h.left的子结点之一变红
   flipColors(h);
   if (isRed(h.right.left))
   {
      h.right = rotateRight(h.right);
      h = rotateLeft(h);
   }
   return h;
}
public void deleteMin()
{
   if (isRed(root.left) && !isRed(root.right))
      root.color = RED;
   root = deleteMin(root);
   if (!isEmpty()) root.color = BLACK;
}
private Node deleteMin(Node h)
{
   if (h.left == null)
      return null;
   if (!isRed(h.left) && !isRed(h.left.left))
      h = moveRedLeft(h);
   h.left = deleteMin(h.left);
   return balance(h);
}
```

　　　其中的 `balance()` 方法由下一行代码和算法 3.4 的递归 `put()` 方法中的最后 5 行代码组成：

```
if (isRed(h.right)) h = rotateLeft(h);
```

　　　这里的 `flipColors()` 方法将会补全三条链接的颜色，而不是正文中实现插入操作时实现的 `flipColors()` 方法。对于删除，我们会将父结点设为 `BLACK`（黑）而将两个子结点设为 `RED`（红）。

**3.3.40**　**删除最大键**。实现红黑树的 `deleteMax()` 方法。需要注意的是因为红链接都是左链接，所以这里用到的变换和上一道练习中的稍有不同。

　　　**解答**：

```
private Node moveRedRight(Node h)
{  // 假设结点h为红色，h.right和h.right.left都是黑色，
   // 将h.right或者h.right的子结点之一变红
   flipColors(h)
   if (!isRed(h.left.left))
      h = rotateRight(h);
   return h;
 }
public void deleteMax()
{
   if (!isRed(root.left) && !isRed(root.right))
      root.color = RED;
   root = deleteMax(root);
   if (!isEmpty()) root.color = BLACK;
}
private Node deleteMax(Node h)
{
   if (isRed(h.left))
       h = rotateRight(h);
   if (h.right == null)
      return null;
   if (!isRed(h.right) && !isRed(h.right.left))
      h = moveRedRight(h);
   h.right = deleteMax(h.right);
   return balance(h);
}
```

**3.3.41**　**删除操作**。将上两题中的方法和二叉查找树的 `delete()` 方法结合起来，实现红黑树的删除操作。

　　　**解答**：

```
public void delete(Key key)
{
   if (!isRed(root.left) && !isRed(root.right))
      root.color = RED;
   root = delete(root, key);
   if (!isEmpty()) root.color = BLACK;
}
private Node delete(Node h, Key key)
{
   if (key.compareTo(h.key) < 0)
   {
      if (!isRed(h.left) && !isRed(h.left.left))
         h = moveRedLeft(h);
      h.left =  delete(h.left, key);
   }
   else
   {
      if (isRed(h.left))
         h = rotateRight(h);
      if (key.compareTo(h.key) == 0 && (h.right == null))
         return null;
      if (!isRed(h.right) && !isRed(h.right.left))
         h = moveRedRight(h);
      if (key.compareTo(h.key) == 0)
      {
         h.val = get(h.right, min(h.right).key);
         h.key = min(h.right).key;
         h.right = deleteMin(h.right);
      }
      else h.right = delete(h.right, key);
   }
   return balance(h);
}
```

###实验题

**3.3.42**　**统计红色结点**。编写一段程序，统计给定的红黑树中红色结点所占的比例。对于 ![N=10^4](https://private.codecogs.com/gif.latex?N=10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)，用你的程序统计至少 100 棵随机构造的大小为 ![N](https://private.codecogs.com/gif.latex?N) 的红黑树并得出一个猜想。

**3.3.43**　**成本图**。改造 `RedBlackBST` 的实现来绘制本节中能够显示计算中每次 `put()` 操作的成本的图（请参考练习 3.1.38）。

**3.3.44**　**平均查找用时**。用实验研究和计算在一棵由 ![N](https://private.codecogs.com/gif.latex?N) 个随机结点构造的红黑树中到达一个随机结点的平均路径长度（内部路径长度除以 ![N](https://private.codecogs.com/gif.latex?N) 再加 1）的平均差和标准差，对于 1 到 10 000 之间的每个 ![N](https://private.codecogs.com/gif.latex?N) 至少重复实验 1000 遍。将结果绘制成和图 3.3.30 相似的 Tufte 图，并画上函数 ![\lg N-0.5](https://private.codecogs.com/gif.latex?\lg%20N-0.5) 的曲线。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.056.png)

**图 3.3.30　随机构造的红黑树中到达一个随机结点的平均路径长度**

**3.3.45**　**统计旋转**。改进你为练习 3.3.43 给出的程序，用图像绘制出在构造红黑树的过程中旋转和分解结点的次数并讨论结果。

**3.3.46**　**红黑树的高度**。改进你为练习 3.3.43 给出的程序，用图像绘制出所有红黑树的高度并讨论结果。

##3.4　散列表

如果所有的键都是小整数，我们可以用一个数组来实现无序的符号表，将键作为数组的索引而数组中键 `i` 处储存的就是它对应的值。这样我们就可以快速访问任意键的值。在本节中我们将要学习**散列表**。它是这种简易方法的扩展并能够处理更加复杂的类型的键。我们需要用算术操作将键转化为数组的索引来访问数组中的键值对。

使用散列的查找算法分为两步。第一步是用**散列函数**将被查找的键转化为数组的一个索引。理想情况下，不同的键都能转化为不同的索引值。当然，这只是理想情况，所以我们需要面对两个或者多个键都会散列到相同的索引值的情况。因此，散列查找的第二步就是一个**处理碰撞冲突**的过程，如图 3.4.1 所示。在描述了多种散列函数的计算后，我们会学习两种解决碰撞的方法：**拉链法**和**线性探测法**。

![{45%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.057.png)

**图 3.4.1　散列表的核心问题**

散列表是算法在**时间和空间上作出权衡的**经典例子。如果没有内存限制，我们可以直接将键作为（可能是一个超大的）数组的索引，那么所有查找操作只需要访问内存一次即可完成。但这种理想情况不会经常出现，因为当键很多时需要的内存太大。另一方面，如果没有时间限制，我们可以使用无序数组并进行顺序查找，这样就只需要很少的内存。而散列表则使用了适度的空间和时间并在这两个极端之间找到了一种平衡。事实上，我们不必重写代码，只需要调整散列算法的参数就可以在空间和时间之间作出取舍。我们会使用概率论的经典结论来帮助我们选择适当的参数。

概率论是数学分析的重大成果。虽然它不在本书的讨论范围之内，但我们将要学习的散列算法利用了这些知识，这些算法虽然简单但应用广泛。使用散列表，你可以实现在一般应用中拥有（均摊后）**常数级别**的查找和插入操作的符号表。这使得它在很多情况下成为实现简单符号表的最佳选择。

###3.4.1　散列函数

我们面对的第一个问题就是散列函数的计算，这个过程会将键转化为数组的索引。如果我们有一个能够保存 ![M](https://private.codecogs.com/gif.latex?M) 个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的索引（![[0,M-1]](https://private.codecogs.com/gif.latex?[0,M-1]) 范围内的整数）的**散列函数**。我们要找的散列函数应该易于计算并且能够均匀分布所有的键，即对于任意键，0 到 ![M-1](https://private.codecogs.com/gif.latex?M-1) 之间的每个整数都有相等的可能性与之对应（与键无关）。这个要求似乎有些难以理解。那么要理解散列，就首先要仔细思考如何去实现这样一个函数。

散列函数和键的类型有关。严格地说，**对于每种类型的键都我们都需要一个与之对应的散列函数**。如果键是一个数，比如社会保险号，我们就可以直接使用这个数；如果键是一个字符串，比如一个人的名字，我们就需要将这个字符串转化为一个数；如果键含有多个部分，比如邮件地址，我们需要用某种方法将这些部分结合起来。对于许多常见类型的键，我们可以利用 Java 提供的默认实现。我们会简略讨论多种数据类型的散列函数。你应该看看它们是如何实现的，因为你也需要为自定义的类型实现散列函数。

####3.4.1.1　典型的例子

假设在我们的应用中，键是美国的社会保险号。一个社会保险号含有 9 位数字并被分为三个部分，例如 123-45-6789。第一组数字表示该号码签发的地区（例如，第一组号码为 035 的社会保险号来自罗得岛州，214 则来自马里兰州），另两组数字表示个人身份。社会保险号共有 10 亿（![10^9](https://private.codecogs.com/gif.latex?10^9)）个，但假设我们的应用程序只需要处理几百个，我们可以使用一个大小 _M_=1000 的散列表。散列函数的一种实现方法是使用键（社会保险号）中的三个数字。用第三组中的三个数字似乎比用第一组中的三个数字更好（因为我们的客户不太可能完全平均地分布在各个地区），但下面会讲到，更好的方法是用所有 9 个数字得到一个整数，然后再考虑整数的散列函数。

####3.4.1.2　正整数

将整数散列最常用方法是**除留余数法**。我们选择大小为素数 ![M](https://private.codecogs.com/gif.latex?M) 的数组，对于任意正整数 ![k](https://private.codecogs.com/gif.latex?k)，计算 ![k](https://private.codecogs.com/gif.latex?k) 除以 ![M](https://private.codecogs.com/gif.latex?M) 的余数。这个函数的计算非常容易（在 Java 中为 `k% M`）并能够有效地将键散布在 0 到 ![M-1](https://private.codecogs.com/gif.latex?M-1) 的范围内。如果 ![M](https://private.codecogs.com/gif.latex?M) 不是素数，我们可能无法利用键中包含的所有信息，这可能导致我们无法均匀地散列散列值。例如，如果键是十进制数而 ![M](https://private.codecogs.com/gif.latex?M) 为 ![10^k](https://private.codecogs.com/gif.latex?10^k)，那么我们只能利用键的后 ![k](https://private.codecogs.com/gif.latex?k) 位，这可能会产生一些问题。举个简单的例子，假设键为电话号码的区号且 ![M=100](https://private.codecogs.com/gif.latex?M=100)。由于历史原因，美国的大部分区号中间位都是 0 或者 1，因此这种方法会将大量的键散列为小于 20 的索引，但如果使用素数 97，散列值的分布显然会更好（一个离 100 更远的素数会更好），如右侧所示。与之类似，互联网中使用的 IP 地址也不是随机的，所以如果我们想用除留余数法将其散列就需要用素数（特别地，这不是 2 的幂）大小的数组。

![{35%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.058.png)

{-:-}**除留余数法**

####3.4.1.3　浮点数

如果键是 0 到 1 之间的实数，我们可以将它乘以 ![M](https://private.codecogs.com/gif.latex?M) 并四舍五入得到一个 0 至 ![M-1](https://private.codecogs.com/gif.latex?M-1) 之间的索引值。尽管这个方法很容易理解，但它是有缺陷的，因为这种情况下键的高位起的作用更大，最低位对散列的结果没有影响。修正这个问题的办法是将键表示为二进制数然后再使用除留余数法（Java 就是这么做的）。

####3.4.1.4　字符串

除留余数法也可以处理较长的键，例如字符串，我们只需将它们当作大整数即可。例如，右侧的代码就能够用除留余数法计算 `String S` 的散列值：

```
int hash = 0;
for (int i = 0; i < s.length(); i++)
   hash = (R * hash + s.charAt(i)) % M;
```

{-:-}散列字符串键

Java 的 `charAt()` 函数能够返回一个 `char` 值，即一个非负 16 位整数。如果 `R` 比任何字符的值都大，这种计算相当于将字符串当作一个 `N` 位的 `R` 进制值，将它除以 `M` 并取余。一种叫 Horner **方法**的经典算法用 `N` 次乘法、加法和取余来计算一个字符串的散列值。只要 `R` 足够小，不造成溢出，那么结果就能够如我们所愿，落在 0 至 ![M-1](https://private.codecogs.com/gif.latex?M-1) 之内。使用一个较小的素数，例如 31，可以保证字符串中的所有字符都能发挥作用。Java 的 `String` 的默认实现使用了一个类似的方法。

####3.4.1.5　组合键

如果键的类型含有多个整型变量，我们可以和 `String` 类型一样将它们混合起来。例如，假设被查找的键的类型是 `Date`，其中含有几个整型的域：`day`（两个数字表示的日），`month`（两个数字表示的月）和 `year`（4 个数字表示的年）。我们可以这样计算它的散列值：

```
int hash = (((day * R + month) % M ) * R + year) % M;
```

只要 `R` 足够小不造成溢出，也可以得到一个 0 至 ![M-1](https://private.codecogs.com/gif.latex?M-1) 之间的散列值。在这种情况下我们可以通过选择一个适当的 `M`，比如 31，来省去括号内的 `% M` 计算。和字符串的散列算法一样，这个方法也能处理有任意多整型变量的类型。

**表 3.4.1　所有例子中的键的散列值**

<table class="table table-bordered table-striped table-condensed">
<tr><th>键</th><td><code>S</code></td><td><code>E</code></td><td><code>A</code></td><td><code>R</code></td><td><code>C</code></td><td><code>H</code></td><td><code>X</code></td><td><code>M</code></td><td><code>P</code></td><td><code>L</code></td></tr>
<tr><th>散列值 (M = 5)</th><td><code>2</code></td><td><code>0</code></td><td><code>0</code></td><td><code>4</code></td><td><code>4</code></td><td><code>4</code></td><td><code>2</code></td><td><code>4</code></td><td><code>3</code></td><td><code>3</code></td></tr>
<tr><th>散列值 (M = 16)</th><td><code>6</code></td><td><code>10</code></td><td><code>4</code></td><td><code>14</code></td><td><code>5</code></td><td><code>4</code></td><td><code>15</code></td><td><code>1</code></td><td><code>14</code></td><td><code>6</code></td></tr>
</table>

####3.4.1.6　Java 的约定

每种数据类型都需要相应的散列函数，于是 Java 令所有数据类型都继承了一个能够返回一个 32 比特整数的 `hashCode()` 方法。每一种数据类型的 `hashCode()` 方法都必须和 `equals()` 方法**一致**。也就是说，如果 `a.equals(b)` 返回 `true`，那么 `a.hashCode()` 的返回值必然和 `b.hashCode()` 的返回值相同。相反，如果两个对象的 `hashCode()` 方法的返回值不同，那么我们就知道这两个对象是不同的。但如果两个对象的 `hashCode()` 方法的返回值相同，这两个对象也有可能不同，我们还需要用 `equals()` 方法进行判断。请注意，这说明如果你要为自定义的数据类型定义散列函数，你需要同时重写 `hashCode()` 和 `equals()` 两个方法。默认散列函数会返回对象的内存地址，但这只适用于很少的情况。Java 为很多常用的数据类型重写了 `hashCode()` 方法（包括 `String`、`Integer`、`Double`、`File` 和 `URL`）。

####3.4.1.7　将 `hashCode()` 的返回值转化为一个数组索引

因为我们需要的是数组的索引而不是一个 32 位的整数，我们在实现中会将默认的 `hashCode()` 方法和除留余数法结合起来产生一个 0 到 ![M-1](https://private.codecogs.com/gif.latex?M-1) 的整数，方法如下：

```
private int hash(Key x)
{  return (x.hashCode() & 0x7fffffff) % M;  }
```

这段代码会将符号位屏蔽（将一个 32 位整数变为一个 31 位非负整数），然后用除留余数法计算它除以 `M` 的余数。在使用这样的代码时我们一般会将数组的大小 `M` 取为**素数**以充分利用原散列值的所有位。**注意**：为了避免混乱，我们在例子中不会使用这种计算方法而是使用表 3.4.1 所示的散列值作为替代。

####3.4.1.8　自定义的 `hashCode()` 方法

散列表的用例希望 `hashCode()` 方法能够将键平均地散布为所有可能的 32 位整数。也就是说，对于任意对象 `x`，你可以调用 `x.hashCode()` 并认为有均等的机会得到 232 个不同整数中的任意一个 32 位整数值。Java 中的 `String`、`Integer`、`Double`、`File` 和 `URL` 对象的 `hashCode()` 方法都能实现这一点。而对于自己定义的数据类型，你必须试着自己实现这一点。3.4.1.5 节中的 `Date` 例子展示了一种可行的方案：用实例变量的整数值和除留余数法得到散列值。在 Java 中，所有的数据类型都继承了 `hashCode()` 方法，因此还有一个更简单的做法：将对象中的每个变量的 `hashCode()` 返回值转化为 32 位整数并计算得到散列值，如 `Transaction` 类所示。

```
public class Transaction
{
   ...
   private final String who;
   private final Date when;
   private final double amount;

   public int hashCode()
   {
       int hash = 17;
       hash = 31 * hash + who.hashCode();
       hash = 31 * hash + when.hashCode();
       hash = 31 * hash
           + ((Double) amount).hashCode();
       return hash;
   }
   ...
}
```

{-:-}自定义类型中 `hashCode()` 方法的实现

对于原始类型的对象，可以将其转化为对应的数据类型然后再调用 `hashCode()` 方法。和以前一样，系数的具体值（这里是 31）并不是很重要。

####3.4.1.9　软缓存

如果散列值的计算很耗时，那么我们或许可以将**每个键的散列值缓存起来**，即在每个键中使用一个 `hash` 变量来保存它的 `hashCode()` 的返回值（请见练习 3.4.25）。第一次调用 `hashCode()` 方法时，我们需要计算对象的散列值，但之后对 `hashCode()` 方法的调用会直接返回 `hash` 变量的值。Java 的 `String` 对象的 `hashCode()` 方法就使用了这种方法来减少计算量。

总的来说，要为一个数据类型实现一个优秀的散列方法需要满足三个条件：

* **一致性**——等价的键必然产生相等的散列值；
* **高效性**——计算简便；
* **均匀性**——均匀地散列所有的键。

设计同时满足这三个条件的散列函数是专家们的事。有了各种内置函数，Java 程序员在使用散列时只需要调用 `hashCode()` 方法即可，我们没有理由不信任它们。

但是，在有性能要求时应该谨慎使用散列，因为糟糕的散列函数经常是性能问题的罪魁祸首：程序可以工作但比预想的慢得多。保证均匀性的最好办法也许就是保证键的每一位都在散列值的计算中起到了相同的作用；实现散列函数最常见的错误也许就是忽略了键的高位。无论散列函数的实现是什么，当性能很重要时你应该测试所使用的所有散列函数。计算散列函数和比较两个键，哪个耗时更多？你的散列函数能够将一组键均匀地散布在 0 到 ![M-1](https://private.codecogs.com/gif.latex?M-1) 之间吗？用简单的实现测试这些问题能够预防未来的悲剧。例如，图 3.4.2 就显示出，对于《双城记》我们的 `hash()` 方法在使用了 Java 的 `String` 类型的 `hashCode()` 方法后能够得到一个合理的分布。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.059.png)

**图 3.4.2　《双城记》中每个单词的散列值的出现频率（10 679 个键，即单词，![M=97](https://private.codecogs.com/gif.latex?M=97)）**

这些讨论的背后是我们在使用散列时作出的一个重要假设。这个假设是一个我们实际上无法达到的理想模型，但它是我们实现散列函数时的指导思想。

>**假设 J（均匀散列假设）**。我们使用的散列函数能够均匀并独立地将所有的键散布于 0 到 ![M-1](https://private.codecogs.com/gif.latex?M-1) 之间。

>**讨论**。我们在实现散列函数时随意指定了很多参数，这显然无法实现一个能够在数学意义上均匀并独立地散布所有键的散列函数。坚深的理论研究告诉我们想要找到一个计算简单但又拥有一致性和均匀性的散列函数是不太可能的。在实际应用中，和使用 `Math.random()` 生成随机数一样，大多数程序员都会满足于随机数生成器类的散列函数。很少有人会去检验独立性，而这个性质一般都不会满足。

尽管验证这个假设很困难，假设 J 仍然是考察散列函数的重要方式，原因有两点。首先，设计散列函数时尽量避免随意指定参数以防止大量的碰撞，这是我们的重要目标；其次，尽管我们可能无法验证假设本身，它提示我们使用数学分析来预测散列算法的性能并在实验中进行验证。

###3.4.2　基于拉链法的散列表

一个散列函数能够将键转化为数组索引。散列算法的第二步是**碰撞处理**，也就是处理两个或多个键的散列值相同的情况。一种直接的办法是将大小为 ![M](https://private.codecogs.com/gif.latex?M) 的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。这种方法被称为**拉链法**，因为发生冲突的元素都被存储在链表中。这个方法的基本思想就是选择足够大的 ![M](https://private.codecogs.com/gif.latex?M)，使得所有链表都尽可能短以保证高效的查找。查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。

拉链法的一种实现方法是使用原始的链表数据类型（请见练习 3.4.2）来扩展 `SequentialSearchST`（算法 3.1）。另一种更简单的方法（但效率稍低）是采用一般性的策略，为 ![M](https://private.codecogs.com/gif.latex?M) 个元素分别构建**符号表**来保存散列到这里的键，这样也可以重用我们之前的代码。算法 3.5 实现的 `SeparateChainingHashST` 使用了一个 `SequentialSearchST` 对象的数组，在 `put()` 和 `get()` 的实现中先计算散列函数来选定被查找的 `SequantialSearchST` 对象，然后使用符号表的 `put()` 和 `get()` 方法来完成相应的任务。

因为我们要用 ![M](https://private.codecogs.com/gif.latex?M) 条链表保存 ![N](https://private.codecogs.com/gif.latex?N) 个键，无论键在各个链表中的分布如何，链表的平均长度肯定是 ![N/M](https://private.codecogs.com/gif.latex?N/M)。例如，假设所有的键都落在了第一条链表上，所有链表的平均长度仍然是 ![(N+0+0+\cdots+0)/M=N/M](https://private.codecogs.com/gif.latex?(N+0+0+\cdots+0%29/M=N/M)。拉链法在实际情况中很有用，因为每条链表**确实都大约含有** ![N/M](https://private.codecogs.com/gif.latex?N/M) 个键值对。在一般情况中，我们能够由它验证假设 J 并且可以依赖这种高效的查找和插入实现。

在标准索引用例中使用基于拉链法的散列表如图 3.4.3 所示。

![{80%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.060.png)

**图 3.4.3　标准索引用例使用基于拉链法的散列表**

>**算法 3.5　基于拉链法的散列表**

>```
>public class SeparateChainingHashST<Key, Value>
>{
>    private int N;                           // 键值对总数
>    private int M;                           // 散列表的大小
>    private SequentialSearchST<Key, Value>[] st;  // 存放链表对象的数组
>
>    public SeparateChainingHashST()
>    {  this(997);  }
>    public SeparateChainingHashST(int M)
>    {  // 创建M条链表
>       this.M = M;
>       st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[M];
>       for (int i = 0; i < M; i++)
>          st[i] = new SequentialSearchST();
>    }
>
>    private int hash(Key key)
>    {  return (key.hashCode() & 0x7fffffff) % M; }
>
>    public Value get(Key key)
>    {  return (Value) st[hash(key)].get(key);  }
>
>    public void put(Key key, Value val)
>    {  st[hash(key)].put(key, val);  }
>
>    public Iterable<Key> keys()
>    // 请见练习3.4.19
>}
>```

>这段简单的符号表实现维护着一条链表的数组，用散列函数来为每个键选择一条链表。简单起见，我们使用了 `SequentialSearchST`。在创建 `st[]` 时需要进行类型转换，因为 Java 不允许泛型的数组。默认的构造函数会使用 997 条链表，因此对于较大的符号表，这种实现比 `SequentialSearchST` 大约会快 1000 倍。当你能够预知所需要的符号表的大小时，这段短小精悍的方案能够得到不错的性能。一种更可靠的方案是动态调整链表数组的大小，这样无论在符号表中有多少键值对都能保证链表较短（请见 3.4.4 节及练习 3.4.18）。

　

>**命题 K**。在一张含有 ![M](https://private.codecogs.com/gif.latex?M) 条链表和 ![N](https://private.codecogs.com/gif.latex?N) 个键的的散列表中，（在假设 J 成立的前提下）任意一条链表中的键的数量均在 ![N/M](https://private.codecogs.com/gif.latex?N/M) 的常数因子范围内的概率无限趋向于 1。

>**简略的证明**。有了假设 J，这个问题就变成了一个经典的概率论问题。在这里我们为有一些概率论基础知识的读者给出一个简要的证明。

>由**二项分布**可知，一条给定的链表正好含有 ![k](https://private.codecogs.com/gif.latex?k) 个键的概率为：

>![\begin{pmatrix}N\\k\end{pmatrix}\biggl(\frac{1}{M}\biggr)^k\biggl(\frac{M-1}{M}\biggr)^{N-k}](https://private.codecogs.com/gif.latex?\begin{pmatrix}N\\k\end{pmatrix}\biggl(\frac{1}{M}\biggr%29^k\biggl(\frac{M-1}{M}\biggr%29^{N-k})

>![{75%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.061.png)

>**二项分布(![N=10^4,~M=10^3,~\alpha=10](https://private.codecogs.com/gif.latex?N=10^4,~M=10^3,~\alpha=10))**

>因为我们实际上是从 ![N](https://private.codecogs.com/gif.latex?N) 个键中取了其中 ![k](https://private.codecogs.com/gif.latex?k) 个。这 ![k](https://private.codecogs.com/gif.latex?k) 个键被散列到给定的链表的概率均为 ![1/M](https://private.codecogs.com/gif.latex?1/M)，而剩下的 ![(N-k)](https://private.codecogs.com/gif.latex?(N-k%29) 个键不被散列到给定的链表中的概率均为 ![(1-1/M)](https://private.codecogs.com/gif.latex?(1-1/M%29)。令 ![\alpha=N/M](https://private.codecogs.com/gif.latex?\alpha=N/M)，这个公式可以写为：

>![\begin{pmatrix}N\\k\end{pmatrix}\biggl(\frac{\alpha}{M}\biggr)^k\biggl(1-\frac{\alpha}{N}\biggr)^{N-k}](https://private.codecogs.com/gif.latex?\begin{pmatrix}N\\k\end{pmatrix}\biggl(\frac{\alpha}{M}\biggr%29^k\biggl(1-\frac{\alpha}{N}\biggr%29^{N-k})

>对于较小的 ![\alpha](https://private.codecogs.com/gif.latex?\alpha)，经典的**泊松分布**可以非常近似地表示它：

>![\frac{\alpha^k{\rm e}^{-\alpha}}{k!}](https://private.codecogs.com/gif.latex?\frac{\alpha^k{\rm%20e}^{-\alpha}}{k!})

>![{75%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.062.png)

>**泊松分布(![N=10^4,~M=10^3,~\alpha=10](https://private.codecogs.com/gif.latex?N=10^4,~M=10^3,~\alpha=10)**

>由此可得，一条链表中含有超过 ![t\alpha](https://private.codecogs.com/gif.latex?t\alpha) 个键的概率不会超过 ![(e/t)^{\alpha t}{\rm e}^{-\alpha}](https://private.codecogs.com/gif.latex?(e/t%29^{\alpha%20t}{\rm%20e}^{-\alpha})。对于实际应用来说，这个数字非常小。例如，如果平均链表长度为 10，那么一个键的散列值落在一条长度超过 20 的链表的概率不超过 ![(10e/2)^2{\rm e}^{-10}\approx0.0084](https://private.codecogs.com/gif.latex?(10e/2%29^2{\rm%20e}^{-10}\approx0.0084)；如果平均链表长度为 20，那么一个键的散列值落在一条长度超过 40 的链表的概率不超过 ![(20~{\rm e}/2)~^2{\rm e}^{-20}\approx0.000~001~6](https://private.codecogs.com/gif.latex?(20~{\rm%20e}/2%29~^2{\rm%20e}^{-20}\approx0.000~001~6)。这个结果并不能保证每条链表都很短，但我们可以知道当 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 一定时，最长链表的平均长度的增长速度为 ![\log N/\log\log N](https://private.codecogs.com/gif.latex?\log%20N/\log\log%20N)。



这段数学分析非常有力，但需要注意的是它**完全依赖于**假设 J。如果散列函数不是均匀和独立的，那么查找和插入的成本就可能和 ![N](https://private.codecogs.com/gif.latex?N) 成正比，也就是和顺序查找类似。假设 J 比我们见过的其他和概率有关的算法中相应的假设都有效，但也更加难以验证。在计算散列值时，我们假设每个键都有均等的机会被散列到 ![M](https://private.codecogs.com/gif.latex?M) 个索引中的任意一个，无论键有多复杂。我们没法用实验来验证所有可能的数据类型，所以我们会进行更复杂的实验，在实际应用中可能出现的一组键中随机取样进行验证，然后统计结果并分析。好消息是我们在测试中仍然可以使用这个算法来验证假设 J 和由它得出的数学推论。

>**性质 L**。在一张含有 ![M](https://private.codecogs.com/gif.latex?M) 条链表和 ![N](https://private.codecogs.com/gif.latex?N) 个键的的散列表中，未命中查找和插入操作所需的比较次数为 ![\sim N/M](https://private.codecogs.com/gif.latex?\sim%20N/M)。

>**例证**。在实际应用中，散列表算法的高性能并不需要散列函数完全符合假设 J 意义上的均匀性。自 20 世纪 50 年代以来，无数程序员都见证了命题 K 所预言的性能改进，即使有些散列函数不是均匀的，命题也成立。例如，图 3.4.4 所示的 `FrequencyCounter` 使用的散列表（其中的 `hash()` 方法是基于 Java 的 `String` 类型的 `hashCode()` 方法）中的链表长度和理论模型完全一致。这条性质的例外之一是在许多情况下散列函数未能使用键的所有信息而造成的性能低下。除此之外，大量经验丰富的程序员给出的应用实例令我们确信，在基于拉链法的散列表中使用大小为 ![M](https://private.codecogs.com/gif.latex?M) 的数组能够将查找和插入操作的效率提高 ![M](https://private.codecogs.com/gif.latex?M) 倍。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.063.png)

**图 3.4.4　使用 `SeparateChainingHashST`，运行 `java FrequencyCounter 8 < tale.txt` 时所有链表的长度**

####3.4.2.1　散列表的大小

在实现基于拉链法的散列表时，我们的目标是选择适当的数组大小 ![M](https://private.codecogs.com/gif.latex?M)，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。而拉链法的一个好处就是这并不是关键性的选择。如果存入的键多于预期，查找所需的时间只会比选择更大的数组稍长；如果少于预期，虽然有些空间浪费但查找会非常快。当内存不是很紧张时，可以选择一个足够大的 ![M](https://private.codecogs.com/gif.latex?M)，使得查找需要的时间变为常数；当内存紧张时，选择尽量大的 ![M](https://private.codecogs.com/gif.latex?M) 仍然能够将性能提高 ![M](https://private.codecogs.com/gif.latex?M) 倍。例如对于 `FrequencyCounter`，从图 3.4.5 可以看出，每次操作所需要的比较次数从使用 `SequentialSearchST` 时的上千次降低到了使用 `SeparateChainingHashST` 时的若干次，正如我们所料。另一种方法是动态调整数组的大小以保持短小的链表（请见练习 3.4.18）。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.064.png)

**图 3.4.5　使用 `SeparateChainingHashST`，运行 `java FrequencyCounter 8 < tale.txt` 的成本（![M=997](https://private.codecogs.com/gif.latex?M=997)）**

####3.4.2.2　删除操作

要删除一个键值对，先用散列值找到含有该键的 `SequentialSearchST` 对象，然后调用该对象的 `delete()` 方法（请见练习 3.1.5）。这种重用已有代码的方式比重新实现链表的删除更好。

####3.4.2.3　有序性相关的操作

散列最主要的目的在于均匀地将键散布开来，因此在计算散列后键的顺序信息就丢失了。如果你需要快速找到最大或者最小的键，或是查找某个范围内的键，或是实现表 3.1.4 中有序符号表 API 中的其他任何方法，散列表都**不是**合适的选择，因为这些操作的运行时间都将会是线性的。

基于拉链法的散列表的实现简单。在键的顺序并不重要的应用中，它可能是最快的（也是使用最广泛的）符号表实现。当使用 Java 的内置数据类型作为键，或是在使用含有经过完善测试的 `hashCode()` 方法的自定义类型作为键时，算法 3.5 能够提供快速而方便的查找和插入操作。下面，我们会介绍另一种解决碰撞冲突的有效方法。

###3.4.3　基于线性探测法的散列表

实现散列表的另一种方式就是用大小为 ![M](https://private.codecogs.com/gif.latex?M) 的数组保存 ![N](https://private.codecogs.com/gif.latex?N) 个键值对，其中 ![M>N](https://private.codecogs.com/gif.latex?M%3EN)。我们需要依靠数组中的**空位**解决碰撞冲突。基于这种策略的所有方法被统称为**开放地址**散列表。

开放地址散列表中最简单的方法叫做**线性探测法**：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表中的下一个位置（将索引值加 1）。这样的线性探测可能会产生三种结果：

* 命中，该位置的键和被查找的键相同；
* 未命中，键为空（该位置没有键）；
* 继续查找，该位置的键和被查找的键不同。

我们用散列函数找到键在数组中的索引，检查其中的键和被查找的键是否相同。如果不同则继续查找（将索引增大，到达数组结尾时折回数组的开头），直到找到该键或者遇到一个空元素，如图 3.4.6 所示。我们习惯将检查一个数组位置是否含有被查找的键的操作称作**探测**。在这里它可以等价于我们一直使用的**比较**，不过有些探测实际上是在测试键是否为空。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.065.png)

**图 3.4.6　标准索引用例使用的基于线性探测的符号表的轨迹**

开放地址类的散列表的核心思想是与其将内存用作链表，不如将它们作为在散列表的空元素。这些空元素可以作为查找结束的标志。在 `LinearProbingHashST` 中可以看到（算法 3.6），使用这种思想来实现符号表的 API 是十分简单的。我们在实现中使用了并行数组，一条保存键，一条保存值，并像前面讨论的那样使用散列函数产生访问数据所需的数组索引。

>**算法 3.6　基于线性探测的符号表**

>```
>public class LinearProbingHashST<Key, Value>
>{
>    private int N;         // 符号表中键值对的总数
>    private int M = 16;    // 线性探测表的大小
>    private Key[] keys;    // 键
>    private Value[] vals;  // 值
>    public LinearProbingHashST()
>    {
>       keys = (Key[])   new Object[M];
>       vals = (Value[]) new Object[M];
>    }
>    private int hash(Key key)
>    {  return (key.hashCode() & 0x7fffffff) % M; }
>
>    private void resize()        // 请见3.4.4节
>
>    public void put(Key key, Value val)
>    {
>       if (N >= M/2) resize(2*M);  // 将M加倍（请见正文）
>
>       int i;
>       for (i = hash(key); keys[i] != null; i = (i + 1) % M)
>          if (keys[i].equals(key)) { vals[i] = val; return; }
>       keys[i] = key;
>       vals[i] = val;
>       N++;
>    }
>
>    public Value get(Key key)
>    {
>       for (int i = hash(key); keys[i] != null; i = (i + 1) % M)
>          if (keys[i].equals(key))
>              return vals[i];
>       return null;
>    }
>}
>```

>这段符号表的实现将键和值分别保存在两个数组中（与 `BinarySearchST` 类型中一样），使用空（标记为 `null`）来表示一簇键的结束。如果一个新键的散列值是一个空元素，那么就将它保存在那里；如果不是，我们就顺序查找一个空元素来保存它。要查找一个键，我们从它的散列值开始顺序查找，如果找到则命中，如果遇到空元素则未命中。`keys()` 方法的实现请见练习 3.4.19。

####3.4.3.1　删除操作

如何从基于线性探测的散列表中删除一个键？仔细想一想，你会发现直接将该键所在的位置设为 `null` 是不行的，因为这会使得在此位置之后的元素无法被查找。例如，假设在轨迹图的例子中（图 3.4.6）我们需要用这种方法删除键 `C`，然后查找 `H`。`H` 的散列值是 4，但它实际存储在这一簇键的结尾，即 7 号位置。如果我们将 5 号位置设为 `null`，`get()` 方法将无法找到 `H`。因此，我们需要将簇中被删除键的右侧的所有键重新插入散列表。这个过程比想象的要复杂，所以你最好以练习（请见练习 3.4.17）为例跟踪右侧这段代码的运行全过程。

```
public void delete(Key key)
{
   if (!contains(key)) return;
   int i = hash(key);
   while (!key.equals(keys[i]))
      i = (i + 1) % M;
   keys[i] = null;
   vals[i] = null;
   i = (i + 1) % M;
   while (keys[i] != null)
   {
      Key   keyToRedo = keys[i];
      Value valToRedo = vals[i];
      keys[i] = null;
      vals[i] = null;
      N--;
      put(keyToRedo, valToRedo);
      i = (i + 1) % M;
   }
   N--;
   if (N > 0 && N == M/8) resize(M/2);
}
```

{-:-}基于线性探测的散列表的删除操作

和拉链法一样，开放地址类的散列表的性能也依赖于 ![\alpha=N/M](https://private.codecogs.com/gif.latex?\alpha=N/M) 的比值，但意义有所不同。我们将 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 称为散列表的**使用率**。对于基于拉链法的散列表，![\alpha](https://private.codecogs.com/gif.latex?\alpha) 是每条链表的长度，因此一般大于 1；对于基于线性探测的散列表，![\alpha](https://private.codecogs.com/gif.latex?\alpha) 是表中已被占用的空间的比例，它是不可能大于 1 的。事实上，在 `LinearProbingHashST` 中我们不允许 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 达到 1（散列表被占满），因为此时未命中的查找会导致无限循环。为了保证性能，我们会动态调整数组的大小来保证使用率在 1/8 到 1/2 之间。这个策略是基于数学上的分析，我们会在讨论实现的细节之前介绍。

####3.4.3.2　键簇

线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目，也叫做**键簇**，如图 3.4.7 所示。例如，在示例中插入键 `C` 会产生一个长度为 3 的键簇（`A C S`）。这意味着插入 `H` 需要探测 4 次，因为 `H` 的散列值为该键簇的第一个位置。显然，短小的键簇才能保证较高的效率。随着插入的键越来越多，这个要求很难满足，较长的键簇会越来越多，如图 3.4.8 所示。另外，因为（基于均匀性假设）数组的每个位置都有相同的可能性被插入一个新键，长键簇更长的可能性比短键簇**更大**，因为新键的散列值无论落在簇中的任何位置都会使簇的长度加 1（甚至更多，如果这个簇和相邻的簇之间只有一个空元素相隔的话）。下面我们要将键簇的影响量化来预测线性探测法的性能，并使用这些信息在我们的实现中设置适当的参数值。

![{60%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.066.png)

**图 3.4.7　线性探测法中的键簇（![M=64](https://private.codecogs.com/gif.latex?M=64)）**

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.067.png)

**图 3.4.8　数组的使用模式（2048 个键，每行 128 个）**

####3.4.3.3　线性探测法的性能分析

尽管最后的结果的形式相对简单，准确分析线性探测法的性能是非常有难度的。Knuth 在 1962 年作出的以下推导是算法分析史上的一个里程碑。

>**命题 M**。在一张大小为 ![M](https://private.codecogs.com/gif.latex?M) 并含有 ![N=\alpha M](https://private.codecogs.com/gif.latex?N=\alpha%20M) 个键的基于线性探测的散列表中，基于假设 J，命中和未命中的查找所需的探测次数分别为：

>{-:-}![\sim\frac{1}{2}\Biggl(1+\frac{1}{1-\alpha}\Biggr)](https://private.codecogs.com/gif.latex?\sim\frac{1}{2}\Biggl(1+\frac{1}{1-\alpha}\Biggr%29) 和 ![\sim\frac{1}{2}\Biggl(1+\frac{1}{(1-\alpha)^2}\Biggr)](https://private.codecogs.com/gif.latex?\sim\frac{1}{2}\Biggl(1+\frac{1}{(1-\alpha%29^2}\Biggr%29)

>特别是当 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 约为 1/2 时，查找命中所需要的探测次数约为 3/2，未命中所需要的约为 5/2。当 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 趋近于 1 时，这些估计值的精确度会下降，但不需要担心这些情况，因为我们会保证散列表的使用率小于 1/2。

>**讨论**。要计算平均值，首先要计算在散列表中每个位置上出现查找未命中所需要的探测次数，然后将所有探测次数之和除以 ![M](https://private.codecogs.com/gif.latex?M)。所有查找未命中都至少需要一次探测，因此我们从第一次探测之后开始计数。考虑在一张半满的（![M=2N](https://private.codecogs.com/gif.latex?M=2N)）线性探测散列表中可能出现的以下两种极端情况：在最好的情况下，偶数位置的数组元素都是空的，奇数位置的数组元素都是满的；在最坏的情况下，前半张表是空的，后半张表是满的。键簇的平均长度在两种情况下都是 ![N/(2N)=1/2](https://private.codecogs.com/gif.latex?N/(2N%29=1/2)，但未命中的查找所需的平均探测次数在最好情况下为 1（所有的查找都至少需要一次探测）加上 ![(0+1+0+1+\cdots)/(2N)=1/2](https://private.codecogs.com/gif.latex?(0+1+0+1+\cdots%29/(2N%29=1/2)，在最坏情况下为 1 加上 ![(N+(N-1)+\cdots)/(2N)\sim N/4](https://private.codecogs.com/gif.latex?(N+(N-1%29+\cdots%29/(2N%29\sim%20N/4)。将这段证明一般化可得未命中的查找平均所需的比较次数和键簇长度的**平方**成正比。如果一个键簇的长度为 ![t](https://private.codecogs.com/gif.latex?t)，那么 ![(t+(t-1)+\cdots+2+1)/M=t(t+1)/(2M)](https://private.codecogs.com/gif.latex?(t+(t-1%29+\cdots+2+1%29/M=t(t+1%29/(2M%29) 就是在这段键簇中查找未命中所需的平均探测次数。因为所有键簇的总长度肯定为 ![N](https://private.codecogs.com/gif.latex?N)，所以将表中所有键簇所得的平均探测次数相加可以得到，一次未命中的查找的平均成本为 ![1+N/(2M)+](https://private.codecogs.com/gif.latex?1+N/(2M%29+) ( 每个键簇的长度的平方之和 )，再除以 ![2M](https://private.codecogs.com/gif.latex?2M)。因此，给定一张散列表，我们就可以快速计算该表中一次未命中查找的平均成本（请见练习 3.4.21）。一般情况下，键簇的形成需要一个复杂的动态过程（也就是线性探测算法），很难分析并找出特点，而且这也远远超出了本书的讨论范围。

命题 M 告诉我们（在假设 J 的前提下）当散列表快满的时候查找所需的探测次数是巨大的（![\alpha](https://private.codecogs.com/gif.latex?\alpha) 越趋近于 1，由公式可知探测的次数也越来越大），但当使用率 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间。下面，我们为此来考虑动态调整散列表数组的大小。

###3.4.4　调整数组大小

```
private void resize(int cap)
{
   LinearProbingHashST<Key, Value> t;
   t = new LinearProbingHashST<Key, Value>(cap);
   for (int i = 0; i < M; i++)
      if (keys[i] != null)
          t.put(keys[i], vals[i]);
   keys = t.keys;
   vals = t.vals;
   M    = t.M;
}
```

{-:-}调整线性探测散列表

我们可以使用第 1 章中介绍的调整数组大小的方法来保证散列表的使用率永远都不会超过 1/2。首先，我们的 `LinearProbingHashST` 需要一个新的构造函数，它接受一个固定的容量作为参数（在算法 3.6 的构造函数中加入一行代码就可以在创建数组之前将 `M` 设为给定的值）。然后，我们需要右边给出的`resize()` 方法。它会创建一个新的给定大小的 `LinearProbingHashST`，保存原表中的 `keys` 和 `values` 变量，然后将原表中所有的键重新散列并插入到新表中。这使我们可以将数组的长度加倍。`put()` 方法中的第一条语句会调用 `resize()` 来保证散列表最多为半满状态。这段代码构造的散列表比原来大一倍，因此 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 的值就会减半。和其他需要调整数组大小的应用场景一样，我们也需要在 `delete()` 方法的最后加上：

```
if (N > 0 && N <= M/8) resize(M/2);
```

以保证所使用的内存量和表中的键值对数量的比例总在一定范围之内。动态调整数组大小可以为我们保证 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 不大于 1/2。

####3.4.4.1　拉链法

我们可以用相同的方法在拉链法中保持较短的链表（平均长度在 2 到 8 之间）：在 `resize()` 中将 `LinearProbingHashST` 替换为 `SeparateChainingHashST`，当 `N >= 8*M` 时调用 `resize(2*M)`，并在 `delete()` 中（在 `N >= 0 && N <= 2*M` 时）调用 `resize(M/2)`。对于拉链法，如果你能准确地估计用例所需的散列表的大小 ![N](https://private.codecogs.com/gif.latex?N)，调整数组的工作并不是必需的，只需要根据查找耗时和（![1+N/M](https://private.codecogs.com/gif.latex?1+N/M)）成正比来选取一个适当的 ![M](https://private.codecogs.com/gif.latex?M) 即可。而对于线性探测法，调整数组的大小是必需的，因为当用例插入的键值对数量超过预期时它的查找时间不仅会变得非常长，还会在散列表被填满时进入无限循环。

####3.4.4.2　均摊分析

从理论角度来说，当我们动态调整数组大小时，需要找出均摊成本的上限，因为我们知道使散列表长度加倍的插入操作需要大量的探测。

>**命题 N**。假设一张散列表能够自己调整数组的大小，初始为空。基于假设 J，执行任意顺序的 ![t](https://private.codecogs.com/gif.latex?t) 次**查找**、**插入**和**删除**操作所需的时间和 ![t](https://private.codecogs.com/gif.latex?t) 成正比，所使用的内存量总是在表中的键的总数的常数因子范围内。

>**证明**。对于拉链法和线性探测法，结合命题 K 和命题 M 可知，这个命题只是对我们在第 1 章 中第一次讨论过的数组增长的均摊分析的简单重复而已。

如图 3.4.9 和图 3.4.10 所示，在 `FrequencyCounter` 的例子中，累计平均的曲线很好地显示出散列表中调整数组大小的动态行为。每次数组长度加倍之后，累计平均值都会增加约 1，因为表中的每个键都需要重新计算散列值。然后该值慢慢下降，因为半数左右的键被重新分配到了表中的不同位置。随着表中的键的增加，该值下降的速度也慢慢降低。

![{95%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.068.png)

**图 3.4.9　使用能够自动调整数组大小的 `SeparateChainingHashST`，运行 `java FrequencyCounter 8< tale.txt` 的成本**

![{95%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.069.png)

**图 3.4.10　使用能够自动调整数组大小的 `LinearProbingHashST`，运行 `java FrequencyCounter 8 < tale.txt` 的成本**

###3.4.5　内存使用

我们说过，如果我们希望将散列表的性能调整到最优，理解它的内存使用情况是非常重要的。虽然这种调整是专家们的事儿，但通过估计引用的使用数量来粗略计算所需的内存量仍然是很好的练习。方法如下：除了存储键和值所需的空间之外，我们实现的 `SeparateChainingHashST` 保存了 ![M](https://private.codecogs.com/gif.latex?M) 个 `SequentialSearchST` 对象和它们的引用。每个 `SequentialSearchST` 对象需要 16 字节，它的每个引用需要 8 字节。另外还有 ![N](https://private.codecogs.com/gif.latex?N) 个 `node` 对象，每个都需要 24 字节以及 3 个引用（`key`、`value` 和 `next`），比二叉查找树的每个结点还多需要一个引用。在使用动态调整数组大小来保证表的使用率在 1/8 到 1/2 之间的情况下，线性探测使用 ![4N](https://private.codecogs.com/gif.latex?4N) 到 ![16N](https://private.codecogs.com/gif.latex?16N) 个引用。可以看出，根据内存用量来选择散列表的实现并不容易。对于原始数据类型，这些计算又有所不同（请见练习 3.4.24）。

符号表的内存使用如表 3.4.2 所示。

**表 3.4.2　符号表的内存使用**

|方法|_N_ 个元素所需的内存（引用类型）|
|-|-|
|基于拉链法的散列表|![\sim48N+32M](https://private.codecogs.com/gif.latex?\sim48N+32M)|
|基于线性探测的散列表|在 ![\sim32N](https://private.codecogs.com/gif.latex?\sim32N) 和 ![\sim128N](https://private.codecogs.com/gif.latex?\sim128N) 之间|
|各种二叉查找树|![\sim56N](https://private.codecogs.com/gif.latex?\sim56N)|

自计算机发展的伊始，研究人员就研究了（并且现在仍在继续研究）散列表并找到了很多方法来改进我们所讨论过的几种基本算法。你能找到大量关于这个主题的文献。大多数改进都能降低时间 - 空间的曲线：在查找耗时相同的情况下使用更少的空间，或使在使用相同空间的情况下进行更快的查找。其他方法包括提供更好的性能保证，如最坏情况下的查找成本；改进散列函数的设计等。我们会在练习中讨论其中的部分方法。

拉链法和线性探测法的详细比较取决于实现的细节和用例对空间和时间的要求。即使基于性能考虑，选择拉链法而非线性探测法也不一定是合理的（请见练习 3.5.31）。在实践中，两种方法的性能差别主要是因为拉链法为每个键值对都分配了一小块内存而线性探测则为整张表使用了两个很大的数组。对于非常大的散列表，这些做法对内存管理系统的要求也很不相同。在现代系统中，在性能优先的情景下，最好由专家去把握这种平衡。

有了这些假设，期望散列表能够支持和数组大小无关的常数级别的查找和插入操作是可能的。对于任意的符号表实现，这个期望都是理论上的最优性能。但散列表并非包治百病的灵丹妙药，因为：

* 每种类型的键都需要一个优秀的散列函数；
* 性能保证来自于散列函数的质量；
* 散列函数的计算可能复杂而且昂贵；
* 难以支持有序性相关的符号表操作。

在考察了这些基本问题之后，我们会在 3.5 节的开头将散列表和我们学习过的其他符号表的实现方法进行比较。

###答疑

**问**　Java 的 `Integer`、`Double` 和 `Long` 类型的 `hashCode()` 方法是如何实现的？

**答**　`Integer` 类型会直接返回该整数的 32 位值。对于 `Double` 和 `Long` 类型，Java 会返回值的机器表示的前 32 位和后 32 位**异或**的结果。这些方法可能不够随机，但它们的确能够将值散列。

**问**　当能够动态调整数组大小时，散列表的大小总是 2 的幂，这不是个问题吗？这样 `hash()` 方法就只使用了 `hashCode()` 返回值的低位。

**答**　是的，这个问题在默认实现中特别明显。解决这个问题的一种方法是先用一个大于 `M` 的素数来散列键值对，例如：

```
private int hash(Key x)
{
   int t = x.hashCode() & 0x7fffffff;
   if (lgM < 26) t = t % primes[lgM+5];
   return t % M;
}
```

这段代码假设我们使用了一个变量 ![\lg M](https://private.codecogs.com/gif.latex?\lg%20M)，它的值等于 ![\lg M](https://private.codecogs.com/gif.latex?\lg%20M)（直接初始化为该值，并在将数组长度加倍或者减半时增大或者减小它），以及一个数组 `primes[]`，其中含有大于各个 2 的幂的最小素数（请见右表 {3[这里似乎和表的内容不相符，表中 `prime[k]` 的值是小于 ![2^k](https://private.codecogs.com/gif.latex?2^k) 的最大素数。——译者注]}）。代码中的常数 5 是随意取的一个值——我们希望第一次取余操作（%）能够将所有值散列在小于该素数的范围之内，而第二次取余操作则将其中的 5 个值映射到小于 `M` 的所有值中。请注意，对于很大的 `M` 这是没有意义的。

![{35%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.070.png)

{-:-}**将散列表大小设为素数**

**问**　我忘记了，为什么不将 `hash(x)` 实现为 `x.hashCode() % M` ？

**答**　散列值必须在 0 到 `M`-1 之间，而在 Java 中，取余（`%`）的结果可能是负数。

**问**　那为什么不将 `hash(x)` 实现为 `Math.abs(x.hashCode()) % M` ？

**答**　问得好，不幸的是对于最大的整数 `Math.abs()` 会返回一个负值。对于许多典型情况，这种溢出不会造成什么问题，但对于散列表这可能使你的程序在几十亿次插入之后崩溃，这很难说。例如，Java 中字符串 `"polygenelubricants"` 的散列值为 ![-2^{31} ](https://private.codecogs.com/gif.latex?-2^{31})。找出散列值为这个数（以及为 0）的其他字符串已经变成了一种有趣的算法谜题。

**问**　在算法 3.5 中为什么使用 `SequentialSearchST` 而非 `BinarySearchST` 或者 `RedBlackBST` ？

**答**　一般来说，我们希望散列到每个索引值上的键越少越好，而对于小规模符号表初级实现的性能一般更好。在某些情况下，使用这些复杂的实现也许能够稍稍将性能提高，但最好让专家来进行这种调优。

**问**　散列表的查找比红黑树更快吗？

**答**　这取决于键的类型，它决定了 `hashCode()` 的计算成本是否大于 `compareTo()` 的比较成本。对于常见的键类型以及 Java 的默认实现，这两者的成本是近似的，因此散列表会比红黑树快得多，因为它所需的操作次数是固定的。但需要注意的是，如果要进行有序性相关的操作，这个问题就没有意义了，因为散列表无法高效地支持这些操作。进一步的讨论请见 3.5 节。

**问**　为什么不能让基于线性探测的散列表充满四分之三？

**答**　没什么特别的原因。你可以选择任意的 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 值并用命题 M 来估计相应的查找成本。对于 ![\alpha=3/4](https://private.codecogs.com/gif.latex?\alpha=3/4)，查找命中的平均成本为 2.5，未命中的为 8.5。但如果你允许 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 增长到 7/8，查找未命中的平均成本就会达到 32.5，这可能已经超出了你的承受能力。随着 ![\alpha](https://private.codecogs.com/gif.latex?\alpha) 趋近于 1，命题 M 得出的估计值的准确度会下降，但你不应该使散列表的占有率达到那种程度。

###练习

**3.4.1**　将键 `E A S Y Q U T I O N` 依次插入一张初始为空且含有 ![M=5](https://private.codecogs.com/gif.latex?M=5) 条链表的基于拉链法的散列表中。使用散列函数 `11 k % M` 将第 ![k](https://private.codecogs.com/gif.latex?k) 个字母散列到某个数组索引上。

**3.4.2**　重新实现 `SeparateChainingHashST`，直接使用 `SequentialSearchST` 中链表部分的代码。

**3.4.3**　修改你为上一道练习给出的实现，为每个键值对添加一个整型变量，将其值设为插入该键值对时散列表中元素的数量。实现一个方法，将该变量的值大于给定整数 `k` 的键（及其相应的值）全部删除。**注意**：这个额外的功能在为编译器实现符号表时很有用。

**3.4.4**　使用散列函数 `(a * k) % M` 将 `S E A R C H X M P L` 中的第 ![k](https://private.codecogs.com/gif.latex?k) 个键散列为一个数组索引。编写一段程序找出 `a` 和最小的 `M`，使得该散列函数得到的每个索引都不相同（没有碰撞）。这样的函数也被称为**完美散列函数**。

**3.4.5**　下面这段 `hashCode()` 的实现合法吗？

```
public int hashCode()
{ return 17; }
```

　　　如果合法，请描述它的使用效果，否则请解释原因。

**3.4.6**　假设键为 ![t](https://private.codecogs.com/gif.latex?t) 位整数。对于一个使用素数 ![M](https://private.codecogs.com/gif.latex?M) 的除留余数法的散列函数，请证明对于键的每一位，都存不同的两个键，它们的散列值只有该位不同。

**3.4.7**　考虑对于整型的键将除留余数法的散列函数实现为 `(a * k) % M`，其中 `a` 为一个任意的固定素数。这样是否足以利用键的所有位使得我们可以使用一个非素数 M 了呢？

**3.4.8**　对于 ![N=10](https://private.codecogs.com/gif.latex?N=10)、![10^2](https://private.codecogs.com/gif.latex?10^2)、![10^3](https://private.codecogs.com/gif.latex?10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)，请估计将 ![N](https://private.codecogs.com/gif.latex?N) 个键插入一张 `SeparateChainingHashST` 的散列表后还剩多少空链表？**提示**：参考练习 2.5.31。

**3.4.9**　为 `SeparateChainingHashST` 实现一个即时的 `delete()` 方法。

**3.4.10**　将键 `E A S Y Q U T I O N` 依次插入一张初始为空且大小为 ![M=16](https://private.codecogs.com/gif.latex?M=16) 的基于线性探测法的散列表中。使用散列函数 `11 k % M` 将第 ![K](https://private.codecogs.com/gif.latex?K) 个字母散列到某个数组索引上。对于 ![M=10](https://private.codecogs.com/gif.latex?M=10) 将本题重新完成一遍。

**3.4.11**　将键 `E A S Y Q U T I O N` 依次插入一张初始为空大小为 ![M=4](https://private.codecogs.com/gif.latex?M=4) 的基于线性探测法的散列表中，数组只要达到半满即自动将长度加倍。使用散列函数 `11 k % M` 将第 ![k](https://private.codecogs.com/gif.latex?k) 个字母散列到某个数组索引上。给出得到的散列表的内容。

**3.4.12**　设有键 A 到 G，散列值如下所示。将它们按照一定顺序插入到一张初始为空大小为 7 的基于线性探测的散列表中（这里数组的大小不会动态调整）。下面哪个选项是不可能由插入这些键产生的？给出这些键在构造散列表时可能所需的最大和最小探测次数，并给出相应的插入顺序来证明你的答案。

　　　a. E F G A C B D

　　　b. C E B G F D A

　　　c. B D F A C E G

　　　d. C G B A D E F

　　　e. F G B D A C E

　　　f. G E C A D B F

<table class="table table-bordered table-striped table-condensed">
<tr><th>键</th><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td></tr>
<tr><th>散列值（M=7）</th><td>2</td><td>0</td><td>0</td><td>4</td><td>4</td><td>4</td><td>2</td></tr>
</table>

**3.4.13**　在下面哪些情况中基于线性探测的散列表中的一次随机的命中查找所需的时间是**线性**的？

　　　a. 所有键均被散列到同一个索引上

　　　b. 所有键均被散列到不同的索引上

　　　c. 所有键均被散列到同一个偶数索引上

　　　d. 所有键均被散列到不同的偶数索引上

**3.4.14**　对于未命中的查找回答上一道练习的问题，假设被查找的键被散列到表中任意位置的可能性均等。

**3.4.15**　在最坏情况下，向一张初始为空、基于线性探测法并能够动态调整数组大小的散列表中插入 ![N](https://private.codecogs.com/gif.latex?N) 个键需要多少次比较？

**3.4.16**　假设有一张大小为 ![10^6](https://private.codecogs.com/gif.latex?10^6) 的基于线性探测的散列表已经半满了，被占用的元素随机分布。请估计所有索引值中能够被 100 整除的位置都被占用的概率。

**3.4.17**　使用 3.4.3.1 节的 `delete()` 方法从标准索引测试用例使用的 `LinearProbingHashST` 中删除键 `C` 并给出结果散列表的内容。

**3.4.18**　为 `SeparateChainingHashST` 添加一个构造函数，使用例能够指定查找操作可以接受的在链表中进行的平均探测次数。动态调整数组的大小以保证链表的平均长度小于该值，并使用答疑中所述的方法来保证 `hash()` 方法的系数总是素数。

**3.4.19**　为 `SeparateChainingHashST` 和 `LinearProbingHashST` 实现 `keys()` 方法。

**3.4.20**　为 `LinearProbingHashST` 添加一个方法来计算一次命中查找的平均成本，假设表中每个键被查找的可能性相同。

**3.4.21**　为 `LinearProbingHashST` 添加一个方法来计算一次**未命中**查找的平均成本，假设使用了一个随机的散列函数。**请注意**：要解决这个问题并不一定要计算所有的散列函数。

**3.4.22**　为下列数据类型实现 `hashCode()` 方法：`Point2D`、`Interval`、`Interval2D` 和 `Date`。

**3.4.23**　对于字符串类型的键，考虑 `R = 256` 和 `M = 255` 的除留余数法的散列函数。请证明这是一个糟糕的选择，因为任意排列的字母所得字符串的散列值均相同。

**3.4.24**　对于 `double` 类型，分析拉链法、线性探测法和二叉查找树的内存使用情况。将结果整理成类似于表 3.4.2 的表格。

###提高题

**3.4.25**　**散列值的缓存**。修改 3.4.1.8 节的 `Transaction` 类并维护一个变量 `hash`，在 `hashCode()` 方法第一次为一个对象计算散列值后将值保存在 `hash` 中，这样随后的调用就不必重新计算了。**请注意**：这种方法仅适用于不可变的数据类型。

**3.4.26**　**线性探测法中的延时删除**。为 `LinearProbingHashST` 添加一个 `delete()` 方法，在删除一个键值对时将其值设为 `null`，并在调用 `resize()` 方法时将键值对从表中删除。这种方法的主要难点在于决定何时应该调用 `resize()` 方法。**请注意**：如果后来的 `put()` 方法为该键指定了一个新的值，你应该用新值将 `null` 覆盖掉。你的程序在决定扩张或者收缩数组时不但要考虑到数组的空元素，也要考虑到这种**死掉的**元素。

**3.4.27**　**二次探测**。修改 `SeparateChainingHashST`，进行二次散列并选择两条链表中的较短者。将键 `E A S Y Q U T I O N` 依次插入一张初始为空且大小为 ![M=3](https://private.codecogs.com/gif.latex?M=3) 的基于拉链法的散列表中，以 `11 k % M` 作为第一个散列函数，`17 k % M` 作为第二个散列函数来将第 ![k](https://private.codecogs.com/gif.latex?k) 个字母散列到某个数组索引上。给出插入过程的轨迹以及随机的命中查找和未命中查找在该符号表中所需的平均探测次数。

**3.4.28**　**二次散列**。修改 `LinearProbingHashST`，进行二次散列以得到探测起始点。确切地说，是将（所有的）`(i + 1) % M` 替换为 `(i + k) % M`，其中 `k` 是一个非零、和 `M` 互质且和键相关的整数。**提示**：可以令 `M` 为素数来满足互质的条件。使用上一道练习中给出的两个散列函数，将键　`E A S Y Q U T I O N` 依次插入一张初始为空且大小为 ![M=11](https://private.codecogs.com/gif.latex?M=11) 的基于线性探测的散列表中。给出插入过程的轨迹以及随机的命中查找和未命中查找所需的平均探测次数。

**3.4.29**　**删除操作**。分别为前两题中所述的散列表实现即时的 `delete()` 方法。

**3.4.30**　卡方值（chi—square statistic）。为 `SeparateChainingHashST` 添加一个方法来计算散列表的 ![{\cal X}^2](https://private.codecogs.com/gif.latex?{\cal%20X}^2)。对于大小为 ![M](https://private.codecogs.com/gif.latex?M) 并含有 ![N](https://private.codecogs.com/gif.latex?N) 个元素的散列表，这个值的定义为：

![\mathcal{X}^2=(M/N)((f_0-N/M)^2+(f_1-N/M)^2+\cdots+(f_{M-1}-N/M)^2)](https://private.codecogs.com/gif.latex?\mathcal{X}^2=(M/N%29((f_0-N/M%29^2+(f_1-N/M%29^2+\cdots+(f_{M-1}-N/M%29^2%29)

　　　其中，![f_i](https://private.codecogs.com/gif.latex?f_i) 为散列值为 ![i](https://private.codecogs.com/gif.latex?i) 的键的数量。这个统计数据是检测我们的散列函数产生的随机值是否满足假设的一种方法。如果满足，对于 ![N>cM](https://private.codecogs.com/gif.latex?N%3EcM)，这个值落在 ![M-\sqrt{M}](https://private.codecogs.com/gif.latex?M-\sqrt{M}) 和 ![M+\sqrt{M}](https://private.codecogs.com/gif.latex?M+\sqrt{M}) 之间的概率为 ![1-1/c](https://private.codecogs.com/gif.latex?1-1/c)。

**3.4.31**　**Cuckoo 散列函数**。实现一个符号表，在其中维护两张散列表和两个散列函数。一个给定的键只能存在于一张散列表之中。在插入一个新键时，在其中一张散列表中插入该键。如果这张表中该键的位置已经被占用了，就用新键替代老键并将老键插入到另一张散列表中（如果在这张表中该键的位置也被占用了，那么就将这个占用者重新插入第一张散列表，把位置腾给被插入的键），如此循环往复。动态调整数组大小以保持两张表都不到半满。这种实现中查找所需的比较次数在最坏情况下是一个常数，插入操作所需的时间在均摊后也是常数。

**3.4.32**　**散列攻击**。找出 ![2^N](https://private.codecogs.com/gif.latex?2^N) 个 `hashCode()` 方法返回值均相同且长度均为 ![2^N](https://private.codecogs.com/gif.latex?2^N) 的字符串。假设 `String` 类型的 `hashCode()` 方法的实现如下：

```
public int hashCode()
{
   int hash = 0;
   for (int i = 0; i < length(); i ++)
      hash = (hash * 31) + charAt(i);
   return hash;
}
```

　　　**重要提示**：`Aa` 和 `BB` 的散列值相同。

**3.4.33**　**糟糕的散列函数**。考虑 Java 的早期版本中 `String` 类型的 `hashCode()` 方法的实现，如下所示：

```
public int hashCode()
{
   int hash = 0;
   int skip = Math.max(1, length()/8);
   for (int i = 0; i < length(); i += skip)
      hash = (hash * 37) + charAt(i);
   return hash;
}
```

　　　说明你认为设计者选择这种实现的原因以及为什么它被替换成了上一道练习中的实现。

###实验题

**3.4.34**　**散列的成本**。用各种常见的数据类型进行实验以得到 `hash()` 方法和 `compareTo()` 方法的耗时比的经验数据。

**3.4.35**　**卡方检验**。使用你为练习 3.4.30 给出的答案验证常用数据类型的散列函数产生的值是否随机。

**3.4.36**　**链表长度的范围**。编写一段程序，向一张长度为 ![N/100](https://private.codecogs.com/gif.latex?N/100) 的基于拉链法的散列表中插入 ![N](https://private.codecogs.com/gif.latex?N) 个随机的 `int` 键，找出表中最长和最短的链表的长度，其中 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)。

**3.4.37**　**混合使用**。用实验研究在 `SeparateChainingHashST` 中使用正 `RedBlackBST` 代替 `SequentialSearchST` 来处理碰撞的性能。这种方案的优点是即使散列函数很糟糕它仍然能够保证对数级别的性能，缺点是需要维护两种不同的符号表实现。实际效果如何呢？

**3.4.38**　**拉链法的分布**。编写一段程序，向一张大小为 ![10^5](https://private.codecogs.com/gif.latex?10^5) 的基于线性探测法的散列表中插入 ![10^5](https://private.codecogs.com/gif.latex?10^5) 个小于 ![10^6](https://private.codecogs.com/gif.latex?10^6) 的随机非负整数并在每 ![10^3](https://private.codecogs.com/gif.latex?10^3) 次插入后打印出当前探测的总次数。讨论你的结果在何种程度上验证了命题 K。{4[这个题目和拉链无关，是原书的bug。——译者注]}

**3.4.39**　**线性探测法的分布**。向一张大小为 ![N](https://private.codecogs.com/gif.latex?N) 的基于线性探测法的散列表中插入 ![N/2](https://private.codecogs.com/gif.latex?N/2) 个随机非负整数并根据表中的键簇计算一次未命中查找的平均成本，其中 ![N=10^3](https://private.codecogs.com/gif.latex?N=10^3)、![10^4](https://private.codecogs.com/gif.latex?10^4)、![10^5](https://private.codecogs.com/gif.latex?10^5) 和 ![10^6](https://private.codecogs.com/gif.latex?10^6)。讨论你的结果在何种程度上验证了命题 M。

**3.4.40**　**绘图**。改进 `LinearProbingHashST` 和 `SeparateChainingHashST` 的实现，使之绘出和正文中类似的图表。

**3.4.41**　**二次探测**。用实验研究来评估二次探测法的效果（请见练习 3.4.27）。

**3.4.42**　**二次散列**。用实验研究来评估二次散列法的效果（请见练习 3.4.28）。

**3.4.43**　**停车问题**（D.　Knuth)。用实验研究来验证一个猜想：向一张大小为 ![M](https://private.codecogs.com/gif.latex?M) 的基于线性探测法的散列表中插入 ![M](https://private.codecogs.com/gif.latex?M) 个随机键所需的比较次数为 ![\sim cM^{3/2}](https://private.codecogs.com/gif.latex?\sim%20cM^{3/2})，其中 ![{\rm c}=\sqrt{\pi/2}](https://private.codecogs.com/gif.latex?{\rm%20c}=\sqrt{\pi/2}) 。

##3.5　应用

在计算机发展的早期，符号表帮助程序员从使用机器语言的数字地址进化到在汇编语言中使用符号名称；在现代应用程序中，符号名称的含义能够通行于跨越全球的计算机网络。快速查找算法曾经并继续在计算机领域中扮演着重要角色。符号表的现代应用包括科学数据的组织，例如在基因组数据中寻找分子标记或模式从而绘制全基因组图谱；网络信息的组织，从搜索在线贸易到数字图书馆；以及互联网基础构架的实现，例如包在网络结点中的路由、共享文件系统和流媒体等。高效的查找算法确保了这些以及无数其他重要的应用程序成为可能。在本节中我们会考察几个有代表性的例子。

* 能够快速并灵活地从文件中提取由逗号分隔的信息的一个字典程序和一个索引程序。逗号分隔的格式（及类似格式）常用于存储网络信息。
* 为一组文件构建逆向索引的一个程序。
* 一个表示稀疏矩阵的数据类型。它用符号表处理的问题规模能够远远大于这种数据类型的标准实现。

在第 6 章中，我们会学习一种适合于数据库或者文件系统的符号表，它能够保存的数据量超过你的想象。

符号表在本书其他章节的算法中也会起到关键的作用。例如，我们会使用符号表来表示图（第 4 章）以及处理字符串（第 5 章）。

在本章中我们已经看到，实现能够快速进行各种操作的符号表是一项很有挑战性的任务。另一方面，我们学习过的实现都经过了仔细研究，应用广泛并且在许多环境中都可用（包括 Java 的标准库）。从现在开始，符号表就将成为你的编程工具箱中的一件重要武器。

###3.5.1　我应该使用符号表的哪种实现

表 3.5.1 总结了由本章中多个命题和性质得到的各种符号表算法的性能特点（散列表的最坏情况除外，它的结果来自于研究文献并且也不太可能在实际应用中遇到）。从表中显然可以知道，对于典型的应用程序，应该在散列表和二叉查找树之间进行选择。

相对二叉查找树，散列表的优点在于代码更简单，且查找时间最优（常数级别，只要键的数据类型是标准的或者简单到我们可以为它写出满足（或者近似满足）均匀性假设的高效散列函数即可）。二叉查找树相对于散列表的优点在于抽象结构更简单（不需要设计散列函数），红黑树可以保证最坏情况下的性能且它能够支持的操作更多（如排名、选择、排序和范围查找）。根据经验法则，大多数程序员的第一选择都是散列表，在其他因素更重要时才会选择红黑树。在第 5 章中我们会遇到这个经验法则的例外：当键都是长字符串时，我们可以构造出比红黑树更灵活而又比散列表更高效的数据结构。

**表 3.5.1　各种符号表实现的渐进性能的总结**

<table class="table table-bordered table-striped table-condensed">
<tr><th rowspan="2">算法（数据结构）</th><th colspan="2">最坏情况下的运行时间的增长数量级（<i>N</i> 次插入之后）</th><th colspan="2">平均情况下的运行时间的增长数量级（<i>N</i> 次随机插入之后）</th><th rowspan="2">关键接口</th><th rowspan="2">内存使用（字节）</th></tr>
<tr><th>查找</th><th>插入</th><th>查找命中</th><th>插入</th></tr>
<tr><td>顺序查询（无序链表）</td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N/2" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><code>equals()</code></td><td><img src="https://private.codecogs.com/gif.latex?48N" /></td></tr>
<tr><td>二分查找（有序数组）</td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N/2" /></td><td><code>compareTo()</code></td><td><img src="https://private.codecogs.com/gif.latex?16N" /></td></tr>
<tr><td>二叉树查找（二叉查找树）</td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.39\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.39\lg%20N" /></td><td><code>compareTo()</code></td><td><img src="https://private.codecogs.com/gif.latex?64N" /></td></tr>
<tr><td>2-3 树查找（红黑树）</td><td><img src="https://private.codecogs.com/gif.latex?2\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?2\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.00\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?1.00\lg%20N" /></td><td><code>compareTo()</code></td><td><img src="https://private.codecogs.com/gif.latex?64N" /></td></tr>
<tr><td>拉链法<sup>*</sup>（链表数组）</td><td><img src="https://private.codecogs.com/gif.latex?%3C\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?%3C\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?N/(2M%29" /></td><td><img src="https://private.codecogs.com/gif.latex?N/M" /></td><td><code>equals()</code><br><code>hashCode()</code></td><td><img src="https://private.codecogs.com/gif.latex?48N+32M" /></td></tr>
<tr><td>线性探测法<sup>*</sup>（并行数组）</td><td><img src="https://private.codecogs.com/gif.latex?c\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?c\lg%20N" /></td><td><img src="https://private.codecogs.com/gif.latex?%3C1.5" /></td><td><img src="https://private.codecogs.com/gif.latex?%3C2.5" /></td><td><code>equals()</code><br><code>hashCode()</code></td><td>在 <img src="https://private.codecogs.com/gif.latex?32N" /> 和 <img src="https://private.codecogs.com/gif.latex?128N" /> 之间</td></tr>
</table>

<sup>\* 需要均匀并独立的散列函数。</sup>

我们的符号表实现已经可以广泛应用于各种应用程序，但经过简单的修改后这些算法还可以适应并支持其他一些使用广泛的场景，有必要在这里提一下。

####3.5.1.1　原始数据类型

假设我们有一张符号表，其中整型的键对应着浮点型的值。如果使用我们的标准实现，键和值会被储存在 `Integer` 和 `Double` 类中，因此我们需要两个额外的引用来访问每个键值对。如果应用程序只会使用几千个键进行几千次查找，那么这些引用可能没什么问题。但如果是对几十亿个键进行几十亿次查找，那么这些引用就会造成巨大的额外开销。使用原始数据类型代替 `Key` 类型可以为每个键值对节省一个引用。当键的值也是原始数据类型时我们又可以节约另外一个引用。图 3.5.1 显示了在拉链法中使用原始数据类型的情况，这种交换也适用于符号表的其他实现。对于性能优先的应用程序，这种改进并不困难并且值得一试（请见练习 3.5.4）。

![{50%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.071.png)

**图 3.5.1　拉链法的内存使用情况**

####3.5.1.2　重复键

符号表的实现有时需要专门考虑重复键的可能性。许多应用都希望能够为同一个键绑定多个值。例如在一个交易处理系统中，多笔交易的客户属性都是相同的。符号表不允许重复键，因此用例只能自己管理重复键。本节稍后我们会遇到一个这样的示例程序。我们可以考虑在实现中允许数据结构保存重复的键值对，并在查找时返回给定的键所对应的**任意值之一**。我们也可以加入一个方法来返回给定的键对应的**所有值**。修改我们实现的二叉查找树和散列表来在数据结构中保存重复的键并不困难。修改红黑树可能会稍有挑战（请见练习 3.5.9 和练习 3.5.10）。这种实现在许多文献中都可以找到（包括本书以前的版本）。

####3.5.1.3　Java 标准库

Java 的 java.util.TreeMap 和 java.util.HashMap 分别是基于红黑树和拉链法的散列表的符号表实现。TreeMap 没有直接支持 `rank()`、`select()` 和我们的有序符号表 API 中的一些其他方法，但它支持一些能够高效实现这些方法的操作。HashMap 和我们的 `LinearProbingHashST` 的实现基本相同——它也会动态调整数组的大小来保持使用率大约不超过 75%。

为了保持前后一致，我们在本书中一般会使用 3.3 节中基于红黑树的符号表或是 3.4 节中基于线性探测法的符号表。为了节省篇幅并保证符号表的用例和具体实现的独立性，我们在调用代码中将使用 `ST` 来代替有序符号表 `RedBlackBST`，用 `HashST` 来代替有序性操作无关紧要且拥有散列函数的 `LinearProbingHashST`。尽管我们知道某些应用可能需要改变或者扩展这些算法和数据结构，我们仍然要这样约定。你应该使用哪种符号表？随便，只要记得测试你的选择是否能够提供所需要的性能就好。

###3.5.2　集合的 API

某些符号表的用例不需要处理值，它们只需要能够将键插入表中并检测一个键在表中是否存在。因为我们不允许重复的键，这些操作对应着下面这组 API（表 3.5.2），它们只处理表中所有键的**集合**，和相应的值无关。

**表 3.5.2　集合数据类型的一组基本 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>public class&nbsp;&nbsp;<b>SET</b>&lt;Key></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SET()</code></td><td>创建一个空的集合</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;add(Key key)</code></td><td>将键 <code>key</code> 加入集合</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;delete(Key key)</code></td><td>从集合中删除键 <code>key</code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;contains(Key key)</code></td><td>键 <code>key</code> 是否在集合之中</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;&nbsp;isEmpty()</code></td><td>集合是否为空</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;size()</code></td><td>集合中键的数量</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;toString()</code></td><td>对象的字符串表示</td></tr>
</table>

只要忽略键关联的值或者使用一个简单的类进行封装，你就可以将任何符号表的实现变成一个 `SET` 类的实现（请见练习 3.5.1 至练习 3.5.3）。

```
public class DeDup
{
   public static void main(String[] args)
   {
      HashSET<String> set;
      set = new HashSET<String>();
      while (!StdIn.isEmpty())
      {
         String key = StdIn.readString();
         if (!set.contains(key))
         {
            set.add(key);
            StdOut.print(key + ＂＂);
         }
      }
   }
}
```

{-:-}`Dedup` 过滤器

用并（union）、交（intersection）、补（complement）和其他数学集合的操作扩展 `SET` 类需要的 API 更复杂（例如，complement 操作需要先定义所有可能的键的**集合**），使用的算法也更有趣，练习 3.5.17 会讨论它们。

基于符号表 `ST`，`SET` 类分有序和无序两个版本。如果键都是 `Comparable` 的，我们可以为有序的键定义 `min()`、`max()`、`floor()`、`ceiling()`、`deleteMin()`、`deleteMax()`、`rank()`、`select()` 以及需要两个参数的 `size()` 和 `get()` 方法来构成一组完整的 API。为了遵守我们关于符号表 `ST` 的约定，我们在用例中用 `SET` 表示有序的集合，用 `HashSET` 表示无序的集合。

为了演示 `SET` 的使用方法，我们来看一组**过滤器**（filter）程序。它会从标准输入读取一组字符串并将其中一些写入标准输出。这种程序源自于早期内存很小无法容纳所有数据的计算机系统。它们在今天仍有用武之地，那就是当你的程序需要从网络中获取输入时。在例子中我们使用 tinyTale. txt（请见表 3.1.7）作为输入。为了保证可读性，我们将输入中的换行符保留到了输出中，不过代码并没有这么做。

####3.5.2.1　dedup

过滤器例子的原型是一个调用 `SET` 或者 `HashSET` 来去掉输入流中的重复项的程序，一般叫做 dedup（如右侧代码所示）。我们会保存一个已知字符串的集合。如果下一个键已经**存在于**集合中，忽略之；如果不在，将它加入集合并打印它。标准输出中键的顺序和它们在标准输入中的顺序相同，只是去掉了重复项。这个过程需要的空间和输入中不同的键的数量成正比（一般比键的总量要小得多）。

```
% java DeDup < tinyTale.txt
it was the best of times worst
age wisdom foolishness
epoch belief incredulity
season light darkness
spring hope winter despair
```

####3.5.2.2　白名单和黑名单

过滤器的另一个经典应用是用一个文件中保存的键来判定输入流中的哪些键可以被传递到输出流。这个通用程序有许多天然的应用，最简单的例子就是**白名单**。其中，文件中的键被定义为**好键**。用例可以选择将所有**不在**白名单上的键传递到标准输出并忽略所有**白名单上的键**（就像第 1 章中我们的第一个程序处理的那个例子一样），也可以选择只将所有**在**白名单上的键传递到标准输出并忽略所有**不在**白名单上的键（如右侧这段代码所示，使用 `HashSET` 实现的 `WhiteFilter`）。例如，电子邮件程序可能会允许用户通过这样一个过滤器指定朋友的邮件地址并将所有来自其他人的邮件当成垃圾邮件。我们根据指定的列表构造一个 `HashSET`，然后从标准输入中读取所有键。如果下个键**存在于**集合之中则打印它，否则就忽略它。**黑名单**则与之相反，名单上的所有键都被定义为**坏键**。同样，黑名单过滤器也有两种自然的应用。在电子邮件的例子中，用户可能会指定一些已知的垃圾邮件发送者的地址并要求程序放过所有不是由这些地址发来的邮件。我们可以用 `HashSET` 实现一个 `BlackFilter`，过滤条件只需要和 `WhiteFilter` 相反即可。实际应用中，信用卡公司用黑名单过滤被盗用的信用卡号，因特网路由器用白名单来实现防火墙。它们使用的名单可能非常巨大，输入无限并且响应时间要求非常严格。我们已经学习过的符号表实现能够很好地满足这些需求。

```
public class WhiteFilter
{
   public static void main(String[] args)
   {
      HashSET<String> set;
      set = new HashSET<String>();
      In in = new In(args[0]);
      while (!in.isEmpty())
         set.add(in.readString());
      while (!StdIn.isEmpty())
      {
         String word = StdIn.readString();
         if (set.contains(word))
            StdOut.print(word + ＂＂);
      }
   }
}
```

{-:-}白名单过滤器

```
% more list.txt
was it the of

% java WhiteFilter list.txt < tinyTale.txt
it was the of it was the of
it was the of it was the of
it was the of it was the of
it was the of it was the of
it was the of it was the of

% java BlackFilter list.txt < tinyTale.txt
best times worst times
age wisdom age foolishness
epoch belief epoch incredulity
season light season darkness
spring hope winter despair
```

###3.5.3　字典类用例

符号表使用最简单的情况就是用连续的 `put()` 操作构造一张符号表以备 `get()` 查询。许多应用程序都将符号表看做一个可以方便地查询并更新其中信息的**动态**字典。以下列出了这类用例中的一些常见例子。

* **电话黄页**。当符号表中的键是人名而值是电话号码时，这张符号表就成了一个电话本。但和一本纸质印刷的电话黄页的一个重大不同是我们可以向其中添加新的名字或者更新其中的电话号码。我们也可以将电话号码作为键而将人名作为值——如果你从来没这么做过，试着在浏览器的搜索栏中输入你的电话（包括区号）并搜索一下。
* **字典**。将一个单词和它的含义关联起来就得到了“字典”。几个世纪以来人们都会在家里和办公室里放一本纸质的字典以查找单词（键）的定义和拼写（值）。现在，有了优秀的符号表实现，人们在电脑上可以使用内置的拼写检查器并快速查到单词的意义。
* **账户信息**。如今股民们都会在网上实时获取股票的价格信息。这些网络服务会关联股票名称（键）和当前价格（值）以及丰富的其他信息。类似的商业应用非常多，比如金融机构会将名字或者账号与账户信息关联，学校会将学生的姓名或者学号与他的成绩关联，等等。
* **基因组学**。在现代基因组学中符号的作用非常重要。最简单的例子就是 A、C、T 和 G 这几个字母代表了活体组织中 DNA 的四种核苷酸。另一个比较简单的例子是密码子（核苷酸三联体）和氨基酸的对应关系（TTA 表示亮氨酸，TCT 表示丝氨酸，等等），以及氨基酸序列和蛋白质之间的对应关系。基因组学的研究者每天都需要使用各种符号表来组织这些信息。
* **实验数据**。从天体物理学到动物学，现代科学家被各种实验数据包围着。有效的组织和访问这些信息才能理解它们的含义，而符号表正是一个关键的入手点。基于符号表的高级数据结构和算法如今已经成为科学研究的一个重要部分。
* **编译器**。符号表最早期的应用之一就是组织程序代码的信息。最初，计算机程序只是一串简单的数字，但程序员们很快发现使用符号来表示操作和内存地址（变量名）要方便得多。将名称和数字关联起来就需要一张符号表。随着程序的增长，符号表操作的性能逐渐变成了程序开发效率的瓶颈，为此而开发的数据结构和算法就是我们在本章中学习的内容。
* **文件系统**。我们都在使用符号表定期整理计算机系统中的数据。也许其中最明显的例子就是文件系统了，因为是它将文件名（键）和文件内容的地址（值）关联起来。音乐播放器同样使用文件系统关联了歌曲名（键）和歌曲的位置（值）。
* **互联网 DNS**。域名系统（DNS）是互联网信息组织的基础，它可以将人类能够理解的 URL（键，如 www.princeton.edu 或是 www.wikipedia.org）和计算机网络中路由器能够理解的 IP 地址（值，如 208.216.181.15 或是 207.142.131.206 ）关联起来。这个系统被称为下一代“电话黄页”。有了它，人们就可以使用便于记忆的域名，而机器也可以高效地处理对应的数字。为此，全球互联网的路由器中每秒钟进行的符号表查找次数是个天文数字，所以性能显然非常重要。每年，互联网上都会新增上百万台电脑和其他设备，因此互联网路由器中的符号表也需要能够动态地适应它们。

将以上几个典型应用总结一下，如表 3.5.3 所示。

**表 3.5.3-典型的字典类应用**

|应用领域|键|值|
|-|-|-|
|电话黄页|人名|电话号码|
|字典|单词|定义|
|账户信息|账号|余额|
|基因组|密码子|氨基酸|
|实验数据|数据 / 时间|实验结果|
|编译器|变量名|内存地址|
|文件共享|歌曲名|计算机|
|DNS|网站|IP 地址|

尽管已经涉及了许多领域，表 3.5.3 中选取的仍然只是几个有代表性的例子来说明符号表应用的广泛程度。每当使用一个名称来指代某种东西时，都用到了符号表。也许你只是用到了计算机的文件系统或是互联网，但在某个角落肯定有一张符号表在默默工作。

作为一个具体的例子，我们来看看一个从文件或者网页中提取由**逗号分隔的信息**（.csv 文件格式）的程序。这种格式存储的列表的信息不需要任何专用的程序就可以读取：数据都是文本，每行中各项均由逗号隔开。在本书的网站上你会找到很多 .csv 文件，都和我们刚才提到过的应用领域相关，包括 amino.csv（密码子和氨基酸的编码关系）、DJIA.csv（道琼斯工业平均指数历史上每天的开盘价、成交量和收盘价）、ip.csv（DNS 数据库中的一部分条目）和 upc.csv（广泛用于识别商品的 Uniform Product Code 条形码），如右侧代码框所示。电子表格等数据处理应用程序都能读写 .csv 文件，我们的例子程序说明你也能够编写 Java 程序来根据需要处理这些数据。

```
% more amino.csv
TTT,Phe,F,Phenylalanine
TTC,Phe,F,Phenylalanine
TTA,Leu,L,Leucine
TTG,Leu,L,Leucine
TCT,Ser,S,Serine
TCC,Ser,S,Serine
...
GAA,Gly,G,Glutamic Acid
GAG,Gly,G,Glutamic Acid
GGT,Gly,G,Glycine
GGC,Gly,G,Glycine
GGA,Gly,G,Glycine
GGG,Gly,G,Glycine

% more DJIA.csv
...
20-Oct-87,1738.74,608099968,1841.01
19-Oct-87,2164.16,604300032,1738.74
16-Oct-87,2355.09,338500000,2246.73
15-Oct-87,2412.70,263200000,2355.09
...
30-Oct-29,230.98,10730000,258.47
29-Oct-29,252.38,16410000,230.07
28-Oct-29,295.18,9210000,260.64
25-Oct-29,299.47,5920000,301.22
...

% more ip.csv
...
www.ebay.com,66.135.192.87
www.princeton.edu,128.112.128.15
www.cs.princeton.edu,128.112.136.35
www.harvard.edu,128.103.60.24
www.yale.edu,130.132.51.8
www.cnn.com,64.236.16.20
www.google.com,216.239.41.99
www.nytimes.com,199.239.136.200
www.apple.com,17.112.152.32
www.slashdot.org,66.35.250.151
www.espn.com,199.181.135.201
www.weather.com,63.111.66.11
www.yahoo.com,216.109.118.65
...

% more UPC.csv
...
0002058102040,,"1 1/4"" STANDARD STORM DOOR"
0002058102057,,"1 1/4"" STANDARD STORM DOOR" 0002058102125,,"DELUXE STORM DOOR UNIT"
0002082012728,"100/ per box","12 gauge shells"
0002083110812,"Classical CD","'Bits and Pieces'"
002083142882,CD,"Garth Brooks - Ropin' The Wind" 0002094000003,LB,"PATE PARISIEN"
0002098000009,LB,"PATE TRUFFLE COGNAC-M&H 8Z RW"
0002100001086,"16 oz","Kraft Parmesan"
0002100002090,"15 pieces","Wrigley's Gum"
0002100002434,"One pint","Trader Joe's milk"
...
```

{-:-}典型的含有由逗号分隔的值的文件（.csv）

下页的 `LookupCSV` 根据命令行指定的文件中的数据构建了一组键值对，并会打印出由标准输入读取的键对应的值。命令行参数包括一个文件名和两个整数，分别用来指定键和值所在的位置。

这个例子的目的在于展示符号表的作用和灵活性。哪个网站的 IP 地址是 128.112.136.35 ？www.cs.princeton.edu；哪种氨基酸对应着密码子 TCA ？丝氨酸；DJIA 在 1929 年 10 月 29 号的价格是多少？252.38；哪种商品的条形码是 0002100001086 ？卡夫芝士粉（Kraft Parmesan ）。有了 LookupCSV 和合适的 .csv 文件，可以轻易查到这类问题的答案。

在处理交互性的查询时，性能一般都不是问题（因为你的计算机在你打字的工夫就能检索上百万条信息），所以在使用 `LookupCSV` 时符号表的高效性并不明显。但是当程序需要进行（大量的）查找时，符号表的性能就很重要了。例如，互联网上的一台路由器每秒钟可能需要查找上百万个 IP 地址。在本书中，我们已经通过 `FrequencyCounter` 看到了高性能的必要性，在本节中你还会看到其他几个例子。

练习里有几个更加复杂的处理 .csv 文件的测试用例。例如，我们可以将一个字典动态化，允许它接受从标准输入中得到的指令来改变一个键的值，或是为它添加范围查找的功能，或者我们可以为同一个文件构造多个字典。

>**字典的查找**

>```
>public class LookupCSV
>{
>    public static void main(String[] args)
>    {
>       In in = new In(args[0]);
>       int keyField = Integer.parseInt(args[1]);
>       int valField = Integer.parseInt(args[2]);
>       ST<String, String> st = new ST<String, String>();
>       while (in.hasNextLine())
>       {
>          String line = in.readLine();
>          String[] tokens = line.split(“,”);
>          String key = tokens[keyField];
>          String val = tokens[valField];
>          st.put(key, val);
>       }
>       while (!StdIn.isEmpty())
>       {
>          String query = StdIn.readString();
>          if (st.contains(query))
>             StdOut.println(st.get(query));
>       }
>    }
>}
>```

>这段数据驱动的符号表用例会从一个文件中读取键值对并根据标准输入中的键打印出相应的值。其中键和值都是字符串，键和值所在的位置由命令行参数指定。

>```
>% java LookupCSV ip.csv 1 0
>128.112.136.35
>www.cs.princeton.edu
>```
>
>　
>
>```
>% java LookupCSV amino.csv 0 3
>TCC
>Serine
>```
>
>　
>
>```
>% java LookupCSV DJIA.csv 0 3
>29-Oct-29
>230.07
>```
>
>　
>
>```
>% java LookupCSV UPC.csv 0 2
>0002100001086
>Kraft Parmesan
>```

###3.5.4　索引类用例

字典的主要特点是每个键都有一个与之关联的值，因此基于关联型抽象数组来为一个键指定一个值的符号表数据类型正合适。每个账号都唯一地表示一个客户，每个条码都唯一地表示一种商品，等等。但一般说来，一个给定的键当然有可能和多个值相关联。例如，在我们的 amino.csv 的例子中，每个密码子都对应着一种氨基酸，但一种氨基酸有可能对应着多个密码子。如下页的 aminoI.txt 所示，文件的每一行都包含一个氨基酸和它对应的多个密码子。

我们使用**索引**来描述一个键和多个值相关联的符号表，下面是更多的例子。

![{55%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.072.png)

{-:-}一个小型索引文件（20行）


* **商业交易**。公司使用客户账户来跟踪一天内所有交易的一种方法是为当日所有交易建立一个索引，其中键是客户的账号，值是和该账号有关的所有交易。
* **网络搜索**。当你输入一个关键字并得到一系列含有这个关键字的网站时，你就是在使用网络搜索引擎创建的索引。每个键（查询）都关联着一个值（一组网页），当然实际情况会更加复杂，因为我们经常会指定多个关键字。
* **电影和演员**。本书网站上的 movies.txt 来自于 IMDB（互联网电影数据库）。每一行都含有一部电影的名称（键），随后是在其中出演的演员列表（值），用斜杠分隔，如图 3.5.2 所示。

![{85%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.073.png)

**图 3.5.2　一个巨型索引文件（250 000 多行）的一小部分**

将每个键关联的所有值都放入一个数据结构中（比如一个 `Queue`）并用它作为值就可以轻松构造一个索引。根据这一点来扩展 `LookupCSV` 很简单，我们将它留作一道练习（请见练习 3.5.12）。这里我们看一下 `LookupIndex`，它能够从一个文件，例如 aminoI.txt 或 movies.txt（分隔符不一定和 .csv 文件一样必须是逗号，但需要能够从命令行指定），构造一个索引。构造完成后 `LookupIndex` 能够接受查询并打印出键对应的所有值。更有意思的是 `LookupIndex` 也会为每个文件构造一个**反向索引**，也就是将键和值的角色互换。在氨基酸的例子中，它的功能相当于 `LookupCSV`（找到给定密码子所对应的氨基酸）。在电影和演员的例子中，它使我们能够找到一个演员出演过的所有电影。这项信息隐藏于数据当中，但没有符号表我们就很难获取它。**请仔细研究这个例子**，因为它深刻地揭示了符号表的本质特征。

表 3.5.4 总结了典型的索引类应用的符号表中键值的对应情况。

**表 3.5.4　典型的索引类应用**

|应用领域|键|值|
|-|-|-|
|基因组学|氨基酸|一系列密码子|
|商业交易|账号|一系列交易|
|网络搜索|关键字|一系列网页|
|IMDB|电影|一系列演员|

**反向索引**

**反向索引**一般是指用值来**查找**键的操作，比如我们有大量的数据并且希望知道某个键都在哪些地方出现过。这是另一种符号表的典型用例，它会进行一系列 `get()` 和 `put()` 的混合调用。和以前一样，我们将每个键和一个 `SET` 类型的值关联起来，这个值中包含了该键出现的所有位置。位置信息的性质和用途取决于应用场景：在一本书中，位置可能是书的页码；在一段程序中，位置可能是代码的行号；在基因组中，位置可能是一段基因序列的某个位点，等等。

* **互联网电影数据库（IMDB）**。在上文的例子中，输入是将每部电影和它的演员关联起来的一个索引。它的反向索引则会将每个演员和他出演过的所有电影相关联。
* **图书索引**。每本教科书都会有一个索引。你能在其中查找到一个术语和它出现过的所有页码。创建优秀的索引当然需要作者的努力来去掉常见和无关的词语，但文档处理系统能够使用符号表将整个过程自动化。一种有趣的特殊情况叫做对照索引（concordance），它会给出每个单词在书中出现的所有位置（请见练习 3.5.20）。
* **编译器**。在一个使用了许多符号的庞大程序中，能够知道每个名称的使用位置很有帮助。在以前，一张打印的以追踪各个符号在程序中使用位置的符号表曾经是程序员最重要的工具之一。在现代计算机系统中，符号表是程序员用来管理各种名称的工具软件的基础。
* **文件搜索**。现代操作系统都提供了根据关键字搜索文件的功能。对于这个索引，键就是关键字，值则是含有该关键字的所有文件的集合。
* **基因组学**。基因组学研究中的一个典型（或许有些过于简化了）情况是科学家希望知道一个给定的核苷酸序列在一个基因或者一组基因中的位置。某些特定序列或者近似序列的存在也许都有重大的意义。这种研究首先就需要一个序列和基因的对照索引，但也需要一些修改，因为基因是无法像句子一样被切分为单词的（请见练习 3.5.15）。

常见反向索引用例的符号表的键值对应情况如表 3.5.5 所示。

**表 3.5.5　典型的反向索引**

|应用领域|键|值|
|-|-|-|
|IMDB|演员|一系列电影|
|图书|术语|一系列页码|
|编译器|标识符|一系列使用位置|
|文件搜索|关键字|文件集合|
|基因组学|基因片段|一系列位置|

>**索引（以及反向索引）的查找**

>```
>public class LookupIndex
>{
>    public static void main(String[] args)
>    {
>       In in = new In(args[0]);   // （索引数据库）
>       String sp = args[1];       // （分隔符）
>       ST<String, Queue<String>> st = new ST<String, Queue<String>>();
>       ST<String, Queue<String>> ts = new ST<String, Queue<String>>();
>       while (in.hasNextLine())
>       {
>          String[] a = in.readLine().split(sp);
>          String key = a[0];
>          for (int i = 1; i < a.length; i++)
>          {
>             String val = a[i];
>             if (!st.contains(key)) st.put(key, new Queue<String>());
>             if (!ts.contains(val)) ts.put(val, new Queue<String>());
>             st.get(key).enqueue(val);
>             ts.get(val).enqueue(key);
>          }
>       }
>       while (!StdIn.isEmpty())
>       {
>          String query = StdIn.readLine();
>          if (st.contains(query))
>            for (String s : st.get(query))
>               StdOut.println(" " + s);
>          if (ts.contains(query))
>            for (String s : ts.get(query))
>               StdOut.println(" " + s);
>      }
>    }
>}
>```

>　

>```
>% java LookupIndex aminoI.txt ","
>Serine
>   TCT
>   TCA
>   TCG
>   AGT
>   AGC
>TCG
>   Serine
>
>% java LookupIndex movies.txt "/"
>Bacon, Kevin
>   Mystic River (2003)
>   Friday the 13th (1980)
>   Flatliners (1990)
>   Few Good Men, A (1992)
>   ...
>Tin Men (1987)
>   Blumenfeld, Alan
>   DeBoy, David
>   ...
>```

>这段数据驱动的符号表用例会从一个文件中读取键值对并根据标准输入中的键打印出相应的值。其中键为字符串，值为一列字符串，分隔符由命令行参数指定。

下面的 `FileIndex` 从命令行接受多个文件名并使用一张符号表来构造一个反向索引，它能够将任意文件中的任意一个单词和一个出现过这个单词的所有文件的文件名构成的 `SET` 对象关联起来。在接受标准输入的查询时，输出单词对应的文件列表。这个过程与工具软件在网络上或是在你的计算机上查找信息的过程类似，即根据输入的关键字得到所有该关键字出现过的位置。这类工具的开发者一般会在下面几点上下工夫来改进这个过程：

* 查询形式；
* 被索引的文件或网页的集合；
* 文件或网页在结果中的排列顺序。

例如，你肯定已经习惯了在网络搜索引擎（它们的基础都是将网络上的大部分页面进行索引）的查询中输入多个关键字进行查找，并得到一组按照相关性或者重要性（对于你或是对于广告商而言）由高到低排序的结果。本节最后的练习中讨论了这里的一些改进。我们会在以后学习和网络搜索有关的各种算法，但符号表仍然会是整个过程的核心工具。

和 `LookupIndex` 一样，你也应该从本书的网站上下载 `FileIndex` 并用它来为你的电脑上的一些文件或是你感兴趣的一些网站建立索引，从而更好地理解符号表的使用。你将会发现即使是根据巨型文件构造庞大的索引，这个工具的耗时也不多，因为每个 `put()` 操作和 `get()` 请求的处理都非常快。确保巨型的动态索引实现即时响应是算法技术的重要胜利之一。

>**文件索引**

>```
>import java.io.File;
>public class FileIndex
>{
>    public static void main(String[] args)
>    {
>       ST<String, SET<File>> st = new ST<String, SET<File>>();
>       for (String filename : args)
>       {
>          File file = new File(filename);
>          In in = new In(file);
>          while (!in.isEmpty())
>          {
>             String word = in.readString();
>             if (!st.contains(word)) st.put(word, new SET<File>());
>             SET<File> set = st.get(word);
>             set.add(file);
>          }
>       }
>       while (!StdIn.isEmpty())
>       {
>          String query = StdIn.readString();
>          if (st.contains(query))
>              for (File file : st.get(query))
>                StdOut.println(" " + file.getName());
>       }
>     }
>}
>```

>这段符号表用例能够为一组文件创建索引。我们将每个文件中的每个单词都记录在符号表中并维护一个 `SET` 对象来保存出现过该单词的文件。`In` 对象接受的名称也可以是网页，因此这段代码也可以用来为一组网页创建反向索引。

>```
>% more ex1.txt
>it was the best of times
>
>% more ex2.txt
>it was the worst of times
>
>% more ex3.txt
>it was the age of wisdom
>
>% more ex4.txt it
>was the age of foolishness
>```

>　

>```
>% java FileIndex ex*.txt
>age
>   ex3.txt
>   ex4.txt
>best
>   ex1.txt
>was
>   ex1.txt
>   ex2.txt
>   ex3.txt
>   ex4.txt
>```

###3.5.5　稀疏向量

下面这个例子展示的是符号表在科学和数学计算领域所起到的重要作用。我们会考察一种重要而常见的计算，它在典型的实际应用中常常是性能的瓶颈，然后我们会演示符号表如何解决这个瓶颈并能够处理规模大得多的问题。实际上，这个计算正是 S. Brin 和 L. Page 发明的 PageRank 算法的核心，这个算法在 2000 年左右造就了 Google（它同时也是一个著名的数学抽象模型，在很多其他场景中都会用到）。

我们要考察的简单计算就是**矩阵和向量的乘法**（如图 3.5.3 所示）：给定一个矩阵和一个向量并计算结果向量，其中第 ![i](https://private.codecogs.com/gif.latex?i) 项的值为矩阵的第 ![i](https://private.codecogs.com/gif.latex?i) 行和给定的向量的**点乘**。为了简化问题，我们只考虑 ![N](https://private.codecogs.com/gif.latex?N) 行 ![N](https://private.codecogs.com/gif.latex?N) 列的方阵，向量的大小也为 ![N](https://private.codecogs.com/gif.latex?N)。在 Java 中，用代码实现这种操作非常简单，但所需的时间和 ![N^2](https://private.codecogs.com/gif.latex?N^2) 成正比，因为 ![N](https://private.codecogs.com/gif.latex?N) 维结果向量中的每一项都需要计算 ![N](https://private.codecogs.com/gif.latex?N) 次乘法。因为需要存储整个矩阵，计算所需的空间也和 ![N^2](https://private.codecogs.com/gif.latex?N^2) 成正比。实现代码如下所示。

![{75%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.074.png)

**图 3.5.3　矩阵和向量的乘法**

在实际应用中，![N](https://private.codecogs.com/gif.latex?N) 往往非常巨大。例如，在刚才提到的 Google 的应用中，![N](https://private.codecogs.com/gif.latex?N) 等于互联网中所有网页的总数。在 PageRank 算法发明的时候，这个数字大概在百亿到千亿之间，但之后一直在暴增。因此，![N^2](https://private.codecogs.com/gif.latex?N^2) 的值应该远远大于 ![10^{20} ](https://private.codecogs.com/gif.latex?10^{20})。没人能够负担起这么多内存和时间来进行这种计算，所以我们需要更好的算法。

幸好，这里的矩阵常常是**稀疏的**，即其中大多数项都是 0。实际上，在 Google 的应用中，每行中的非零项的数量是一个较小的常数：每个网页中指向其他页面的链接其实都很少（相比互联网中所有网页的总数而言）。因此，我们可以将这个矩阵表示为由稀疏向量组成的一个数组，使用 `HashST` 的稀疏向量实现如下面的 `SparseVector` 所示。

```
...
double[][] a = new double[N][N];
double[] x = new double[N];
double[] b = new double[N];
...
// 初始化a[][]和x[]
...
for (int i = 0; i < N; i++)
{
   sum = 0.0;
   for (int j = 0; j < N; j++)
      sum += a[i][j]*x[j];
   b[i] = sum;
}
```

{-:-}矩阵和向量相乘的标准实现

>**能够完成点乘的稀疏向量**

>```
>public class SparseVector
>{
>    private HashST<Integer, Double> st;
>    public SparseVector()
>     {  st = new HashST<Integer, Double>();  }
>    public int size()
>    {  return st.size();  }
>    public void put(int i, double x)
>     {  st.put(i, x);  }
>    public double get(int i)
>    {
>       if (!st.contains(i)) return 0.0;
>       else return st.get(i);
>    }
>    public double dot(double[] that)
>    {
>        double sum = 0.0;
>        for (int i : st.keys())
>            sum += that[i]*this.get(i);
>        return sum;
>    }
>}
>```

>这个符号表的用例实现了稀疏向量的主要功能并高效完成了点乘操作。我们将一个向量中的每一项和另一个向量中对应项相乘并将所有结果相加，所需的乘法操作数量等于稀疏向量中的非零项的数目。

稀疏矩阵的表示如图 3.5.4 所示。

![{90%}](http://www.ituring.com.cn/figures/2018/Algorithms/07.d03z.075.png)

**图 3.5.4　稀疏矩阵的表示**

这里我们不再使用 `a[i][j]` 来访问矩阵中第 `i` 行第 `j` 列的元素，而是使用 `a[i].put(j, val)` 来表示矩阵中的值并使用 `a[i].get(j)` 来获取它。从下面这段代码可以看到，用这种方式实现的矩阵和向量的乘法比数组表示法的实现更简单（也能更清晰地描述乘法的过程）。更重要的是，它所需的时间仅和 ![N](https://private.codecogs.com/gif.latex?N) 加上矩阵中的非零元素的数量成正比。

虽然对于较小或是不那么稀疏的矩阵，使用符号表的代价可能会非常高昂，但你应该理解它对于巨型稀疏矩阵的意义。为了更好地说明这一点，设想一个超大的应用（就像 Brin 和 Page 面对的问题一样），![N](https://private.codecogs.com/gif.latex?N) 可能超过 100 亿或者 1000 亿而平均每行中的非零元素小于 10。对于这种应用，使用符号表能够将矩阵和向量乘法的速度提升 10 亿倍甚至更多。这种应用虽然简单但非常重要，不愿意挖掘其中省时省力的潜力的程序员解决实际问题能力的潜力也必然是有限的，能够将运行速度提升几十亿倍的程序员勇于面对看似无法解决的问题。

构造 Google 所使用的矩阵是一种图的应用（当然也是符号表的一种应用），尽管是一个巨型的稀疏矩阵。有了这个矩阵，PageRank 算法的计算就变成了简单的矩阵和向量之间的乘法运算，不断用结果向量取代计算所使用的向量，重复这个迭代过程直到收敛（这一点是由概率论的基础定理所保证的）。因此，使用一个类似于 `SparseVector` 的类能够将这种应用程序所需的空间和时间改进几百或者几千亿倍，甚至更多。

在许多科学计算中类似的改进都是可能的，因此稀疏向量和矩阵的应用十分广泛，并且一般都会被集成到科学计算专用的库中。在处理庞大的向量或矩阵的时候，你最好用一些简单的性能测试来保证不会错过类似的改进机会。另外，大多数编程语言都拥有处理原始数据类型数组的能力，因此像例子中那样用数组来保存密集的向量也许能提供更好的性能。对于这些应用，有必要深入了解它们的运行瓶颈从而选择合适的数据类型实现。

符号表之所以是算法技术为现代计算机基础设施建设的一大重要贡献，是因为在很多实际应用中它都能够节省大量的运行成本，使得各个领域内许多原来完全无法想象的问题的解决成为可能。科学或是工程领域能够将运行效率提升一千亿倍的发明极少——我们已经在几个例子中看到，符号表做到了，并且这些改进的影响非常深远。但我们学习过的数据结构和算法的演化并没有结束：它们才出现了几十年，我们也并没有完全了解它们的性质。鉴于它们的重要性，符号表的各种实现仍然是全球学者的研究热点。随着它的应用范围不断扩展，我们会在更多领域看到它的新发展。

```
...
SparseVector[] a;
a = new SparseVector[N];
double[] x = new double[N];
double[] b = new double[N];

...
// 初始化 a[] 和 x[]
...
for (int i = 0; i < N; i++)
   b[i] = a[i].dot(x);
```

{-:-}稀疏矩阵和向量的乘法

###答疑

**问**　`SET` 能够包含 `null` 吗？

**答**　不行。和符号表一样，键必须是非空的对象。

**问**　`SET` 可以是 `null` 吗？

**答**　不行。一个 `SET` 集合可以是空的（不包含任何对象），但不能为 `null`。和 Java 的其他数据类型一样，一个 `SET` 类型的变量的值可以是 `null`，但这仅仅意味着它没有指向任何 `SET` 对象。对 `SET` 使用 `new` 的结果必然是一个非空的对象。

**问**　如果能够将所有数据都存储在内存中，那就没有必要使用过滤器了，对吗？

**答**　是的。过滤器最大的用处在于处理输入数据量未知的情况。在其他情况下，它可能会是一种有用的思维方式，但也不是万能的。

**问**　我在一张电子表格中保存了一些数据。我需要开发一个类似于 `LookupCSV` 的程序查找这些数据吗？

**答**　你的电子表格程序应该能够将它们导出为 .csv 的文件，这样你就可以直接使用 `LookupCSV` 了。

**问**　`FileIndex` 程序有什么用？操作系统不能解决这个问题吗？

**答**　如果操作系统能够满足你的需求，当然应该直接使用它的解决方案。和我们的许多例子程序一样，`FileIndex` 也是为了向你展示这些应用程序的基本原理并为你提供其他的可能性。

**问**　为什么 `SparseVector` 的 `dot()` 方法不接受一个 `SparseVector` 对象作为参数并返回一个 `SparseVector` 对象？

**答**　这也是一个不错的设计，它所需的代码比我们的设计稍稍复杂一些，因此也是一道不错的编程练习（请见练习 3.5.16）。对于普通矩阵的处理，我们也许还应该再增加一个 `SparseMatrix` 数据类型。

###练习

**3.5.1**　分别使用 `ST` 和 `HashST` 来实现 `SET` 和 `HashSET`（为键关联虚拟值并忽略它们）。

**3.5.2**　删除 `SequentialSearchST` 中和值相关的所有代码来实现 `SequentialSearchSET`。

**3.5.3**　删除 `BinarySearchST` 中和值相关的所有代码来实现 `BinarySearchSET`。

**3.5.4**　分别为 `int` 和 `double` 两种原始数据类型的键实现 `HashSTint` 类和 `HashSTdouble` 类（将 `LinearProbingHashST` 中的泛型改为原始数据类型）。

**3.5.5**　分别为 `int` 和 `double` 两种原始数据类型的键实现 `STint` 类和 `STdouble` 类（将 `RedBlackBST` 中的泛型改为原始数据类型）。用经过修改的 `SparseVector` 作为用例测试你的答案。

**3.5.6**　分别为 `int` 和 `double` 两种原始数据类型的键实现 `HashSETint` 类和 `HashSETdouble` 类（删去你为练习 3.5.4 给出的答案中所有关于值的代码）。

**3.5.7**　分别为 `int` 和 `double` 两种原始数据类型的键实现 `SETint` 类和 `SETdouble` 类（删去你为练习 3.5.5 给出的答案中所有关于值的代码）。

**3.5.8**　修改 `LinearProbingHashST`，允许在表中保存重复的键。对于 `get()` 方法，返回给定键所关联的任意值；对于 `delete()` 方法，删除表中**所有**和给定键相等的键值对。

**3.5.9**　修改二叉查找树 BST，允许在树中保存重复的键。对于 `get()` 方法，返回给定键所关联的任意值；对于 `delete()` 方法，删除树中**所有**和给定键相等的结点。

**3.5.10**　修改红黑树 RedBlackBST，允许在树中保存重复的键。对于 `get()` 方法，返回给定键所关联的任意值；对于 `delete()` 方法，删除树中所有和给定键相等的结点。

**3.5.11**　开发一个和 `SET` 相似的类 `MultiSET`，允许出现相等的键，也就是实现了数学上的**多重集合**。

**3.5.12**　修改 `LookupCSV`，将每个键和输入中与该键对应的所有值相关联（而非和关联型抽象数组的一样，仅关联最近出现的那个值）。

**3.5.13**　修改 `LookupCSV` 为 `RangeLookupCSV`，从标准输入接受两个键并打印出 .csv 文件中所有在该范围之内的键值对。

**3.5.14**　编写并测试方法 `invert()`，它接受参数 `ST<String, Bag<String>>` 并返回给定符号表的反向索引（一个相同类型的符号表）。

**3.5.15**　编写一个程序，从标准输入接受一个字符串并从命令行参数获得一个整数 ![k](https://private.codecogs.com/gif.latex?k) 作为参数，在标准输出中有序打印出在字符串中找到的 ![k](https://private.codecogs.com/gif.latex?k) 元文法（![k-{\rm gram}](https://private.codecogs.com/gif.latex?k-{\rm%20gram})），以及每个 ![k-{\rm gram}](https://private.codecogs.com/gif.latex?k-{\rm%20gram}) 在字符串中的位置。

**3.5.16**　为 `SparseVector` 添加一个 `sum()` 方法，接受一个 `SparseVector` 对象作为参数并将两者相加的结果返回为一个 `SparseVector` 对象。**请注意**：你需要使用 `delete()` 方法来处理向量中的一项变为 0 的情况（请特别注意精度）。

###提高题

**3.5.17**　**数学集合**。你的目标是实现表 3.5.6 中 `MathSET` 的 API 来处理（可变的）数学集合。

**表 3.5.6　一种简单的集合数据类型的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>Public class <b>MathSET</b>&lt;Key></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MathSET(Key[] universe)</code></td><td>创建一个集合</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void add(Key key)</code></td><td>将 <code>key</code> 加入集合</td></tr>
<tr><td><code>MathSET&lt;Key> complement()</code></td><td>所有在 <code>Universe</code> 中并且不在该集合中的键的集合</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void union(MathSET&lt;Key> a)</code></td><td>将 <code>a</code> 中所有不在该集合中的键加入该集合（并集）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void intersection(MathSET&lt;Key> a)</code></td><td>将该集合中所有不在 <code>a</code> 中的键删除（交集）</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void delete(Key key)</code></td><td>将 <code>key</code> 从集合中删去</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean contains(Key key)</code></td><td>集合中是否存在键 <code>key</code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean isEmpty()</code></td><td>集合是否为空</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size()</code></td><td>集合中键的总数</td></tr>
</table>

　　　请使用符号表来实现它。**附加题**：使用 `boolean` 类型的数组来表示集合。

**3.5.18**　**多重集合**。请参考练习 3.5.2、练习 3.5.3 以及前面的练习，为无序和有序的多重集合（可以含有相同的键的集合）给出 `MultiHashSET` 和 `MultiSET` 的 API，并分别用 `SeparateChainingMultiSET` 和 `BinarySearchMultiSET` 实现它们。

**3.5.19**　**符号表中的等值键**。（有序的和无序的）`MultiST` 的 API 分别和表 3.1.2 以及表 3.1.4 中定义的符号表 API 相同，只是允许存在等值的键。因此，`get()` 方法的行为是返回给定键所关联的**任意值**。另外，我们还需要添加一个新方法来返回和给定键关联的**所有值**：

```
Iterable<Value> getAll(Key key)
```

　　　根据我们的 `SeparateChainingHashST` 和 `BinarySearchST` 的代码来实现 `SeparateChainingMultiST` 和 `BinarySearchMultiST` 的 API。

**3.5.20**　**对照索引**。编写一个 ST 的用例 Concordance，为从标准输入得到的字符串构建对照索引并打印出来（请见 320 页“图书索引”段落中“对照索引”的定义）。

**3.5.21**　**反向对照索引**。编写一个程序 InvertedConcordance，从标准输入接受一个对照索引并在标准输出中打印出原始的字符串。**注意**：这个计算和著名的“死海卷轴”故事有关。最早发现原始石板的团队仅公开了用一种不为人知的方式生成的对照索引。一段时间之后其他研究者才找到了如何将这种索引还原的方法，并最终将石板上的全文公之于众。

**3.5.22**　**完全索引的 CSV 文件**。编写一个 ST 的用例 `FullLookupCSV`，构造一个 `ST` 对象的数组（每列一个），以及一个允许使用者指定键和值的列的测试用例。

**3.5.23**　**稀疏矩阵**。为稀疏二维矩阵设计一组 API 并将它实现，支持矩阵的加法和乘法操作。包含分别能够指定行和列向量的构造函数。

**3.5.24**　**不重叠的区间查找**。给定对象的一组互不重叠的区间，编写一个函数接受一个对象作为参数并判断它是否存在于其中任何一个区间之内。例如，如果对象是整数而区间为 1643-2033，5532-7643，8999-10332，5666653-5669321，那么查询 9122 的结果为第三个区间，而 8122 的结果是不在任何区间。

**3.5.25**　**登记员的日程安排**。东北部某著名大学的注册主任最近作出的安排中有一位老师需要在同一时间为两个不同的班级授课。请用一种方法来检查类似的冲突，帮助这位主任不要再犯同样的错误。简单起见，假设每节课的时间为 50 分钟，分别从 9:00、10:00、11:00、1:00、2:00 和 3:00 开始。

**3.5.26**　**LRU 缓存**。创建一个支持以下操作的数据结构：访问和删除。访问操作会将不存在于数据结构中的元素插入。删除操作会删除并返回最近最少访问的元素。**提示**：将元素按照访问的先后顺序保存在一条双向链表之中，并保存指向开头和结尾元素的指针。将元素和元素在链表中的位置分别作为键和相应的值保存在一张符号表中。当你访问一个元素时，将它从链表中删除并重新插入链表的头部。当你删除一个元素时，将它从链表的尾部和符号表中删除。

**3.5.27**　**列表**。实现表 3.5.7 中的 API：

**表 3.5.7　列表数据类型的 API**

<table class="table table-bordered table-striped table-condensed">
<tr><td colspan="2"><code>Public class <b>List</b>&lt;Item> implements Iterable&lt;Item></code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List()</code></td><td>创建一个列表</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void addFront(Item item)</code></td><td>将 <code>item</code> 添加到列表的头部</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void addBack(Item item)</code></td><td>将 <code>item</code> 添加到列表的尾部</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item deleteFront()</code></td><td>删除列表头部的元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item deleteBack()</code></td><td>删除列表尾部的元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void delete(Item item)</code></td><td>从列表中删除 <code>item</code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void add(int i, Item item)</code></td><td>将 <code>item</code> 添加为列表的第 <code>i</code> 个元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Item delete(int i)</code></td><td>从列表中删除第 <code>i</code> 个元素</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean contains(Item item)</code></td><td>列表中是否存在元素 <code>item</code></td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean isEmpty()</code></td><td>列表是否为空</td></tr>
<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size()</code></td><td>列表中元素的总数</td></tr>
</table>

　　　**提示**：使用两个符号表，一个用来快速定位列表中的第 `i` 个元素，另一个用来快速根据元素查找。（Java 的 `java.util.List` 包含类似的方法，但它的实现的操作并不都是高效的。）

**3.5.28**　`uniQueue`。创建一个类似于队列的数据类型，但每个元素只能插入队列一次。用一个符号表来记录所有已经被插入的元素并忽略所有将它们重新插入的请求。

**3.5.29**　**支持随机访问的符号表**。创建一个数据结构，能够向其中插入键值对，查找一个键并返回相应的值以及删除并返回一个随机的键。**提示**：将一个符号表和一个随机队列结合起来实现该数据结构。

###实验题

**3.5.30**　**重复元素（续）**。使用 3.5.2.1 节的 dedup 过滤器重新完成练习 2.5.31。比较两种解决方法的运行时间。然后使用 dedup 运行试验，其中 ![N=10^7](https://private.codecogs.com/gif.latex?N=10^7)、![10^8](https://private.codecogs.com/gif.latex?10^8) 和 ![10^9](https://private.codecogs.com/gif.latex?10^9)。使用随机的 `long` 值重新完成试验并讨论结果。

**3.5.31**　**拼写检查**。将本书网站上的 dictionary.txt 文件作为命令行参数，用 3.5.2.2 节的 BlackFilter 程序打印出从标准输入接受的文本文件中所有拼写错误的单词。在这个测试中分别使用 `RedBlackBST`、`SeparateChainingHashST` 和 `LinearProbingHashST` 处理 WarAndPeace.txt（本书网站提供）并讨论结果。

**3.5.32**　**字典**。在一个性能优先的场景中研究类似于 LookupCSV 用例的性能。请设计一个查询生成器来代替标准输入并用大量的输入和查询来测试用例的性能。

**3.5.33**　**索引**。在一个性能优先的场景中研究类似于 LookupIndex 用例的性能。请设计一个查询生成器来代替标准输入并用大量的输入和查询来测试用例的性能。

**3.5.34**　**稀疏向量**。用实验来比较使用稀疏矩阵和使用标准数组实现矩阵向量乘法的性能。

**3.5.35**　**原始数据类型**。对于 `LinearProbingHashST` 和 `RedBlackBST`，评估使用原始数据类型来表示 `Integer` 和 `Double` 值的情况。如果在一张巨型的符号表中进行大量的查找，这么做能节省多少空间和时间？